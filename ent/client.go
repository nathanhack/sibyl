// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/nathanhack/sibyl/ent/migrate"

	"github.com/nathanhack/sibyl/ent/bargroup"
	"github.com/nathanhack/sibyl/ent/barrecord"
	"github.com/nathanhack/sibyl/ent/bartimerange"
	"github.com/nathanhack/sibyl/ent/datasource"
	"github.com/nathanhack/sibyl/ent/dividend"
	"github.com/nathanhack/sibyl/ent/entity"
	"github.com/nathanhack/sibyl/ent/exchange"
	"github.com/nathanhack/sibyl/ent/financial"
	"github.com/nathanhack/sibyl/ent/interval"
	"github.com/nathanhack/sibyl/ent/markethours"
	"github.com/nathanhack/sibyl/ent/marketinfo"
	"github.com/nathanhack/sibyl/ent/split"
	"github.com/nathanhack/sibyl/ent/tradecondition"
	"github.com/nathanhack/sibyl/ent/tradecorrection"
	"github.com/nathanhack/sibyl/ent/traderecord"
	"github.com/nathanhack/sibyl/ent/tradetimerange"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// BarGroup is the client for interacting with the BarGroup builders.
	BarGroup *BarGroupClient
	// BarRecord is the client for interacting with the BarRecord builders.
	BarRecord *BarRecordClient
	// BarTimeRange is the client for interacting with the BarTimeRange builders.
	BarTimeRange *BarTimeRangeClient
	// DataSource is the client for interacting with the DataSource builders.
	DataSource *DataSourceClient
	// Dividend is the client for interacting with the Dividend builders.
	Dividend *DividendClient
	// Entity is the client for interacting with the Entity builders.
	Entity *EntityClient
	// Exchange is the client for interacting with the Exchange builders.
	Exchange *ExchangeClient
	// Financial is the client for interacting with the Financial builders.
	Financial *FinancialClient
	// Interval is the client for interacting with the Interval builders.
	Interval *IntervalClient
	// MarketHours is the client for interacting with the MarketHours builders.
	MarketHours *MarketHoursClient
	// MarketInfo is the client for interacting with the MarketInfo builders.
	MarketInfo *MarketInfoClient
	// Split is the client for interacting with the Split builders.
	Split *SplitClient
	// TradeCondition is the client for interacting with the TradeCondition builders.
	TradeCondition *TradeConditionClient
	// TradeCorrection is the client for interacting with the TradeCorrection builders.
	TradeCorrection *TradeCorrectionClient
	// TradeRecord is the client for interacting with the TradeRecord builders.
	TradeRecord *TradeRecordClient
	// TradeTimeRange is the client for interacting with the TradeTimeRange builders.
	TradeTimeRange *TradeTimeRangeClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.BarGroup = NewBarGroupClient(c.config)
	c.BarRecord = NewBarRecordClient(c.config)
	c.BarTimeRange = NewBarTimeRangeClient(c.config)
	c.DataSource = NewDataSourceClient(c.config)
	c.Dividend = NewDividendClient(c.config)
	c.Entity = NewEntityClient(c.config)
	c.Exchange = NewExchangeClient(c.config)
	c.Financial = NewFinancialClient(c.config)
	c.Interval = NewIntervalClient(c.config)
	c.MarketHours = NewMarketHoursClient(c.config)
	c.MarketInfo = NewMarketInfoClient(c.config)
	c.Split = NewSplitClient(c.config)
	c.TradeCondition = NewTradeConditionClient(c.config)
	c.TradeCorrection = NewTradeCorrectionClient(c.config)
	c.TradeRecord = NewTradeRecordClient(c.config)
	c.TradeTimeRange = NewTradeTimeRangeClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		BarGroup:        NewBarGroupClient(cfg),
		BarRecord:       NewBarRecordClient(cfg),
		BarTimeRange:    NewBarTimeRangeClient(cfg),
		DataSource:      NewDataSourceClient(cfg),
		Dividend:        NewDividendClient(cfg),
		Entity:          NewEntityClient(cfg),
		Exchange:        NewExchangeClient(cfg),
		Financial:       NewFinancialClient(cfg),
		Interval:        NewIntervalClient(cfg),
		MarketHours:     NewMarketHoursClient(cfg),
		MarketInfo:      NewMarketInfoClient(cfg),
		Split:           NewSplitClient(cfg),
		TradeCondition:  NewTradeConditionClient(cfg),
		TradeCorrection: NewTradeCorrectionClient(cfg),
		TradeRecord:     NewTradeRecordClient(cfg),
		TradeTimeRange:  NewTradeTimeRangeClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		BarGroup:        NewBarGroupClient(cfg),
		BarRecord:       NewBarRecordClient(cfg),
		BarTimeRange:    NewBarTimeRangeClient(cfg),
		DataSource:      NewDataSourceClient(cfg),
		Dividend:        NewDividendClient(cfg),
		Entity:          NewEntityClient(cfg),
		Exchange:        NewExchangeClient(cfg),
		Financial:       NewFinancialClient(cfg),
		Interval:        NewIntervalClient(cfg),
		MarketHours:     NewMarketHoursClient(cfg),
		MarketInfo:      NewMarketInfoClient(cfg),
		Split:           NewSplitClient(cfg),
		TradeCondition:  NewTradeConditionClient(cfg),
		TradeCorrection: NewTradeCorrectionClient(cfg),
		TradeRecord:     NewTradeRecordClient(cfg),
		TradeTimeRange:  NewTradeTimeRangeClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		BarGroup.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.BarGroup.Use(hooks...)
	c.BarRecord.Use(hooks...)
	c.BarTimeRange.Use(hooks...)
	c.DataSource.Use(hooks...)
	c.Dividend.Use(hooks...)
	c.Entity.Use(hooks...)
	c.Exchange.Use(hooks...)
	c.Financial.Use(hooks...)
	c.Interval.Use(hooks...)
	c.MarketHours.Use(hooks...)
	c.MarketInfo.Use(hooks...)
	c.Split.Use(hooks...)
	c.TradeCondition.Use(hooks...)
	c.TradeCorrection.Use(hooks...)
	c.TradeRecord.Use(hooks...)
	c.TradeTimeRange.Use(hooks...)
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	c.BarGroup.Intercept(interceptors...)
	c.BarRecord.Intercept(interceptors...)
	c.BarTimeRange.Intercept(interceptors...)
	c.DataSource.Intercept(interceptors...)
	c.Dividend.Intercept(interceptors...)
	c.Entity.Intercept(interceptors...)
	c.Exchange.Intercept(interceptors...)
	c.Financial.Intercept(interceptors...)
	c.Interval.Intercept(interceptors...)
	c.MarketHours.Intercept(interceptors...)
	c.MarketInfo.Intercept(interceptors...)
	c.Split.Intercept(interceptors...)
	c.TradeCondition.Intercept(interceptors...)
	c.TradeCorrection.Intercept(interceptors...)
	c.TradeRecord.Intercept(interceptors...)
	c.TradeTimeRange.Intercept(interceptors...)
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *BarGroupMutation:
		return c.BarGroup.mutate(ctx, m)
	case *BarRecordMutation:
		return c.BarRecord.mutate(ctx, m)
	case *BarTimeRangeMutation:
		return c.BarTimeRange.mutate(ctx, m)
	case *DataSourceMutation:
		return c.DataSource.mutate(ctx, m)
	case *DividendMutation:
		return c.Dividend.mutate(ctx, m)
	case *EntityMutation:
		return c.Entity.mutate(ctx, m)
	case *ExchangeMutation:
		return c.Exchange.mutate(ctx, m)
	case *FinancialMutation:
		return c.Financial.mutate(ctx, m)
	case *IntervalMutation:
		return c.Interval.mutate(ctx, m)
	case *MarketHoursMutation:
		return c.MarketHours.mutate(ctx, m)
	case *MarketInfoMutation:
		return c.MarketInfo.mutate(ctx, m)
	case *SplitMutation:
		return c.Split.mutate(ctx, m)
	case *TradeConditionMutation:
		return c.TradeCondition.mutate(ctx, m)
	case *TradeCorrectionMutation:
		return c.TradeCorrection.mutate(ctx, m)
	case *TradeRecordMutation:
		return c.TradeRecord.mutate(ctx, m)
	case *TradeTimeRangeMutation:
		return c.TradeTimeRange.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// BarGroupClient is a client for the BarGroup schema.
type BarGroupClient struct {
	config
}

// NewBarGroupClient returns a client for the BarGroup from the given config.
func NewBarGroupClient(c config) *BarGroupClient {
	return &BarGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bargroup.Hooks(f(g(h())))`.
func (c *BarGroupClient) Use(hooks ...Hook) {
	c.hooks.BarGroup = append(c.hooks.BarGroup, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `bargroup.Intercept(f(g(h())))`.
func (c *BarGroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.BarGroup = append(c.inters.BarGroup, interceptors...)
}

// Create returns a builder for creating a BarGroup entity.
func (c *BarGroupClient) Create() *BarGroupCreate {
	mutation := newBarGroupMutation(c.config, OpCreate)
	return &BarGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BarGroup entities.
func (c *BarGroupClient) CreateBulk(builders ...*BarGroupCreate) *BarGroupCreateBulk {
	return &BarGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BarGroup.
func (c *BarGroupClient) Update() *BarGroupUpdate {
	mutation := newBarGroupMutation(c.config, OpUpdate)
	return &BarGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BarGroupClient) UpdateOne(bg *BarGroup) *BarGroupUpdateOne {
	mutation := newBarGroupMutation(c.config, OpUpdateOne, withBarGroup(bg))
	return &BarGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BarGroupClient) UpdateOneID(id int) *BarGroupUpdateOne {
	mutation := newBarGroupMutation(c.config, OpUpdateOne, withBarGroupID(id))
	return &BarGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BarGroup.
func (c *BarGroupClient) Delete() *BarGroupDelete {
	mutation := newBarGroupMutation(c.config, OpDelete)
	return &BarGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BarGroupClient) DeleteOne(bg *BarGroup) *BarGroupDeleteOne {
	return c.DeleteOneID(bg.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BarGroupClient) DeleteOneID(id int) *BarGroupDeleteOne {
	builder := c.Delete().Where(bargroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BarGroupDeleteOne{builder}
}

// Query returns a query builder for BarGroup.
func (c *BarGroupClient) Query() *BarGroupQuery {
	return &BarGroupQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a BarGroup entity by its id.
func (c *BarGroupClient) Get(ctx context.Context, id int) (*BarGroup, error) {
	return c.Query().Where(bargroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BarGroupClient) GetX(ctx context.Context, id int) *BarGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTimeRange queries the time_range edge of a BarGroup.
func (c *BarGroupClient) QueryTimeRange(bg *BarGroup) *BarTimeRangeQuery {
	query := (&BarTimeRangeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bg.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bargroup.Table, bargroup.FieldID, id),
			sqlgraph.To(bartimerange.Table, bartimerange.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bargroup.TimeRangeTable, bargroup.TimeRangeColumn),
		)
		fromV = sqlgraph.Neighbors(bg.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRecords queries the records edge of a BarGroup.
func (c *BarGroupClient) QueryRecords(bg *BarGroup) *BarRecordQuery {
	query := (&BarRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bg.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bargroup.Table, bargroup.FieldID, id),
			sqlgraph.To(barrecord.Table, barrecord.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, bargroup.RecordsTable, bargroup.RecordsColumn),
		)
		fromV = sqlgraph.Neighbors(bg.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BarGroupClient) Hooks() []Hook {
	return c.hooks.BarGroup
}

// Interceptors returns the client interceptors.
func (c *BarGroupClient) Interceptors() []Interceptor {
	return c.inters.BarGroup
}

func (c *BarGroupClient) mutate(ctx context.Context, m *BarGroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BarGroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BarGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BarGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BarGroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BarGroup mutation op: %q", m.Op())
	}
}

// BarRecordClient is a client for the BarRecord schema.
type BarRecordClient struct {
	config
}

// NewBarRecordClient returns a client for the BarRecord from the given config.
func NewBarRecordClient(c config) *BarRecordClient {
	return &BarRecordClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `barrecord.Hooks(f(g(h())))`.
func (c *BarRecordClient) Use(hooks ...Hook) {
	c.hooks.BarRecord = append(c.hooks.BarRecord, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `barrecord.Intercept(f(g(h())))`.
func (c *BarRecordClient) Intercept(interceptors ...Interceptor) {
	c.inters.BarRecord = append(c.inters.BarRecord, interceptors...)
}

// Create returns a builder for creating a BarRecord entity.
func (c *BarRecordClient) Create() *BarRecordCreate {
	mutation := newBarRecordMutation(c.config, OpCreate)
	return &BarRecordCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BarRecord entities.
func (c *BarRecordClient) CreateBulk(builders ...*BarRecordCreate) *BarRecordCreateBulk {
	return &BarRecordCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BarRecord.
func (c *BarRecordClient) Update() *BarRecordUpdate {
	mutation := newBarRecordMutation(c.config, OpUpdate)
	return &BarRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BarRecordClient) UpdateOne(br *BarRecord) *BarRecordUpdateOne {
	mutation := newBarRecordMutation(c.config, OpUpdateOne, withBarRecord(br))
	return &BarRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BarRecordClient) UpdateOneID(id int) *BarRecordUpdateOne {
	mutation := newBarRecordMutation(c.config, OpUpdateOne, withBarRecordID(id))
	return &BarRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BarRecord.
func (c *BarRecordClient) Delete() *BarRecordDelete {
	mutation := newBarRecordMutation(c.config, OpDelete)
	return &BarRecordDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BarRecordClient) DeleteOne(br *BarRecord) *BarRecordDeleteOne {
	return c.DeleteOneID(br.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BarRecordClient) DeleteOneID(id int) *BarRecordDeleteOne {
	builder := c.Delete().Where(barrecord.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BarRecordDeleteOne{builder}
}

// Query returns a query builder for BarRecord.
func (c *BarRecordClient) Query() *BarRecordQuery {
	return &BarRecordQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a BarRecord entity by its id.
func (c *BarRecordClient) Get(ctx context.Context, id int) (*BarRecord, error) {
	return c.Query().Where(barrecord.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BarRecordClient) GetX(ctx context.Context, id int) *BarRecord {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGroup queries the group edge of a BarRecord.
func (c *BarRecordClient) QueryGroup(br *BarRecord) *BarGroupQuery {
	query := (&BarGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := br.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(barrecord.Table, barrecord.FieldID, id),
			sqlgraph.To(bargroup.Table, bargroup.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, barrecord.GroupTable, barrecord.GroupColumn),
		)
		fromV = sqlgraph.Neighbors(br.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BarRecordClient) Hooks() []Hook {
	return c.hooks.BarRecord
}

// Interceptors returns the client interceptors.
func (c *BarRecordClient) Interceptors() []Interceptor {
	return c.inters.BarRecord
}

func (c *BarRecordClient) mutate(ctx context.Context, m *BarRecordMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BarRecordCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BarRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BarRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BarRecordDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BarRecord mutation op: %q", m.Op())
	}
}

// BarTimeRangeClient is a client for the BarTimeRange schema.
type BarTimeRangeClient struct {
	config
}

// NewBarTimeRangeClient returns a client for the BarTimeRange from the given config.
func NewBarTimeRangeClient(c config) *BarTimeRangeClient {
	return &BarTimeRangeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bartimerange.Hooks(f(g(h())))`.
func (c *BarTimeRangeClient) Use(hooks ...Hook) {
	c.hooks.BarTimeRange = append(c.hooks.BarTimeRange, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `bartimerange.Intercept(f(g(h())))`.
func (c *BarTimeRangeClient) Intercept(interceptors ...Interceptor) {
	c.inters.BarTimeRange = append(c.inters.BarTimeRange, interceptors...)
}

// Create returns a builder for creating a BarTimeRange entity.
func (c *BarTimeRangeClient) Create() *BarTimeRangeCreate {
	mutation := newBarTimeRangeMutation(c.config, OpCreate)
	return &BarTimeRangeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BarTimeRange entities.
func (c *BarTimeRangeClient) CreateBulk(builders ...*BarTimeRangeCreate) *BarTimeRangeCreateBulk {
	return &BarTimeRangeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BarTimeRange.
func (c *BarTimeRangeClient) Update() *BarTimeRangeUpdate {
	mutation := newBarTimeRangeMutation(c.config, OpUpdate)
	return &BarTimeRangeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BarTimeRangeClient) UpdateOne(btr *BarTimeRange) *BarTimeRangeUpdateOne {
	mutation := newBarTimeRangeMutation(c.config, OpUpdateOne, withBarTimeRange(btr))
	return &BarTimeRangeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BarTimeRangeClient) UpdateOneID(id int) *BarTimeRangeUpdateOne {
	mutation := newBarTimeRangeMutation(c.config, OpUpdateOne, withBarTimeRangeID(id))
	return &BarTimeRangeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BarTimeRange.
func (c *BarTimeRangeClient) Delete() *BarTimeRangeDelete {
	mutation := newBarTimeRangeMutation(c.config, OpDelete)
	return &BarTimeRangeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BarTimeRangeClient) DeleteOne(btr *BarTimeRange) *BarTimeRangeDeleteOne {
	return c.DeleteOneID(btr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BarTimeRangeClient) DeleteOneID(id int) *BarTimeRangeDeleteOne {
	builder := c.Delete().Where(bartimerange.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BarTimeRangeDeleteOne{builder}
}

// Query returns a query builder for BarTimeRange.
func (c *BarTimeRangeClient) Query() *BarTimeRangeQuery {
	return &BarTimeRangeQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a BarTimeRange entity by its id.
func (c *BarTimeRangeClient) Get(ctx context.Context, id int) (*BarTimeRange, error) {
	return c.Query().Where(bartimerange.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BarTimeRangeClient) GetX(ctx context.Context, id int) *BarTimeRange {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInterval queries the interval edge of a BarTimeRange.
func (c *BarTimeRangeClient) QueryInterval(btr *BarTimeRange) *IntervalQuery {
	query := (&IntervalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := btr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bartimerange.Table, bartimerange.FieldID, id),
			sqlgraph.To(interval.Table, interval.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bartimerange.IntervalTable, bartimerange.IntervalColumn),
		)
		fromV = sqlgraph.Neighbors(btr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroups queries the groups edge of a BarTimeRange.
func (c *BarTimeRangeClient) QueryGroups(btr *BarTimeRange) *BarGroupQuery {
	query := (&BarGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := btr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bartimerange.Table, bartimerange.FieldID, id),
			sqlgraph.To(bargroup.Table, bargroup.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, bartimerange.GroupsTable, bartimerange.GroupsColumn),
		)
		fromV = sqlgraph.Neighbors(btr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BarTimeRangeClient) Hooks() []Hook {
	return c.hooks.BarTimeRange
}

// Interceptors returns the client interceptors.
func (c *BarTimeRangeClient) Interceptors() []Interceptor {
	return c.inters.BarTimeRange
}

func (c *BarTimeRangeClient) mutate(ctx context.Context, m *BarTimeRangeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BarTimeRangeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BarTimeRangeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BarTimeRangeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BarTimeRangeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BarTimeRange mutation op: %q", m.Op())
	}
}

// DataSourceClient is a client for the DataSource schema.
type DataSourceClient struct {
	config
}

// NewDataSourceClient returns a client for the DataSource from the given config.
func NewDataSourceClient(c config) *DataSourceClient {
	return &DataSourceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `datasource.Hooks(f(g(h())))`.
func (c *DataSourceClient) Use(hooks ...Hook) {
	c.hooks.DataSource = append(c.hooks.DataSource, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `datasource.Intercept(f(g(h())))`.
func (c *DataSourceClient) Intercept(interceptors ...Interceptor) {
	c.inters.DataSource = append(c.inters.DataSource, interceptors...)
}

// Create returns a builder for creating a DataSource entity.
func (c *DataSourceClient) Create() *DataSourceCreate {
	mutation := newDataSourceMutation(c.config, OpCreate)
	return &DataSourceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DataSource entities.
func (c *DataSourceClient) CreateBulk(builders ...*DataSourceCreate) *DataSourceCreateBulk {
	return &DataSourceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DataSource.
func (c *DataSourceClient) Update() *DataSourceUpdate {
	mutation := newDataSourceMutation(c.config, OpUpdate)
	return &DataSourceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DataSourceClient) UpdateOne(ds *DataSource) *DataSourceUpdateOne {
	mutation := newDataSourceMutation(c.config, OpUpdateOne, withDataSource(ds))
	return &DataSourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DataSourceClient) UpdateOneID(id int) *DataSourceUpdateOne {
	mutation := newDataSourceMutation(c.config, OpUpdateOne, withDataSourceID(id))
	return &DataSourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DataSource.
func (c *DataSourceClient) Delete() *DataSourceDelete {
	mutation := newDataSourceMutation(c.config, OpDelete)
	return &DataSourceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DataSourceClient) DeleteOne(ds *DataSource) *DataSourceDeleteOne {
	return c.DeleteOneID(ds.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DataSourceClient) DeleteOneID(id int) *DataSourceDeleteOne {
	builder := c.Delete().Where(datasource.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DataSourceDeleteOne{builder}
}

// Query returns a query builder for DataSource.
func (c *DataSourceClient) Query() *DataSourceQuery {
	return &DataSourceQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a DataSource entity by its id.
func (c *DataSourceClient) Get(ctx context.Context, id int) (*DataSource, error) {
	return c.Query().Where(datasource.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DataSourceClient) GetX(ctx context.Context, id int) *DataSource {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIntervals queries the intervals edge of a DataSource.
func (c *DataSourceClient) QueryIntervals(ds *DataSource) *IntervalQuery {
	query := (&IntervalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ds.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(datasource.Table, datasource.FieldID, id),
			sqlgraph.To(interval.Table, interval.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, datasource.IntervalsTable, datasource.IntervalsColumn),
		)
		fromV = sqlgraph.Neighbors(ds.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DataSourceClient) Hooks() []Hook {
	return c.hooks.DataSource
}

// Interceptors returns the client interceptors.
func (c *DataSourceClient) Interceptors() []Interceptor {
	return c.inters.DataSource
}

func (c *DataSourceClient) mutate(ctx context.Context, m *DataSourceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DataSourceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DataSourceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DataSourceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DataSourceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DataSource mutation op: %q", m.Op())
	}
}

// DividendClient is a client for the Dividend schema.
type DividendClient struct {
	config
}

// NewDividendClient returns a client for the Dividend from the given config.
func NewDividendClient(c config) *DividendClient {
	return &DividendClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dividend.Hooks(f(g(h())))`.
func (c *DividendClient) Use(hooks ...Hook) {
	c.hooks.Dividend = append(c.hooks.Dividend, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dividend.Intercept(f(g(h())))`.
func (c *DividendClient) Intercept(interceptors ...Interceptor) {
	c.inters.Dividend = append(c.inters.Dividend, interceptors...)
}

// Create returns a builder for creating a Dividend entity.
func (c *DividendClient) Create() *DividendCreate {
	mutation := newDividendMutation(c.config, OpCreate)
	return &DividendCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Dividend entities.
func (c *DividendClient) CreateBulk(builders ...*DividendCreate) *DividendCreateBulk {
	return &DividendCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Dividend.
func (c *DividendClient) Update() *DividendUpdate {
	mutation := newDividendMutation(c.config, OpUpdate)
	return &DividendUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DividendClient) UpdateOne(d *Dividend) *DividendUpdateOne {
	mutation := newDividendMutation(c.config, OpUpdateOne, withDividend(d))
	return &DividendUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DividendClient) UpdateOneID(id int) *DividendUpdateOne {
	mutation := newDividendMutation(c.config, OpUpdateOne, withDividendID(id))
	return &DividendUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Dividend.
func (c *DividendClient) Delete() *DividendDelete {
	mutation := newDividendMutation(c.config, OpDelete)
	return &DividendDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DividendClient) DeleteOne(d *Dividend) *DividendDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DividendClient) DeleteOneID(id int) *DividendDeleteOne {
	builder := c.Delete().Where(dividend.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DividendDeleteOne{builder}
}

// Query returns a query builder for Dividend.
func (c *DividendClient) Query() *DividendQuery {
	return &DividendQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Dividend entity by its id.
func (c *DividendClient) Get(ctx context.Context, id int) (*Dividend, error) {
	return c.Query().Where(dividend.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DividendClient) GetX(ctx context.Context, id int) *Dividend {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStock queries the stock edge of a Dividend.
func (c *DividendClient) QueryStock(d *Dividend) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dividend.Table, dividend.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, dividend.StockTable, dividend.StockPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DividendClient) Hooks() []Hook {
	return c.hooks.Dividend
}

// Interceptors returns the client interceptors.
func (c *DividendClient) Interceptors() []Interceptor {
	return c.inters.Dividend
}

func (c *DividendClient) mutate(ctx context.Context, m *DividendMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DividendCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DividendUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DividendUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DividendDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Dividend mutation op: %q", m.Op())
	}
}

// EntityClient is a client for the Entity schema.
type EntityClient struct {
	config
}

// NewEntityClient returns a client for the Entity from the given config.
func NewEntityClient(c config) *EntityClient {
	return &EntityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entity.Hooks(f(g(h())))`.
func (c *EntityClient) Use(hooks ...Hook) {
	c.hooks.Entity = append(c.hooks.Entity, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entity.Intercept(f(g(h())))`.
func (c *EntityClient) Intercept(interceptors ...Interceptor) {
	c.inters.Entity = append(c.inters.Entity, interceptors...)
}

// Create returns a builder for creating a Entity entity.
func (c *EntityClient) Create() *EntityCreate {
	mutation := newEntityMutation(c.config, OpCreate)
	return &EntityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Entity entities.
func (c *EntityClient) CreateBulk(builders ...*EntityCreate) *EntityCreateBulk {
	return &EntityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Entity.
func (c *EntityClient) Update() *EntityUpdate {
	mutation := newEntityMutation(c.config, OpUpdate)
	return &EntityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntityClient) UpdateOne(e *Entity) *EntityUpdateOne {
	mutation := newEntityMutation(c.config, OpUpdateOne, withEntity(e))
	return &EntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntityClient) UpdateOneID(id int) *EntityUpdateOne {
	mutation := newEntityMutation(c.config, OpUpdateOne, withEntityID(id))
	return &EntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Entity.
func (c *EntityClient) Delete() *EntityDelete {
	mutation := newEntityMutation(c.config, OpDelete)
	return &EntityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntityClient) DeleteOne(e *Entity) *EntityDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntityClient) DeleteOneID(id int) *EntityDeleteOne {
	builder := c.Delete().Where(entity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntityDeleteOne{builder}
}

// Query returns a query builder for Entity.
func (c *EntityClient) Query() *EntityQuery {
	return &EntityQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Entity entity by its id.
func (c *EntityClient) Get(ctx context.Context, id int) (*Entity, error) {
	return c.Query().Where(entity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntityClient) GetX(ctx context.Context, id int) *Entity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExchanges queries the exchanges edge of a Entity.
func (c *EntityClient) QueryExchanges(e *Entity) *ExchangeQuery {
	query := (&ExchangeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(exchange.Table, exchange.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entity.ExchangesTable, entity.ExchangesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIntervals queries the intervals edge of a Entity.
func (c *EntityClient) QueryIntervals(e *Entity) *IntervalQuery {
	query := (&IntervalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(interval.Table, interval.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entity.IntervalsTable, entity.IntervalsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDividends queries the dividends edge of a Entity.
func (c *EntityClient) QueryDividends(e *Entity) *DividendQuery {
	query := (&DividendClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(dividend.Table, dividend.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entity.DividendsTable, entity.DividendsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySplits queries the splits edge of a Entity.
func (c *EntityClient) QuerySplits(e *Entity) *SplitQuery {
	query := (&SplitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(split.Table, split.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entity.SplitsTable, entity.SplitsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFinancials queries the financials edge of a Entity.
func (c *EntityClient) QueryFinancials(e *Entity) *FinancialQuery {
	query := (&FinancialClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entity.Table, entity.FieldID, id),
			sqlgraph.To(financial.Table, financial.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, entity.FinancialsTable, entity.FinancialsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntityClient) Hooks() []Hook {
	return c.hooks.Entity
}

// Interceptors returns the client interceptors.
func (c *EntityClient) Interceptors() []Interceptor {
	return c.inters.Entity
}

func (c *EntityClient) mutate(ctx context.Context, m *EntityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Entity mutation op: %q", m.Op())
	}
}

// ExchangeClient is a client for the Exchange schema.
type ExchangeClient struct {
	config
}

// NewExchangeClient returns a client for the Exchange from the given config.
func NewExchangeClient(c config) *ExchangeClient {
	return &ExchangeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `exchange.Hooks(f(g(h())))`.
func (c *ExchangeClient) Use(hooks ...Hook) {
	c.hooks.Exchange = append(c.hooks.Exchange, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `exchange.Intercept(f(g(h())))`.
func (c *ExchangeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Exchange = append(c.inters.Exchange, interceptors...)
}

// Create returns a builder for creating a Exchange entity.
func (c *ExchangeClient) Create() *ExchangeCreate {
	mutation := newExchangeMutation(c.config, OpCreate)
	return &ExchangeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Exchange entities.
func (c *ExchangeClient) CreateBulk(builders ...*ExchangeCreate) *ExchangeCreateBulk {
	return &ExchangeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Exchange.
func (c *ExchangeClient) Update() *ExchangeUpdate {
	mutation := newExchangeMutation(c.config, OpUpdate)
	return &ExchangeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExchangeClient) UpdateOne(e *Exchange) *ExchangeUpdateOne {
	mutation := newExchangeMutation(c.config, OpUpdateOne, withExchange(e))
	return &ExchangeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExchangeClient) UpdateOneID(id int) *ExchangeUpdateOne {
	mutation := newExchangeMutation(c.config, OpUpdateOne, withExchangeID(id))
	return &ExchangeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Exchange.
func (c *ExchangeClient) Delete() *ExchangeDelete {
	mutation := newExchangeMutation(c.config, OpDelete)
	return &ExchangeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExchangeClient) DeleteOne(e *Exchange) *ExchangeDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExchangeClient) DeleteOneID(id int) *ExchangeDeleteOne {
	builder := c.Delete().Where(exchange.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExchangeDeleteOne{builder}
}

// Query returns a query builder for Exchange.
func (c *ExchangeClient) Query() *ExchangeQuery {
	return &ExchangeQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Exchange entity by its id.
func (c *ExchangeClient) Get(ctx context.Context, id int) (*Exchange, error) {
	return c.Query().Where(exchange.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExchangeClient) GetX(ctx context.Context, id int) *Exchange {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStocks queries the stocks edge of a Exchange.
func (c *ExchangeClient) QueryStocks(e *Exchange) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exchange.Table, exchange.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, exchange.StocksTable, exchange.StocksPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExchangeClient) Hooks() []Hook {
	return c.hooks.Exchange
}

// Interceptors returns the client interceptors.
func (c *ExchangeClient) Interceptors() []Interceptor {
	return c.inters.Exchange
}

func (c *ExchangeClient) mutate(ctx context.Context, m *ExchangeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExchangeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExchangeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExchangeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExchangeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Exchange mutation op: %q", m.Op())
	}
}

// FinancialClient is a client for the Financial schema.
type FinancialClient struct {
	config
}

// NewFinancialClient returns a client for the Financial from the given config.
func NewFinancialClient(c config) *FinancialClient {
	return &FinancialClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `financial.Hooks(f(g(h())))`.
func (c *FinancialClient) Use(hooks ...Hook) {
	c.hooks.Financial = append(c.hooks.Financial, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `financial.Intercept(f(g(h())))`.
func (c *FinancialClient) Intercept(interceptors ...Interceptor) {
	c.inters.Financial = append(c.inters.Financial, interceptors...)
}

// Create returns a builder for creating a Financial entity.
func (c *FinancialClient) Create() *FinancialCreate {
	mutation := newFinancialMutation(c.config, OpCreate)
	return &FinancialCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Financial entities.
func (c *FinancialClient) CreateBulk(builders ...*FinancialCreate) *FinancialCreateBulk {
	return &FinancialCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Financial.
func (c *FinancialClient) Update() *FinancialUpdate {
	mutation := newFinancialMutation(c.config, OpUpdate)
	return &FinancialUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FinancialClient) UpdateOne(f *Financial) *FinancialUpdateOne {
	mutation := newFinancialMutation(c.config, OpUpdateOne, withFinancial(f))
	return &FinancialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FinancialClient) UpdateOneID(id int) *FinancialUpdateOne {
	mutation := newFinancialMutation(c.config, OpUpdateOne, withFinancialID(id))
	return &FinancialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Financial.
func (c *FinancialClient) Delete() *FinancialDelete {
	mutation := newFinancialMutation(c.config, OpDelete)
	return &FinancialDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FinancialClient) DeleteOne(f *Financial) *FinancialDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FinancialClient) DeleteOneID(id int) *FinancialDeleteOne {
	builder := c.Delete().Where(financial.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FinancialDeleteOne{builder}
}

// Query returns a query builder for Financial.
func (c *FinancialClient) Query() *FinancialQuery {
	return &FinancialQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Financial entity by its id.
func (c *FinancialClient) Get(ctx context.Context, id int) (*Financial, error) {
	return c.Query().Where(financial.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FinancialClient) GetX(ctx context.Context, id int) *Financial {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStock queries the stock edge of a Financial.
func (c *FinancialClient) QueryStock(f *Financial) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(financial.Table, financial.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, financial.StockTable, financial.StockPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FinancialClient) Hooks() []Hook {
	return c.hooks.Financial
}

// Interceptors returns the client interceptors.
func (c *FinancialClient) Interceptors() []Interceptor {
	return c.inters.Financial
}

func (c *FinancialClient) mutate(ctx context.Context, m *FinancialMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FinancialCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FinancialUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FinancialUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FinancialDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Financial mutation op: %q", m.Op())
	}
}

// IntervalClient is a client for the Interval schema.
type IntervalClient struct {
	config
}

// NewIntervalClient returns a client for the Interval from the given config.
func NewIntervalClient(c config) *IntervalClient {
	return &IntervalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `interval.Hooks(f(g(h())))`.
func (c *IntervalClient) Use(hooks ...Hook) {
	c.hooks.Interval = append(c.hooks.Interval, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `interval.Intercept(f(g(h())))`.
func (c *IntervalClient) Intercept(interceptors ...Interceptor) {
	c.inters.Interval = append(c.inters.Interval, interceptors...)
}

// Create returns a builder for creating a Interval entity.
func (c *IntervalClient) Create() *IntervalCreate {
	mutation := newIntervalMutation(c.config, OpCreate)
	return &IntervalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Interval entities.
func (c *IntervalClient) CreateBulk(builders ...*IntervalCreate) *IntervalCreateBulk {
	return &IntervalCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Interval.
func (c *IntervalClient) Update() *IntervalUpdate {
	mutation := newIntervalMutation(c.config, OpUpdate)
	return &IntervalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IntervalClient) UpdateOne(i *Interval) *IntervalUpdateOne {
	mutation := newIntervalMutation(c.config, OpUpdateOne, withInterval(i))
	return &IntervalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IntervalClient) UpdateOneID(id int) *IntervalUpdateOne {
	mutation := newIntervalMutation(c.config, OpUpdateOne, withIntervalID(id))
	return &IntervalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Interval.
func (c *IntervalClient) Delete() *IntervalDelete {
	mutation := newIntervalMutation(c.config, OpDelete)
	return &IntervalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IntervalClient) DeleteOne(i *Interval) *IntervalDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IntervalClient) DeleteOneID(id int) *IntervalDeleteOne {
	builder := c.Delete().Where(interval.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IntervalDeleteOne{builder}
}

// Query returns a query builder for Interval.
func (c *IntervalClient) Query() *IntervalQuery {
	return &IntervalQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Interval entity by its id.
func (c *IntervalClient) Get(ctx context.Context, id int) (*Interval, error) {
	return c.Query().Where(interval.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IntervalClient) GetX(ctx context.Context, id int) *Interval {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDataSource queries the data_source edge of a Interval.
func (c *IntervalClient) QueryDataSource(i *Interval) *DataSourceQuery {
	query := (&DataSourceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(interval.Table, interval.FieldID, id),
			sqlgraph.To(datasource.Table, datasource.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, interval.DataSourceTable, interval.DataSourceColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStock queries the stock edge of a Interval.
func (c *IntervalClient) QueryStock(i *Interval) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(interval.Table, interval.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, interval.StockTable, interval.StockColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBars queries the bars edge of a Interval.
func (c *IntervalClient) QueryBars(i *Interval) *BarTimeRangeQuery {
	query := (&BarTimeRangeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(interval.Table, interval.FieldID, id),
			sqlgraph.To(bartimerange.Table, bartimerange.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, interval.BarsTable, interval.BarsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTrades queries the trades edge of a Interval.
func (c *IntervalClient) QueryTrades(i *Interval) *TradeTimeRangeQuery {
	query := (&TradeTimeRangeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(interval.Table, interval.FieldID, id),
			sqlgraph.To(tradetimerange.Table, tradetimerange.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, interval.TradesTable, interval.TradesColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IntervalClient) Hooks() []Hook {
	return c.hooks.Interval
}

// Interceptors returns the client interceptors.
func (c *IntervalClient) Interceptors() []Interceptor {
	return c.inters.Interval
}

func (c *IntervalClient) mutate(ctx context.Context, m *IntervalMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IntervalCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IntervalUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IntervalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IntervalDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Interval mutation op: %q", m.Op())
	}
}

// MarketHoursClient is a client for the MarketHours schema.
type MarketHoursClient struct {
	config
}

// NewMarketHoursClient returns a client for the MarketHours from the given config.
func NewMarketHoursClient(c config) *MarketHoursClient {
	return &MarketHoursClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `markethours.Hooks(f(g(h())))`.
func (c *MarketHoursClient) Use(hooks ...Hook) {
	c.hooks.MarketHours = append(c.hooks.MarketHours, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `markethours.Intercept(f(g(h())))`.
func (c *MarketHoursClient) Intercept(interceptors ...Interceptor) {
	c.inters.MarketHours = append(c.inters.MarketHours, interceptors...)
}

// Create returns a builder for creating a MarketHours entity.
func (c *MarketHoursClient) Create() *MarketHoursCreate {
	mutation := newMarketHoursMutation(c.config, OpCreate)
	return &MarketHoursCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MarketHours entities.
func (c *MarketHoursClient) CreateBulk(builders ...*MarketHoursCreate) *MarketHoursCreateBulk {
	return &MarketHoursCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MarketHours.
func (c *MarketHoursClient) Update() *MarketHoursUpdate {
	mutation := newMarketHoursMutation(c.config, OpUpdate)
	return &MarketHoursUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MarketHoursClient) UpdateOne(mh *MarketHours) *MarketHoursUpdateOne {
	mutation := newMarketHoursMutation(c.config, OpUpdateOne, withMarketHours(mh))
	return &MarketHoursUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MarketHoursClient) UpdateOneID(id int) *MarketHoursUpdateOne {
	mutation := newMarketHoursMutation(c.config, OpUpdateOne, withMarketHoursID(id))
	return &MarketHoursUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MarketHours.
func (c *MarketHoursClient) Delete() *MarketHoursDelete {
	mutation := newMarketHoursMutation(c.config, OpDelete)
	return &MarketHoursDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MarketHoursClient) DeleteOne(mh *MarketHours) *MarketHoursDeleteOne {
	return c.DeleteOneID(mh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MarketHoursClient) DeleteOneID(id int) *MarketHoursDeleteOne {
	builder := c.Delete().Where(markethours.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MarketHoursDeleteOne{builder}
}

// Query returns a query builder for MarketHours.
func (c *MarketHoursClient) Query() *MarketHoursQuery {
	return &MarketHoursQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a MarketHours entity by its id.
func (c *MarketHoursClient) Get(ctx context.Context, id int) (*MarketHours, error) {
	return c.Query().Where(markethours.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MarketHoursClient) GetX(ctx context.Context, id int) *MarketHours {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMarketInfo queries the market_info edge of a MarketHours.
func (c *MarketHoursClient) QueryMarketInfo(mh *MarketHours) *MarketInfoQuery {
	query := (&MarketInfoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mh.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(markethours.Table, markethours.FieldID, id),
			sqlgraph.To(marketinfo.Table, marketinfo.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, markethours.MarketInfoTable, markethours.MarketInfoColumn),
		)
		fromV = sqlgraph.Neighbors(mh.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MarketHoursClient) Hooks() []Hook {
	return c.hooks.MarketHours
}

// Interceptors returns the client interceptors.
func (c *MarketHoursClient) Interceptors() []Interceptor {
	return c.inters.MarketHours
}

func (c *MarketHoursClient) mutate(ctx context.Context, m *MarketHoursMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MarketHoursCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MarketHoursUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MarketHoursUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MarketHoursDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MarketHours mutation op: %q", m.Op())
	}
}

// MarketInfoClient is a client for the MarketInfo schema.
type MarketInfoClient struct {
	config
}

// NewMarketInfoClient returns a client for the MarketInfo from the given config.
func NewMarketInfoClient(c config) *MarketInfoClient {
	return &MarketInfoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `marketinfo.Hooks(f(g(h())))`.
func (c *MarketInfoClient) Use(hooks ...Hook) {
	c.hooks.MarketInfo = append(c.hooks.MarketInfo, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `marketinfo.Intercept(f(g(h())))`.
func (c *MarketInfoClient) Intercept(interceptors ...Interceptor) {
	c.inters.MarketInfo = append(c.inters.MarketInfo, interceptors...)
}

// Create returns a builder for creating a MarketInfo entity.
func (c *MarketInfoClient) Create() *MarketInfoCreate {
	mutation := newMarketInfoMutation(c.config, OpCreate)
	return &MarketInfoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MarketInfo entities.
func (c *MarketInfoClient) CreateBulk(builders ...*MarketInfoCreate) *MarketInfoCreateBulk {
	return &MarketInfoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MarketInfo.
func (c *MarketInfoClient) Update() *MarketInfoUpdate {
	mutation := newMarketInfoMutation(c.config, OpUpdate)
	return &MarketInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MarketInfoClient) UpdateOne(mi *MarketInfo) *MarketInfoUpdateOne {
	mutation := newMarketInfoMutation(c.config, OpUpdateOne, withMarketInfo(mi))
	return &MarketInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MarketInfoClient) UpdateOneID(id int) *MarketInfoUpdateOne {
	mutation := newMarketInfoMutation(c.config, OpUpdateOne, withMarketInfoID(id))
	return &MarketInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MarketInfo.
func (c *MarketInfoClient) Delete() *MarketInfoDelete {
	mutation := newMarketInfoMutation(c.config, OpDelete)
	return &MarketInfoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MarketInfoClient) DeleteOne(mi *MarketInfo) *MarketInfoDeleteOne {
	return c.DeleteOneID(mi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MarketInfoClient) DeleteOneID(id int) *MarketInfoDeleteOne {
	builder := c.Delete().Where(marketinfo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MarketInfoDeleteOne{builder}
}

// Query returns a query builder for MarketInfo.
func (c *MarketInfoClient) Query() *MarketInfoQuery {
	return &MarketInfoQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a MarketInfo entity by its id.
func (c *MarketInfoClient) Get(ctx context.Context, id int) (*MarketInfo, error) {
	return c.Query().Where(marketinfo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MarketInfoClient) GetX(ctx context.Context, id int) *MarketInfo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryHours queries the hours edge of a MarketInfo.
func (c *MarketInfoClient) QueryHours(mi *MarketInfo) *MarketHoursQuery {
	query := (&MarketHoursClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(marketinfo.Table, marketinfo.FieldID, id),
			sqlgraph.To(markethours.Table, markethours.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, marketinfo.HoursTable, marketinfo.HoursColumn),
		)
		fromV = sqlgraph.Neighbors(mi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MarketInfoClient) Hooks() []Hook {
	return c.hooks.MarketInfo
}

// Interceptors returns the client interceptors.
func (c *MarketInfoClient) Interceptors() []Interceptor {
	return c.inters.MarketInfo
}

func (c *MarketInfoClient) mutate(ctx context.Context, m *MarketInfoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MarketInfoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MarketInfoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MarketInfoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MarketInfoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MarketInfo mutation op: %q", m.Op())
	}
}

// SplitClient is a client for the Split schema.
type SplitClient struct {
	config
}

// NewSplitClient returns a client for the Split from the given config.
func NewSplitClient(c config) *SplitClient {
	return &SplitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `split.Hooks(f(g(h())))`.
func (c *SplitClient) Use(hooks ...Hook) {
	c.hooks.Split = append(c.hooks.Split, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `split.Intercept(f(g(h())))`.
func (c *SplitClient) Intercept(interceptors ...Interceptor) {
	c.inters.Split = append(c.inters.Split, interceptors...)
}

// Create returns a builder for creating a Split entity.
func (c *SplitClient) Create() *SplitCreate {
	mutation := newSplitMutation(c.config, OpCreate)
	return &SplitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Split entities.
func (c *SplitClient) CreateBulk(builders ...*SplitCreate) *SplitCreateBulk {
	return &SplitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Split.
func (c *SplitClient) Update() *SplitUpdate {
	mutation := newSplitMutation(c.config, OpUpdate)
	return &SplitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SplitClient) UpdateOne(s *Split) *SplitUpdateOne {
	mutation := newSplitMutation(c.config, OpUpdateOne, withSplit(s))
	return &SplitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SplitClient) UpdateOneID(id int) *SplitUpdateOne {
	mutation := newSplitMutation(c.config, OpUpdateOne, withSplitID(id))
	return &SplitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Split.
func (c *SplitClient) Delete() *SplitDelete {
	mutation := newSplitMutation(c.config, OpDelete)
	return &SplitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SplitClient) DeleteOne(s *Split) *SplitDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SplitClient) DeleteOneID(id int) *SplitDeleteOne {
	builder := c.Delete().Where(split.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SplitDeleteOne{builder}
}

// Query returns a query builder for Split.
func (c *SplitClient) Query() *SplitQuery {
	return &SplitQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Split entity by its id.
func (c *SplitClient) Get(ctx context.Context, id int) (*Split, error) {
	return c.Query().Where(split.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SplitClient) GetX(ctx context.Context, id int) *Split {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStock queries the stock edge of a Split.
func (c *SplitClient) QueryStock(s *Split) *EntityQuery {
	query := (&EntityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(split.Table, split.FieldID, id),
			sqlgraph.To(entity.Table, entity.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, split.StockTable, split.StockColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SplitClient) Hooks() []Hook {
	return c.hooks.Split
}

// Interceptors returns the client interceptors.
func (c *SplitClient) Interceptors() []Interceptor {
	return c.inters.Split
}

func (c *SplitClient) mutate(ctx context.Context, m *SplitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SplitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SplitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SplitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SplitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Split mutation op: %q", m.Op())
	}
}

// TradeConditionClient is a client for the TradeCondition schema.
type TradeConditionClient struct {
	config
}

// NewTradeConditionClient returns a client for the TradeCondition from the given config.
func NewTradeConditionClient(c config) *TradeConditionClient {
	return &TradeConditionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tradecondition.Hooks(f(g(h())))`.
func (c *TradeConditionClient) Use(hooks ...Hook) {
	c.hooks.TradeCondition = append(c.hooks.TradeCondition, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tradecondition.Intercept(f(g(h())))`.
func (c *TradeConditionClient) Intercept(interceptors ...Interceptor) {
	c.inters.TradeCondition = append(c.inters.TradeCondition, interceptors...)
}

// Create returns a builder for creating a TradeCondition entity.
func (c *TradeConditionClient) Create() *TradeConditionCreate {
	mutation := newTradeConditionMutation(c.config, OpCreate)
	return &TradeConditionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TradeCondition entities.
func (c *TradeConditionClient) CreateBulk(builders ...*TradeConditionCreate) *TradeConditionCreateBulk {
	return &TradeConditionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TradeCondition.
func (c *TradeConditionClient) Update() *TradeConditionUpdate {
	mutation := newTradeConditionMutation(c.config, OpUpdate)
	return &TradeConditionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TradeConditionClient) UpdateOne(tc *TradeCondition) *TradeConditionUpdateOne {
	mutation := newTradeConditionMutation(c.config, OpUpdateOne, withTradeCondition(tc))
	return &TradeConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TradeConditionClient) UpdateOneID(id int) *TradeConditionUpdateOne {
	mutation := newTradeConditionMutation(c.config, OpUpdateOne, withTradeConditionID(id))
	return &TradeConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TradeCondition.
func (c *TradeConditionClient) Delete() *TradeConditionDelete {
	mutation := newTradeConditionMutation(c.config, OpDelete)
	return &TradeConditionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TradeConditionClient) DeleteOne(tc *TradeCondition) *TradeConditionDeleteOne {
	return c.DeleteOneID(tc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TradeConditionClient) DeleteOneID(id int) *TradeConditionDeleteOne {
	builder := c.Delete().Where(tradecondition.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TradeConditionDeleteOne{builder}
}

// Query returns a query builder for TradeCondition.
func (c *TradeConditionClient) Query() *TradeConditionQuery {
	return &TradeConditionQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a TradeCondition entity by its id.
func (c *TradeConditionClient) Get(ctx context.Context, id int) (*TradeCondition, error) {
	return c.Query().Where(tradecondition.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TradeConditionClient) GetX(ctx context.Context, id int) *TradeCondition {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRecord queries the record edge of a TradeCondition.
func (c *TradeConditionClient) QueryRecord(tc *TradeCondition) *TradeRecordQuery {
	query := (&TradeRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tradecondition.Table, tradecondition.FieldID, id),
			sqlgraph.To(traderecord.Table, traderecord.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, tradecondition.RecordTable, tradecondition.RecordPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TradeConditionClient) Hooks() []Hook {
	return c.hooks.TradeCondition
}

// Interceptors returns the client interceptors.
func (c *TradeConditionClient) Interceptors() []Interceptor {
	return c.inters.TradeCondition
}

func (c *TradeConditionClient) mutate(ctx context.Context, m *TradeConditionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TradeConditionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TradeConditionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TradeConditionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TradeConditionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TradeCondition mutation op: %q", m.Op())
	}
}

// TradeCorrectionClient is a client for the TradeCorrection schema.
type TradeCorrectionClient struct {
	config
}

// NewTradeCorrectionClient returns a client for the TradeCorrection from the given config.
func NewTradeCorrectionClient(c config) *TradeCorrectionClient {
	return &TradeCorrectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tradecorrection.Hooks(f(g(h())))`.
func (c *TradeCorrectionClient) Use(hooks ...Hook) {
	c.hooks.TradeCorrection = append(c.hooks.TradeCorrection, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tradecorrection.Intercept(f(g(h())))`.
func (c *TradeCorrectionClient) Intercept(interceptors ...Interceptor) {
	c.inters.TradeCorrection = append(c.inters.TradeCorrection, interceptors...)
}

// Create returns a builder for creating a TradeCorrection entity.
func (c *TradeCorrectionClient) Create() *TradeCorrectionCreate {
	mutation := newTradeCorrectionMutation(c.config, OpCreate)
	return &TradeCorrectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TradeCorrection entities.
func (c *TradeCorrectionClient) CreateBulk(builders ...*TradeCorrectionCreate) *TradeCorrectionCreateBulk {
	return &TradeCorrectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TradeCorrection.
func (c *TradeCorrectionClient) Update() *TradeCorrectionUpdate {
	mutation := newTradeCorrectionMutation(c.config, OpUpdate)
	return &TradeCorrectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TradeCorrectionClient) UpdateOne(tc *TradeCorrection) *TradeCorrectionUpdateOne {
	mutation := newTradeCorrectionMutation(c.config, OpUpdateOne, withTradeCorrection(tc))
	return &TradeCorrectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TradeCorrectionClient) UpdateOneID(id int) *TradeCorrectionUpdateOne {
	mutation := newTradeCorrectionMutation(c.config, OpUpdateOne, withTradeCorrectionID(id))
	return &TradeCorrectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TradeCorrection.
func (c *TradeCorrectionClient) Delete() *TradeCorrectionDelete {
	mutation := newTradeCorrectionMutation(c.config, OpDelete)
	return &TradeCorrectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TradeCorrectionClient) DeleteOne(tc *TradeCorrection) *TradeCorrectionDeleteOne {
	return c.DeleteOneID(tc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TradeCorrectionClient) DeleteOneID(id int) *TradeCorrectionDeleteOne {
	builder := c.Delete().Where(tradecorrection.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TradeCorrectionDeleteOne{builder}
}

// Query returns a query builder for TradeCorrection.
func (c *TradeCorrectionClient) Query() *TradeCorrectionQuery {
	return &TradeCorrectionQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a TradeCorrection entity by its id.
func (c *TradeCorrectionClient) Get(ctx context.Context, id int) (*TradeCorrection, error) {
	return c.Query().Where(tradecorrection.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TradeCorrectionClient) GetX(ctx context.Context, id int) *TradeCorrection {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRecord queries the record edge of a TradeCorrection.
func (c *TradeCorrectionClient) QueryRecord(tc *TradeCorrection) *TradeRecordQuery {
	query := (&TradeRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tradecorrection.Table, tradecorrection.FieldID, id),
			sqlgraph.To(traderecord.Table, traderecord.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, tradecorrection.RecordTable, tradecorrection.RecordPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TradeCorrectionClient) Hooks() []Hook {
	return c.hooks.TradeCorrection
}

// Interceptors returns the client interceptors.
func (c *TradeCorrectionClient) Interceptors() []Interceptor {
	return c.inters.TradeCorrection
}

func (c *TradeCorrectionClient) mutate(ctx context.Context, m *TradeCorrectionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TradeCorrectionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TradeCorrectionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TradeCorrectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TradeCorrectionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TradeCorrection mutation op: %q", m.Op())
	}
}

// TradeRecordClient is a client for the TradeRecord schema.
type TradeRecordClient struct {
	config
}

// NewTradeRecordClient returns a client for the TradeRecord from the given config.
func NewTradeRecordClient(c config) *TradeRecordClient {
	return &TradeRecordClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `traderecord.Hooks(f(g(h())))`.
func (c *TradeRecordClient) Use(hooks ...Hook) {
	c.hooks.TradeRecord = append(c.hooks.TradeRecord, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `traderecord.Intercept(f(g(h())))`.
func (c *TradeRecordClient) Intercept(interceptors ...Interceptor) {
	c.inters.TradeRecord = append(c.inters.TradeRecord, interceptors...)
}

// Create returns a builder for creating a TradeRecord entity.
func (c *TradeRecordClient) Create() *TradeRecordCreate {
	mutation := newTradeRecordMutation(c.config, OpCreate)
	return &TradeRecordCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TradeRecord entities.
func (c *TradeRecordClient) CreateBulk(builders ...*TradeRecordCreate) *TradeRecordCreateBulk {
	return &TradeRecordCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TradeRecord.
func (c *TradeRecordClient) Update() *TradeRecordUpdate {
	mutation := newTradeRecordMutation(c.config, OpUpdate)
	return &TradeRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TradeRecordClient) UpdateOne(tr *TradeRecord) *TradeRecordUpdateOne {
	mutation := newTradeRecordMutation(c.config, OpUpdateOne, withTradeRecord(tr))
	return &TradeRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TradeRecordClient) UpdateOneID(id int) *TradeRecordUpdateOne {
	mutation := newTradeRecordMutation(c.config, OpUpdateOne, withTradeRecordID(id))
	return &TradeRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TradeRecord.
func (c *TradeRecordClient) Delete() *TradeRecordDelete {
	mutation := newTradeRecordMutation(c.config, OpDelete)
	return &TradeRecordDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TradeRecordClient) DeleteOne(tr *TradeRecord) *TradeRecordDeleteOne {
	return c.DeleteOneID(tr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TradeRecordClient) DeleteOneID(id int) *TradeRecordDeleteOne {
	builder := c.Delete().Where(traderecord.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TradeRecordDeleteOne{builder}
}

// Query returns a query builder for TradeRecord.
func (c *TradeRecordClient) Query() *TradeRecordQuery {
	return &TradeRecordQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a TradeRecord entity by its id.
func (c *TradeRecordClient) Get(ctx context.Context, id int) (*TradeRecord, error) {
	return c.Query().Where(traderecord.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TradeRecordClient) GetX(ctx context.Context, id int) *TradeRecord {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTimeRange queries the time_range edge of a TradeRecord.
func (c *TradeRecordClient) QueryTimeRange(tr *TradeRecord) *TradeTimeRangeQuery {
	query := (&TradeTimeRangeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(traderecord.Table, traderecord.FieldID, id),
			sqlgraph.To(tradetimerange.Table, tradetimerange.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, traderecord.TimeRangeTable, traderecord.TimeRangeColumn),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConditions queries the conditions edge of a TradeRecord.
func (c *TradeRecordClient) QueryConditions(tr *TradeRecord) *TradeConditionQuery {
	query := (&TradeConditionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(traderecord.Table, traderecord.FieldID, id),
			sqlgraph.To(tradecondition.Table, tradecondition.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, traderecord.ConditionsTable, traderecord.ConditionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCorrection queries the correction edge of a TradeRecord.
func (c *TradeRecordClient) QueryCorrection(tr *TradeRecord) *TradeCorrectionQuery {
	query := (&TradeCorrectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(traderecord.Table, traderecord.FieldID, id),
			sqlgraph.To(tradecorrection.Table, tradecorrection.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, traderecord.CorrectionTable, traderecord.CorrectionPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExchange queries the exchange edge of a TradeRecord.
func (c *TradeRecordClient) QueryExchange(tr *TradeRecord) *ExchangeQuery {
	query := (&ExchangeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(traderecord.Table, traderecord.FieldID, id),
			sqlgraph.To(exchange.Table, exchange.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, traderecord.ExchangeTable, traderecord.ExchangeColumn),
		)
		fromV = sqlgraph.Neighbors(tr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TradeRecordClient) Hooks() []Hook {
	return c.hooks.TradeRecord
}

// Interceptors returns the client interceptors.
func (c *TradeRecordClient) Interceptors() []Interceptor {
	return c.inters.TradeRecord
}

func (c *TradeRecordClient) mutate(ctx context.Context, m *TradeRecordMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TradeRecordCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TradeRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TradeRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TradeRecordDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TradeRecord mutation op: %q", m.Op())
	}
}

// TradeTimeRangeClient is a client for the TradeTimeRange schema.
type TradeTimeRangeClient struct {
	config
}

// NewTradeTimeRangeClient returns a client for the TradeTimeRange from the given config.
func NewTradeTimeRangeClient(c config) *TradeTimeRangeClient {
	return &TradeTimeRangeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tradetimerange.Hooks(f(g(h())))`.
func (c *TradeTimeRangeClient) Use(hooks ...Hook) {
	c.hooks.TradeTimeRange = append(c.hooks.TradeTimeRange, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tradetimerange.Intercept(f(g(h())))`.
func (c *TradeTimeRangeClient) Intercept(interceptors ...Interceptor) {
	c.inters.TradeTimeRange = append(c.inters.TradeTimeRange, interceptors...)
}

// Create returns a builder for creating a TradeTimeRange entity.
func (c *TradeTimeRangeClient) Create() *TradeTimeRangeCreate {
	mutation := newTradeTimeRangeMutation(c.config, OpCreate)
	return &TradeTimeRangeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TradeTimeRange entities.
func (c *TradeTimeRangeClient) CreateBulk(builders ...*TradeTimeRangeCreate) *TradeTimeRangeCreateBulk {
	return &TradeTimeRangeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TradeTimeRange.
func (c *TradeTimeRangeClient) Update() *TradeTimeRangeUpdate {
	mutation := newTradeTimeRangeMutation(c.config, OpUpdate)
	return &TradeTimeRangeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TradeTimeRangeClient) UpdateOne(ttr *TradeTimeRange) *TradeTimeRangeUpdateOne {
	mutation := newTradeTimeRangeMutation(c.config, OpUpdateOne, withTradeTimeRange(ttr))
	return &TradeTimeRangeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TradeTimeRangeClient) UpdateOneID(id int) *TradeTimeRangeUpdateOne {
	mutation := newTradeTimeRangeMutation(c.config, OpUpdateOne, withTradeTimeRangeID(id))
	return &TradeTimeRangeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TradeTimeRange.
func (c *TradeTimeRangeClient) Delete() *TradeTimeRangeDelete {
	mutation := newTradeTimeRangeMutation(c.config, OpDelete)
	return &TradeTimeRangeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TradeTimeRangeClient) DeleteOne(ttr *TradeTimeRange) *TradeTimeRangeDeleteOne {
	return c.DeleteOneID(ttr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TradeTimeRangeClient) DeleteOneID(id int) *TradeTimeRangeDeleteOne {
	builder := c.Delete().Where(tradetimerange.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TradeTimeRangeDeleteOne{builder}
}

// Query returns a query builder for TradeTimeRange.
func (c *TradeTimeRangeClient) Query() *TradeTimeRangeQuery {
	return &TradeTimeRangeQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a TradeTimeRange entity by its id.
func (c *TradeTimeRangeClient) Get(ctx context.Context, id int) (*TradeTimeRange, error) {
	return c.Query().Where(tradetimerange.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TradeTimeRangeClient) GetX(ctx context.Context, id int) *TradeTimeRange {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInterval queries the interval edge of a TradeTimeRange.
func (c *TradeTimeRangeClient) QueryInterval(ttr *TradeTimeRange) *IntervalQuery {
	query := (&IntervalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ttr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tradetimerange.Table, tradetimerange.FieldID, id),
			sqlgraph.To(interval.Table, interval.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tradetimerange.IntervalTable, tradetimerange.IntervalColumn),
		)
		fromV = sqlgraph.Neighbors(ttr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRecords queries the records edge of a TradeTimeRange.
func (c *TradeTimeRangeClient) QueryRecords(ttr *TradeTimeRange) *TradeRecordQuery {
	query := (&TradeRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ttr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tradetimerange.Table, tradetimerange.FieldID, id),
			sqlgraph.To(traderecord.Table, traderecord.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tradetimerange.RecordsTable, tradetimerange.RecordsColumn),
		)
		fromV = sqlgraph.Neighbors(ttr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TradeTimeRangeClient) Hooks() []Hook {
	return c.hooks.TradeTimeRange
}

// Interceptors returns the client interceptors.
func (c *TradeTimeRangeClient) Interceptors() []Interceptor {
	return c.inters.TradeTimeRange
}

func (c *TradeTimeRangeClient) mutate(ctx context.Context, m *TradeTimeRangeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TradeTimeRangeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TradeTimeRangeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TradeTimeRangeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TradeTimeRangeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TradeTimeRange mutation op: %q", m.Op())
	}
}
