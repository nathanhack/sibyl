// Code generated by ent, DO NOT EDIT.

package interval

import (
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the interval type in the database.
	Label = "interval"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldActive holds the string denoting the active field in the database.
	FieldActive = "active"
	// FieldInterval holds the string denoting the interval field in the database.
	FieldInterval = "interval"
	// FieldStockID holds the string denoting the stock_id field in the database.
	FieldStockID = "stock_id"
	// FieldDataSourceID holds the string denoting the data_source_id field in the database.
	FieldDataSourceID = "data_source_id"
	// EdgeDataSource holds the string denoting the data_source edge name in mutations.
	EdgeDataSource = "data_source"
	// EdgeStock holds the string denoting the stock edge name in mutations.
	EdgeStock = "stock"
	// EdgeBars holds the string denoting the bars edge name in mutations.
	EdgeBars = "bars"
	// EdgeTrades holds the string denoting the trades edge name in mutations.
	EdgeTrades = "trades"
	// Table holds the table name of the interval in the database.
	Table = "intervals"
	// DataSourceTable is the table that holds the data_source relation/edge.
	DataSourceTable = "intervals"
	// DataSourceInverseTable is the table name for the DataSource entity.
	// It exists in this package in order to avoid circular dependency with the "datasource" package.
	DataSourceInverseTable = "data_sources"
	// DataSourceColumn is the table column denoting the data_source relation/edge.
	DataSourceColumn = "data_source_id"
	// StockTable is the table that holds the stock relation/edge.
	StockTable = "intervals"
	// StockInverseTable is the table name for the Entity entity.
	// It exists in this package in order to avoid circular dependency with the "entity" package.
	StockInverseTable = "entities"
	// StockColumn is the table column denoting the stock relation/edge.
	StockColumn = "stock_id"
	// BarsTable is the table that holds the bars relation/edge.
	BarsTable = "bar_time_ranges"
	// BarsInverseTable is the table name for the BarTimeRange entity.
	// It exists in this package in order to avoid circular dependency with the "bartimerange" package.
	BarsInverseTable = "bar_time_ranges"
	// BarsColumn is the table column denoting the bars relation/edge.
	BarsColumn = "interval_id"
	// TradesTable is the table that holds the trades relation/edge.
	TradesTable = "trade_time_ranges"
	// TradesInverseTable is the table name for the TradeTimeRange entity.
	// It exists in this package in order to avoid circular dependency with the "tradetimerange" package.
	TradesInverseTable = "trade_time_ranges"
	// TradesColumn is the table column denoting the trades relation/edge.
	TradesColumn = "interval_id"
)

// Columns holds all SQL columns for interval fields.
var Columns = []string{
	FieldID,
	FieldActive,
	FieldInterval,
	FieldStockID,
	FieldDataSourceID,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

var (
	// DefaultActive holds the default value on creation for the "active" field.
	DefaultActive bool
)

// Interval defines the type for the "interval" enum field.
type Interval string

// Interval values.
const (
	IntervalTrades  Interval = "trades"
	Interval1min    Interval = "1min"
	IntervalDaily   Interval = "daily"
	IntervalMonthly Interval = "monthly"
	IntervalYearly  Interval = "yearly"
)

func (i Interval) String() string {
	return string(i)
}

// IntervalValidator is a validator for the "interval" field enum values. It is called by the builders before save.
func IntervalValidator(i Interval) error {
	switch i {
	case IntervalTrades, Interval1min, IntervalDaily, IntervalMonthly, IntervalYearly:
		return nil
	default:
		return fmt.Errorf("interval: invalid enum value for interval field: %q", i)
	}
}

// OrderOption defines the ordering options for the Interval queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByActive orders the results by the active field.
func ByActive(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldActive, opts...).ToFunc()
}

// ByInterval orders the results by the interval field.
func ByInterval(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldInterval, opts...).ToFunc()
}

// ByStockID orders the results by the stock_id field.
func ByStockID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStockID, opts...).ToFunc()
}

// ByDataSourceID orders the results by the data_source_id field.
func ByDataSourceID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDataSourceID, opts...).ToFunc()
}

// ByDataSourceField orders the results by data_source field.
func ByDataSourceField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newDataSourceStep(), sql.OrderByField(field, opts...))
	}
}

// ByStockField orders the results by stock field.
func ByStockField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newStockStep(), sql.OrderByField(field, opts...))
	}
}

// ByBarsCount orders the results by bars count.
func ByBarsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newBarsStep(), opts...)
	}
}

// ByBars orders the results by bars terms.
func ByBars(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newBarsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByTradesCount orders the results by trades count.
func ByTradesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newTradesStep(), opts...)
	}
}

// ByTrades orders the results by trades terms.
func ByTrades(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newTradesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newDataSourceStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(DataSourceInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, DataSourceTable, DataSourceColumn),
	)
}
func newStockStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(StockInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, StockTable, StockColumn),
	)
}
func newBarsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(BarsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, BarsTable, BarsColumn),
	)
}
func newTradesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(TradesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, TradesTable, TradesColumn),
	)
}
