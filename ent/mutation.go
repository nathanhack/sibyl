// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/nathanhack/sibyl/ent/bargroup"
	"github.com/nathanhack/sibyl/ent/barrecord"
	"github.com/nathanhack/sibyl/ent/bartimerange"
	"github.com/nathanhack/sibyl/ent/datasource"
	"github.com/nathanhack/sibyl/ent/dividend"
	"github.com/nathanhack/sibyl/ent/entity"
	"github.com/nathanhack/sibyl/ent/exchange"
	"github.com/nathanhack/sibyl/ent/financial"
	"github.com/nathanhack/sibyl/ent/interval"
	"github.com/nathanhack/sibyl/ent/markethours"
	"github.com/nathanhack/sibyl/ent/marketinfo"
	"github.com/nathanhack/sibyl/ent/predicate"
	"github.com/nathanhack/sibyl/ent/split"
	"github.com/nathanhack/sibyl/ent/tradecondition"
	"github.com/nathanhack/sibyl/ent/tradecorrection"
	"github.com/nathanhack/sibyl/ent/traderecord"
	"github.com/nathanhack/sibyl/ent/tradetimerange"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBarGroup        = "BarGroup"
	TypeBarRecord       = "BarRecord"
	TypeBarTimeRange    = "BarTimeRange"
	TypeDataSource      = "DataSource"
	TypeDividend        = "Dividend"
	TypeEntity          = "Entity"
	TypeExchange        = "Exchange"
	TypeFinancial       = "Financial"
	TypeInterval        = "Interval"
	TypeMarketHours     = "MarketHours"
	TypeMarketInfo      = "MarketInfo"
	TypeSplit           = "Split"
	TypeTradeCondition  = "TradeCondition"
	TypeTradeCorrection = "TradeCorrection"
	TypeTradeRecord     = "TradeRecord"
	TypeTradeTimeRange  = "TradeTimeRange"
)

// BarGroupMutation represents an operation that mutates the BarGroup nodes in the graph.
type BarGroupMutation struct {
	config
	op                Op
	typ               string
	id                *int
	first             *time.Time
	last              *time.Time
	count             *int
	addcount          *int
	clearedFields     map[string]struct{}
	time_range        *int
	clearedtime_range bool
	records           map[int]struct{}
	removedrecords    map[int]struct{}
	clearedrecords    bool
	done              bool
	oldValue          func(context.Context) (*BarGroup, error)
	predicates        []predicate.BarGroup
}

var _ ent.Mutation = (*BarGroupMutation)(nil)

// bargroupOption allows management of the mutation configuration using functional options.
type bargroupOption func(*BarGroupMutation)

// newBarGroupMutation creates new mutation for the BarGroup entity.
func newBarGroupMutation(c config, op Op, opts ...bargroupOption) *BarGroupMutation {
	m := &BarGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeBarGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBarGroupID sets the ID field of the mutation.
func withBarGroupID(id int) bargroupOption {
	return func(m *BarGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *BarGroup
		)
		m.oldValue = func(ctx context.Context) (*BarGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BarGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBarGroup sets the old BarGroup of the mutation.
func withBarGroup(node *BarGroup) bargroupOption {
	return func(m *BarGroupMutation) {
		m.oldValue = func(context.Context) (*BarGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BarGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BarGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BarGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BarGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BarGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFirst sets the "first" field.
func (m *BarGroupMutation) SetFirst(t time.Time) {
	m.first = &t
}

// First returns the value of the "first" field in the mutation.
func (m *BarGroupMutation) First() (r time.Time, exists bool) {
	v := m.first
	if v == nil {
		return
	}
	return *v, true
}

// OldFirst returns the old "first" field's value of the BarGroup entity.
// If the BarGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BarGroupMutation) OldFirst(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirst: %w", err)
	}
	return oldValue.First, nil
}

// ResetFirst resets all changes to the "first" field.
func (m *BarGroupMutation) ResetFirst() {
	m.first = nil
}

// SetLast sets the "last" field.
func (m *BarGroupMutation) SetLast(t time.Time) {
	m.last = &t
}

// Last returns the value of the "last" field in the mutation.
func (m *BarGroupMutation) Last() (r time.Time, exists bool) {
	v := m.last
	if v == nil {
		return
	}
	return *v, true
}

// OldLast returns the old "last" field's value of the BarGroup entity.
// If the BarGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BarGroupMutation) OldLast(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLast is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLast requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLast: %w", err)
	}
	return oldValue.Last, nil
}

// ResetLast resets all changes to the "last" field.
func (m *BarGroupMutation) ResetLast() {
	m.last = nil
}

// SetCount sets the "count" field.
func (m *BarGroupMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *BarGroupMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the BarGroup entity.
// If the BarGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BarGroupMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *BarGroupMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *BarGroupMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *BarGroupMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetTimeRangeID sets the "time_range_id" field.
func (m *BarGroupMutation) SetTimeRangeID(i int) {
	m.time_range = &i
}

// TimeRangeID returns the value of the "time_range_id" field in the mutation.
func (m *BarGroupMutation) TimeRangeID() (r int, exists bool) {
	v := m.time_range
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeRangeID returns the old "time_range_id" field's value of the BarGroup entity.
// If the BarGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BarGroupMutation) OldTimeRangeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeRangeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeRangeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeRangeID: %w", err)
	}
	return oldValue.TimeRangeID, nil
}

// ResetTimeRangeID resets all changes to the "time_range_id" field.
func (m *BarGroupMutation) ResetTimeRangeID() {
	m.time_range = nil
}

// ClearTimeRange clears the "time_range" edge to the BarTimeRange entity.
func (m *BarGroupMutation) ClearTimeRange() {
	m.clearedtime_range = true
	m.clearedFields[bargroup.FieldTimeRangeID] = struct{}{}
}

// TimeRangeCleared reports if the "time_range" edge to the BarTimeRange entity was cleared.
func (m *BarGroupMutation) TimeRangeCleared() bool {
	return m.clearedtime_range
}

// TimeRangeIDs returns the "time_range" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TimeRangeID instead. It exists only for internal usage by the builders.
func (m *BarGroupMutation) TimeRangeIDs() (ids []int) {
	if id := m.time_range; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTimeRange resets all changes to the "time_range" edge.
func (m *BarGroupMutation) ResetTimeRange() {
	m.time_range = nil
	m.clearedtime_range = false
}

// AddRecordIDs adds the "records" edge to the BarRecord entity by ids.
func (m *BarGroupMutation) AddRecordIDs(ids ...int) {
	if m.records == nil {
		m.records = make(map[int]struct{})
	}
	for i := range ids {
		m.records[ids[i]] = struct{}{}
	}
}

// ClearRecords clears the "records" edge to the BarRecord entity.
func (m *BarGroupMutation) ClearRecords() {
	m.clearedrecords = true
}

// RecordsCleared reports if the "records" edge to the BarRecord entity was cleared.
func (m *BarGroupMutation) RecordsCleared() bool {
	return m.clearedrecords
}

// RemoveRecordIDs removes the "records" edge to the BarRecord entity by IDs.
func (m *BarGroupMutation) RemoveRecordIDs(ids ...int) {
	if m.removedrecords == nil {
		m.removedrecords = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.records, ids[i])
		m.removedrecords[ids[i]] = struct{}{}
	}
}

// RemovedRecords returns the removed IDs of the "records" edge to the BarRecord entity.
func (m *BarGroupMutation) RemovedRecordsIDs() (ids []int) {
	for id := range m.removedrecords {
		ids = append(ids, id)
	}
	return
}

// RecordsIDs returns the "records" edge IDs in the mutation.
func (m *BarGroupMutation) RecordsIDs() (ids []int) {
	for id := range m.records {
		ids = append(ids, id)
	}
	return
}

// ResetRecords resets all changes to the "records" edge.
func (m *BarGroupMutation) ResetRecords() {
	m.records = nil
	m.clearedrecords = false
	m.removedrecords = nil
}

// Where appends a list predicates to the BarGroupMutation builder.
func (m *BarGroupMutation) Where(ps ...predicate.BarGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BarGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BarGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BarGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BarGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BarGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BarGroup).
func (m *BarGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BarGroupMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.first != nil {
		fields = append(fields, bargroup.FieldFirst)
	}
	if m.last != nil {
		fields = append(fields, bargroup.FieldLast)
	}
	if m.count != nil {
		fields = append(fields, bargroup.FieldCount)
	}
	if m.time_range != nil {
		fields = append(fields, bargroup.FieldTimeRangeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BarGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bargroup.FieldFirst:
		return m.First()
	case bargroup.FieldLast:
		return m.Last()
	case bargroup.FieldCount:
		return m.Count()
	case bargroup.FieldTimeRangeID:
		return m.TimeRangeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BarGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bargroup.FieldFirst:
		return m.OldFirst(ctx)
	case bargroup.FieldLast:
		return m.OldLast(ctx)
	case bargroup.FieldCount:
		return m.OldCount(ctx)
	case bargroup.FieldTimeRangeID:
		return m.OldTimeRangeID(ctx)
	}
	return nil, fmt.Errorf("unknown BarGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BarGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bargroup.FieldFirst:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirst(v)
		return nil
	case bargroup.FieldLast:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLast(v)
		return nil
	case bargroup.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case bargroup.FieldTimeRangeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeRangeID(v)
		return nil
	}
	return fmt.Errorf("unknown BarGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BarGroupMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, bargroup.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BarGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bargroup.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BarGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bargroup.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown BarGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BarGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BarGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BarGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BarGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BarGroupMutation) ResetField(name string) error {
	switch name {
	case bargroup.FieldFirst:
		m.ResetFirst()
		return nil
	case bargroup.FieldLast:
		m.ResetLast()
		return nil
	case bargroup.FieldCount:
		m.ResetCount()
		return nil
	case bargroup.FieldTimeRangeID:
		m.ResetTimeRangeID()
		return nil
	}
	return fmt.Errorf("unknown BarGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BarGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.time_range != nil {
		edges = append(edges, bargroup.EdgeTimeRange)
	}
	if m.records != nil {
		edges = append(edges, bargroup.EdgeRecords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BarGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bargroup.EdgeTimeRange:
		if id := m.time_range; id != nil {
			return []ent.Value{*id}
		}
	case bargroup.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.records))
		for id := range m.records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BarGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrecords != nil {
		edges = append(edges, bargroup.EdgeRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BarGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bargroup.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.removedrecords))
		for id := range m.removedrecords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BarGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtime_range {
		edges = append(edges, bargroup.EdgeTimeRange)
	}
	if m.clearedrecords {
		edges = append(edges, bargroup.EdgeRecords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BarGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case bargroup.EdgeTimeRange:
		return m.clearedtime_range
	case bargroup.EdgeRecords:
		return m.clearedrecords
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BarGroupMutation) ClearEdge(name string) error {
	switch name {
	case bargroup.EdgeTimeRange:
		m.ClearTimeRange()
		return nil
	}
	return fmt.Errorf("unknown BarGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BarGroupMutation) ResetEdge(name string) error {
	switch name {
	case bargroup.EdgeTimeRange:
		m.ResetTimeRange()
		return nil
	case bargroup.EdgeRecords:
		m.ResetRecords()
		return nil
	}
	return fmt.Errorf("unknown BarGroup edge %s", name)
}

// BarRecordMutation represents an operation that mutates the BarRecord nodes in the graph.
type BarRecordMutation struct {
	config
	op              Op
	typ             string
	id              *int
	close           *float64
	addclose        *float64
	high            *float64
	addhigh         *float64
	low             *float64
	addlow          *float64
	open            *float64
	addopen         *float64
	timestamp       *time.Time
	volume          *float64
	addvolume       *float64
	transactions    *int32
	addtransactions *int32
	clearedFields   map[string]struct{}
	group           *int
	clearedgroup    bool
	done            bool
	oldValue        func(context.Context) (*BarRecord, error)
	predicates      []predicate.BarRecord
}

var _ ent.Mutation = (*BarRecordMutation)(nil)

// barrecordOption allows management of the mutation configuration using functional options.
type barrecordOption func(*BarRecordMutation)

// newBarRecordMutation creates new mutation for the BarRecord entity.
func newBarRecordMutation(c config, op Op, opts ...barrecordOption) *BarRecordMutation {
	m := &BarRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeBarRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBarRecordID sets the ID field of the mutation.
func withBarRecordID(id int) barrecordOption {
	return func(m *BarRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *BarRecord
		)
		m.oldValue = func(ctx context.Context) (*BarRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BarRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBarRecord sets the old BarRecord of the mutation.
func withBarRecord(node *BarRecord) barrecordOption {
	return func(m *BarRecordMutation) {
		m.oldValue = func(context.Context) (*BarRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BarRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BarRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BarRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BarRecordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BarRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClose sets the "close" field.
func (m *BarRecordMutation) SetClose(f float64) {
	m.close = &f
	m.addclose = nil
}

// Close returns the value of the "close" field in the mutation.
func (m *BarRecordMutation) Close() (r float64, exists bool) {
	v := m.close
	if v == nil {
		return
	}
	return *v, true
}

// OldClose returns the old "close" field's value of the BarRecord entity.
// If the BarRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BarRecordMutation) OldClose(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClose: %w", err)
	}
	return oldValue.Close, nil
}

// AddClose adds f to the "close" field.
func (m *BarRecordMutation) AddClose(f float64) {
	if m.addclose != nil {
		*m.addclose += f
	} else {
		m.addclose = &f
	}
}

// AddedClose returns the value that was added to the "close" field in this mutation.
func (m *BarRecordMutation) AddedClose() (r float64, exists bool) {
	v := m.addclose
	if v == nil {
		return
	}
	return *v, true
}

// ResetClose resets all changes to the "close" field.
func (m *BarRecordMutation) ResetClose() {
	m.close = nil
	m.addclose = nil
}

// SetHigh sets the "high" field.
func (m *BarRecordMutation) SetHigh(f float64) {
	m.high = &f
	m.addhigh = nil
}

// High returns the value of the "high" field in the mutation.
func (m *BarRecordMutation) High() (r float64, exists bool) {
	v := m.high
	if v == nil {
		return
	}
	return *v, true
}

// OldHigh returns the old "high" field's value of the BarRecord entity.
// If the BarRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BarRecordMutation) OldHigh(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHigh is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHigh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHigh: %w", err)
	}
	return oldValue.High, nil
}

// AddHigh adds f to the "high" field.
func (m *BarRecordMutation) AddHigh(f float64) {
	if m.addhigh != nil {
		*m.addhigh += f
	} else {
		m.addhigh = &f
	}
}

// AddedHigh returns the value that was added to the "high" field in this mutation.
func (m *BarRecordMutation) AddedHigh() (r float64, exists bool) {
	v := m.addhigh
	if v == nil {
		return
	}
	return *v, true
}

// ResetHigh resets all changes to the "high" field.
func (m *BarRecordMutation) ResetHigh() {
	m.high = nil
	m.addhigh = nil
}

// SetLow sets the "low" field.
func (m *BarRecordMutation) SetLow(f float64) {
	m.low = &f
	m.addlow = nil
}

// Low returns the value of the "low" field in the mutation.
func (m *BarRecordMutation) Low() (r float64, exists bool) {
	v := m.low
	if v == nil {
		return
	}
	return *v, true
}

// OldLow returns the old "low" field's value of the BarRecord entity.
// If the BarRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BarRecordMutation) OldLow(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLow: %w", err)
	}
	return oldValue.Low, nil
}

// AddLow adds f to the "low" field.
func (m *BarRecordMutation) AddLow(f float64) {
	if m.addlow != nil {
		*m.addlow += f
	} else {
		m.addlow = &f
	}
}

// AddedLow returns the value that was added to the "low" field in this mutation.
func (m *BarRecordMutation) AddedLow() (r float64, exists bool) {
	v := m.addlow
	if v == nil {
		return
	}
	return *v, true
}

// ResetLow resets all changes to the "low" field.
func (m *BarRecordMutation) ResetLow() {
	m.low = nil
	m.addlow = nil
}

// SetOpen sets the "open" field.
func (m *BarRecordMutation) SetOpen(f float64) {
	m.open = &f
	m.addopen = nil
}

// Open returns the value of the "open" field in the mutation.
func (m *BarRecordMutation) Open() (r float64, exists bool) {
	v := m.open
	if v == nil {
		return
	}
	return *v, true
}

// OldOpen returns the old "open" field's value of the BarRecord entity.
// If the BarRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BarRecordMutation) OldOpen(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpen: %w", err)
	}
	return oldValue.Open, nil
}

// AddOpen adds f to the "open" field.
func (m *BarRecordMutation) AddOpen(f float64) {
	if m.addopen != nil {
		*m.addopen += f
	} else {
		m.addopen = &f
	}
}

// AddedOpen returns the value that was added to the "open" field in this mutation.
func (m *BarRecordMutation) AddedOpen() (r float64, exists bool) {
	v := m.addopen
	if v == nil {
		return
	}
	return *v, true
}

// ResetOpen resets all changes to the "open" field.
func (m *BarRecordMutation) ResetOpen() {
	m.open = nil
	m.addopen = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *BarRecordMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *BarRecordMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the BarRecord entity.
// If the BarRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BarRecordMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *BarRecordMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetVolume sets the "volume" field.
func (m *BarRecordMutation) SetVolume(f float64) {
	m.volume = &f
	m.addvolume = nil
}

// Volume returns the value of the "volume" field in the mutation.
func (m *BarRecordMutation) Volume() (r float64, exists bool) {
	v := m.volume
	if v == nil {
		return
	}
	return *v, true
}

// OldVolume returns the old "volume" field's value of the BarRecord entity.
// If the BarRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BarRecordMutation) OldVolume(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolume is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolume requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolume: %w", err)
	}
	return oldValue.Volume, nil
}

// AddVolume adds f to the "volume" field.
func (m *BarRecordMutation) AddVolume(f float64) {
	if m.addvolume != nil {
		*m.addvolume += f
	} else {
		m.addvolume = &f
	}
}

// AddedVolume returns the value that was added to the "volume" field in this mutation.
func (m *BarRecordMutation) AddedVolume() (r float64, exists bool) {
	v := m.addvolume
	if v == nil {
		return
	}
	return *v, true
}

// ResetVolume resets all changes to the "volume" field.
func (m *BarRecordMutation) ResetVolume() {
	m.volume = nil
	m.addvolume = nil
}

// SetTransactions sets the "transactions" field.
func (m *BarRecordMutation) SetTransactions(i int32) {
	m.transactions = &i
	m.addtransactions = nil
}

// Transactions returns the value of the "transactions" field in the mutation.
func (m *BarRecordMutation) Transactions() (r int32, exists bool) {
	v := m.transactions
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactions returns the old "transactions" field's value of the BarRecord entity.
// If the BarRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BarRecordMutation) OldTransactions(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactions: %w", err)
	}
	return oldValue.Transactions, nil
}

// AddTransactions adds i to the "transactions" field.
func (m *BarRecordMutation) AddTransactions(i int32) {
	if m.addtransactions != nil {
		*m.addtransactions += i
	} else {
		m.addtransactions = &i
	}
}

// AddedTransactions returns the value that was added to the "transactions" field in this mutation.
func (m *BarRecordMutation) AddedTransactions() (r int32, exists bool) {
	v := m.addtransactions
	if v == nil {
		return
	}
	return *v, true
}

// ResetTransactions resets all changes to the "transactions" field.
func (m *BarRecordMutation) ResetTransactions() {
	m.transactions = nil
	m.addtransactions = nil
}

// SetGroupID sets the "group" edge to the BarGroup entity by id.
func (m *BarRecordMutation) SetGroupID(id int) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the BarGroup entity.
func (m *BarRecordMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the BarGroup entity was cleared.
func (m *BarRecordMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *BarRecordMutation) GroupID() (id int, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *BarRecordMutation) GroupIDs() (ids []int) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *BarRecordMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the BarRecordMutation builder.
func (m *BarRecordMutation) Where(ps ...predicate.BarRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BarRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BarRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BarRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BarRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BarRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BarRecord).
func (m *BarRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BarRecordMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.close != nil {
		fields = append(fields, barrecord.FieldClose)
	}
	if m.high != nil {
		fields = append(fields, barrecord.FieldHigh)
	}
	if m.low != nil {
		fields = append(fields, barrecord.FieldLow)
	}
	if m.open != nil {
		fields = append(fields, barrecord.FieldOpen)
	}
	if m.timestamp != nil {
		fields = append(fields, barrecord.FieldTimestamp)
	}
	if m.volume != nil {
		fields = append(fields, barrecord.FieldVolume)
	}
	if m.transactions != nil {
		fields = append(fields, barrecord.FieldTransactions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BarRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case barrecord.FieldClose:
		return m.Close()
	case barrecord.FieldHigh:
		return m.High()
	case barrecord.FieldLow:
		return m.Low()
	case barrecord.FieldOpen:
		return m.Open()
	case barrecord.FieldTimestamp:
		return m.Timestamp()
	case barrecord.FieldVolume:
		return m.Volume()
	case barrecord.FieldTransactions:
		return m.Transactions()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BarRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case barrecord.FieldClose:
		return m.OldClose(ctx)
	case barrecord.FieldHigh:
		return m.OldHigh(ctx)
	case barrecord.FieldLow:
		return m.OldLow(ctx)
	case barrecord.FieldOpen:
		return m.OldOpen(ctx)
	case barrecord.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case barrecord.FieldVolume:
		return m.OldVolume(ctx)
	case barrecord.FieldTransactions:
		return m.OldTransactions(ctx)
	}
	return nil, fmt.Errorf("unknown BarRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BarRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case barrecord.FieldClose:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClose(v)
		return nil
	case barrecord.FieldHigh:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHigh(v)
		return nil
	case barrecord.FieldLow:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLow(v)
		return nil
	case barrecord.FieldOpen:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpen(v)
		return nil
	case barrecord.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case barrecord.FieldVolume:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolume(v)
		return nil
	case barrecord.FieldTransactions:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactions(v)
		return nil
	}
	return fmt.Errorf("unknown BarRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BarRecordMutation) AddedFields() []string {
	var fields []string
	if m.addclose != nil {
		fields = append(fields, barrecord.FieldClose)
	}
	if m.addhigh != nil {
		fields = append(fields, barrecord.FieldHigh)
	}
	if m.addlow != nil {
		fields = append(fields, barrecord.FieldLow)
	}
	if m.addopen != nil {
		fields = append(fields, barrecord.FieldOpen)
	}
	if m.addvolume != nil {
		fields = append(fields, barrecord.FieldVolume)
	}
	if m.addtransactions != nil {
		fields = append(fields, barrecord.FieldTransactions)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BarRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case barrecord.FieldClose:
		return m.AddedClose()
	case barrecord.FieldHigh:
		return m.AddedHigh()
	case barrecord.FieldLow:
		return m.AddedLow()
	case barrecord.FieldOpen:
		return m.AddedOpen()
	case barrecord.FieldVolume:
		return m.AddedVolume()
	case barrecord.FieldTransactions:
		return m.AddedTransactions()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BarRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case barrecord.FieldClose:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClose(v)
		return nil
	case barrecord.FieldHigh:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHigh(v)
		return nil
	case barrecord.FieldLow:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLow(v)
		return nil
	case barrecord.FieldOpen:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpen(v)
		return nil
	case barrecord.FieldVolume:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVolume(v)
		return nil
	case barrecord.FieldTransactions:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTransactions(v)
		return nil
	}
	return fmt.Errorf("unknown BarRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BarRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BarRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BarRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BarRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BarRecordMutation) ResetField(name string) error {
	switch name {
	case barrecord.FieldClose:
		m.ResetClose()
		return nil
	case barrecord.FieldHigh:
		m.ResetHigh()
		return nil
	case barrecord.FieldLow:
		m.ResetLow()
		return nil
	case barrecord.FieldOpen:
		m.ResetOpen()
		return nil
	case barrecord.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case barrecord.FieldVolume:
		m.ResetVolume()
		return nil
	case barrecord.FieldTransactions:
		m.ResetTransactions()
		return nil
	}
	return fmt.Errorf("unknown BarRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BarRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.group != nil {
		edges = append(edges, barrecord.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BarRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case barrecord.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BarRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BarRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BarRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgroup {
		edges = append(edges, barrecord.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BarRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case barrecord.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BarRecordMutation) ClearEdge(name string) error {
	switch name {
	case barrecord.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown BarRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BarRecordMutation) ResetEdge(name string) error {
	switch name {
	case barrecord.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown BarRecord edge %s", name)
}

// BarTimeRangeMutation represents an operation that mutates the BarTimeRange nodes in the graph.
type BarTimeRangeMutation struct {
	config
	op              Op
	typ             string
	id              *int
	start           *time.Time
	end             *time.Time
	count           *int
	addcount        *int
	status          *bartimerange.Status
	update_time     *time.Time
	clearedFields   map[string]struct{}
	interval        *int
	clearedinterval bool
	groups          map[int]struct{}
	removedgroups   map[int]struct{}
	clearedgroups   bool
	done            bool
	oldValue        func(context.Context) (*BarTimeRange, error)
	predicates      []predicate.BarTimeRange
}

var _ ent.Mutation = (*BarTimeRangeMutation)(nil)

// bartimerangeOption allows management of the mutation configuration using functional options.
type bartimerangeOption func(*BarTimeRangeMutation)

// newBarTimeRangeMutation creates new mutation for the BarTimeRange entity.
func newBarTimeRangeMutation(c config, op Op, opts ...bartimerangeOption) *BarTimeRangeMutation {
	m := &BarTimeRangeMutation{
		config:        c,
		op:            op,
		typ:           TypeBarTimeRange,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBarTimeRangeID sets the ID field of the mutation.
func withBarTimeRangeID(id int) bartimerangeOption {
	return func(m *BarTimeRangeMutation) {
		var (
			err   error
			once  sync.Once
			value *BarTimeRange
		)
		m.oldValue = func(ctx context.Context) (*BarTimeRange, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BarTimeRange.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBarTimeRange sets the old BarTimeRange of the mutation.
func withBarTimeRange(node *BarTimeRange) bartimerangeOption {
	return func(m *BarTimeRangeMutation) {
		m.oldValue = func(context.Context) (*BarTimeRange, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BarTimeRangeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BarTimeRangeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BarTimeRangeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BarTimeRangeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BarTimeRange.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStart sets the "start" field.
func (m *BarTimeRangeMutation) SetStart(t time.Time) {
	m.start = &t
}

// Start returns the value of the "start" field in the mutation.
func (m *BarTimeRangeMutation) Start() (r time.Time, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the BarTimeRange entity.
// If the BarTimeRange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BarTimeRangeMutation) OldStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// ResetStart resets all changes to the "start" field.
func (m *BarTimeRangeMutation) ResetStart() {
	m.start = nil
}

// SetEnd sets the "end" field.
func (m *BarTimeRangeMutation) SetEnd(t time.Time) {
	m.end = &t
}

// End returns the value of the "end" field in the mutation.
func (m *BarTimeRangeMutation) End() (r time.Time, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the BarTimeRange entity.
// If the BarTimeRange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BarTimeRangeMutation) OldEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// ResetEnd resets all changes to the "end" field.
func (m *BarTimeRangeMutation) ResetEnd() {
	m.end = nil
}

// SetCount sets the "count" field.
func (m *BarTimeRangeMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *BarTimeRangeMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the BarTimeRange entity.
// If the BarTimeRange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BarTimeRangeMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *BarTimeRangeMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *BarTimeRangeMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *BarTimeRangeMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetIntervalID sets the "interval_id" field.
func (m *BarTimeRangeMutation) SetIntervalID(i int) {
	m.interval = &i
}

// IntervalID returns the value of the "interval_id" field in the mutation.
func (m *BarTimeRangeMutation) IntervalID() (r int, exists bool) {
	v := m.interval
	if v == nil {
		return
	}
	return *v, true
}

// OldIntervalID returns the old "interval_id" field's value of the BarTimeRange entity.
// If the BarTimeRange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BarTimeRangeMutation) OldIntervalID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntervalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntervalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntervalID: %w", err)
	}
	return oldValue.IntervalID, nil
}

// ResetIntervalID resets all changes to the "interval_id" field.
func (m *BarTimeRangeMutation) ResetIntervalID() {
	m.interval = nil
}

// SetStatus sets the "status" field.
func (m *BarTimeRangeMutation) SetStatus(b bartimerange.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BarTimeRangeMutation) Status() (r bartimerange.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BarTimeRange entity.
// If the BarTimeRange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BarTimeRangeMutation) OldStatus(ctx context.Context) (v bartimerange.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BarTimeRangeMutation) ResetStatus() {
	m.status = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *BarTimeRangeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *BarTimeRangeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the BarTimeRange entity.
// If the BarTimeRange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BarTimeRangeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *BarTimeRangeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// ClearInterval clears the "interval" edge to the Interval entity.
func (m *BarTimeRangeMutation) ClearInterval() {
	m.clearedinterval = true
	m.clearedFields[bartimerange.FieldIntervalID] = struct{}{}
}

// IntervalCleared reports if the "interval" edge to the Interval entity was cleared.
func (m *BarTimeRangeMutation) IntervalCleared() bool {
	return m.clearedinterval
}

// IntervalIDs returns the "interval" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IntervalID instead. It exists only for internal usage by the builders.
func (m *BarTimeRangeMutation) IntervalIDs() (ids []int) {
	if id := m.interval; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInterval resets all changes to the "interval" edge.
func (m *BarTimeRangeMutation) ResetInterval() {
	m.interval = nil
	m.clearedinterval = false
}

// AddGroupIDs adds the "groups" edge to the BarGroup entity by ids.
func (m *BarTimeRangeMutation) AddGroupIDs(ids ...int) {
	if m.groups == nil {
		m.groups = make(map[int]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the BarGroup entity.
func (m *BarTimeRangeMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the BarGroup entity was cleared.
func (m *BarTimeRangeMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the BarGroup entity by IDs.
func (m *BarTimeRangeMutation) RemoveGroupIDs(ids ...int) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the BarGroup entity.
func (m *BarTimeRangeMutation) RemovedGroupsIDs() (ids []int) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *BarTimeRangeMutation) GroupsIDs() (ids []int) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *BarTimeRangeMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// Where appends a list predicates to the BarTimeRangeMutation builder.
func (m *BarTimeRangeMutation) Where(ps ...predicate.BarTimeRange) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BarTimeRangeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BarTimeRangeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BarTimeRange, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BarTimeRangeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BarTimeRangeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BarTimeRange).
func (m *BarTimeRangeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BarTimeRangeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.start != nil {
		fields = append(fields, bartimerange.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, bartimerange.FieldEnd)
	}
	if m.count != nil {
		fields = append(fields, bartimerange.FieldCount)
	}
	if m.interval != nil {
		fields = append(fields, bartimerange.FieldIntervalID)
	}
	if m.status != nil {
		fields = append(fields, bartimerange.FieldStatus)
	}
	if m.update_time != nil {
		fields = append(fields, bartimerange.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BarTimeRangeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bartimerange.FieldStart:
		return m.Start()
	case bartimerange.FieldEnd:
		return m.End()
	case bartimerange.FieldCount:
		return m.Count()
	case bartimerange.FieldIntervalID:
		return m.IntervalID()
	case bartimerange.FieldStatus:
		return m.Status()
	case bartimerange.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BarTimeRangeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bartimerange.FieldStart:
		return m.OldStart(ctx)
	case bartimerange.FieldEnd:
		return m.OldEnd(ctx)
	case bartimerange.FieldCount:
		return m.OldCount(ctx)
	case bartimerange.FieldIntervalID:
		return m.OldIntervalID(ctx)
	case bartimerange.FieldStatus:
		return m.OldStatus(ctx)
	case bartimerange.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown BarTimeRange field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BarTimeRangeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bartimerange.FieldStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case bartimerange.FieldEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case bartimerange.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case bartimerange.FieldIntervalID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntervalID(v)
		return nil
	case bartimerange.FieldStatus:
		v, ok := value.(bartimerange.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case bartimerange.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown BarTimeRange field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BarTimeRangeMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, bartimerange.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BarTimeRangeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bartimerange.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BarTimeRangeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bartimerange.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown BarTimeRange numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BarTimeRangeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BarTimeRangeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BarTimeRangeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BarTimeRange nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BarTimeRangeMutation) ResetField(name string) error {
	switch name {
	case bartimerange.FieldStart:
		m.ResetStart()
		return nil
	case bartimerange.FieldEnd:
		m.ResetEnd()
		return nil
	case bartimerange.FieldCount:
		m.ResetCount()
		return nil
	case bartimerange.FieldIntervalID:
		m.ResetIntervalID()
		return nil
	case bartimerange.FieldStatus:
		m.ResetStatus()
		return nil
	case bartimerange.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown BarTimeRange field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BarTimeRangeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.interval != nil {
		edges = append(edges, bartimerange.EdgeInterval)
	}
	if m.groups != nil {
		edges = append(edges, bartimerange.EdgeGroups)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BarTimeRangeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bartimerange.EdgeInterval:
		if id := m.interval; id != nil {
			return []ent.Value{*id}
		}
	case bartimerange.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BarTimeRangeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedgroups != nil {
		edges = append(edges, bartimerange.EdgeGroups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BarTimeRangeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bartimerange.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BarTimeRangeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinterval {
		edges = append(edges, bartimerange.EdgeInterval)
	}
	if m.clearedgroups {
		edges = append(edges, bartimerange.EdgeGroups)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BarTimeRangeMutation) EdgeCleared(name string) bool {
	switch name {
	case bartimerange.EdgeInterval:
		return m.clearedinterval
	case bartimerange.EdgeGroups:
		return m.clearedgroups
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BarTimeRangeMutation) ClearEdge(name string) error {
	switch name {
	case bartimerange.EdgeInterval:
		m.ClearInterval()
		return nil
	}
	return fmt.Errorf("unknown BarTimeRange unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BarTimeRangeMutation) ResetEdge(name string) error {
	switch name {
	case bartimerange.EdgeInterval:
		m.ResetInterval()
		return nil
	case bartimerange.EdgeGroups:
		m.ResetGroups()
		return nil
	}
	return fmt.Errorf("unknown BarTimeRange edge %s", name)
}

// DataSourceMutation represents an operation that mutates the DataSource nodes in the graph.
type DataSourceMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	address          *string
	clearedFields    map[string]struct{}
	intervals        map[int]struct{}
	removedintervals map[int]struct{}
	clearedintervals bool
	done             bool
	oldValue         func(context.Context) (*DataSource, error)
	predicates       []predicate.DataSource
}

var _ ent.Mutation = (*DataSourceMutation)(nil)

// datasourceOption allows management of the mutation configuration using functional options.
type datasourceOption func(*DataSourceMutation)

// newDataSourceMutation creates new mutation for the DataSource entity.
func newDataSourceMutation(c config, op Op, opts ...datasourceOption) *DataSourceMutation {
	m := &DataSourceMutation{
		config:        c,
		op:            op,
		typ:           TypeDataSource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDataSourceID sets the ID field of the mutation.
func withDataSourceID(id int) datasourceOption {
	return func(m *DataSourceMutation) {
		var (
			err   error
			once  sync.Once
			value *DataSource
		)
		m.oldValue = func(ctx context.Context) (*DataSource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DataSource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDataSource sets the old DataSource of the mutation.
func withDataSource(node *DataSource) datasourceOption {
	return func(m *DataSourceMutation) {
		m.oldValue = func(context.Context) (*DataSource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DataSourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DataSourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DataSourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DataSourceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DataSource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DataSourceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DataSourceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DataSourceMutation) ResetName() {
	m.name = nil
}

// SetAddress sets the "address" field.
func (m *DataSourceMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *DataSourceMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the DataSource entity.
// If the DataSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DataSourceMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *DataSourceMutation) ResetAddress() {
	m.address = nil
}

// AddIntervalIDs adds the "intervals" edge to the Interval entity by ids.
func (m *DataSourceMutation) AddIntervalIDs(ids ...int) {
	if m.intervals == nil {
		m.intervals = make(map[int]struct{})
	}
	for i := range ids {
		m.intervals[ids[i]] = struct{}{}
	}
}

// ClearIntervals clears the "intervals" edge to the Interval entity.
func (m *DataSourceMutation) ClearIntervals() {
	m.clearedintervals = true
}

// IntervalsCleared reports if the "intervals" edge to the Interval entity was cleared.
func (m *DataSourceMutation) IntervalsCleared() bool {
	return m.clearedintervals
}

// RemoveIntervalIDs removes the "intervals" edge to the Interval entity by IDs.
func (m *DataSourceMutation) RemoveIntervalIDs(ids ...int) {
	if m.removedintervals == nil {
		m.removedintervals = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.intervals, ids[i])
		m.removedintervals[ids[i]] = struct{}{}
	}
}

// RemovedIntervals returns the removed IDs of the "intervals" edge to the Interval entity.
func (m *DataSourceMutation) RemovedIntervalsIDs() (ids []int) {
	for id := range m.removedintervals {
		ids = append(ids, id)
	}
	return
}

// IntervalsIDs returns the "intervals" edge IDs in the mutation.
func (m *DataSourceMutation) IntervalsIDs() (ids []int) {
	for id := range m.intervals {
		ids = append(ids, id)
	}
	return
}

// ResetIntervals resets all changes to the "intervals" edge.
func (m *DataSourceMutation) ResetIntervals() {
	m.intervals = nil
	m.clearedintervals = false
	m.removedintervals = nil
}

// Where appends a list predicates to the DataSourceMutation builder.
func (m *DataSourceMutation) Where(ps ...predicate.DataSource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DataSourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DataSourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DataSource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DataSourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DataSourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DataSource).
func (m *DataSourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DataSourceMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, datasource.FieldName)
	}
	if m.address != nil {
		fields = append(fields, datasource.FieldAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DataSourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case datasource.FieldName:
		return m.Name()
	case datasource.FieldAddress:
		return m.Address()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DataSourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case datasource.FieldName:
		return m.OldName(ctx)
	case datasource.FieldAddress:
		return m.OldAddress(ctx)
	}
	return nil, fmt.Errorf("unknown DataSource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DataSourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case datasource.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case datasource.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	}
	return fmt.Errorf("unknown DataSource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DataSourceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DataSourceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DataSourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DataSource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DataSourceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DataSourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DataSourceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DataSource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DataSourceMutation) ResetField(name string) error {
	switch name {
	case datasource.FieldName:
		m.ResetName()
		return nil
	case datasource.FieldAddress:
		m.ResetAddress()
		return nil
	}
	return fmt.Errorf("unknown DataSource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DataSourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.intervals != nil {
		edges = append(edges, datasource.EdgeIntervals)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DataSourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case datasource.EdgeIntervals:
		ids := make([]ent.Value, 0, len(m.intervals))
		for id := range m.intervals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DataSourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedintervals != nil {
		edges = append(edges, datasource.EdgeIntervals)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DataSourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case datasource.EdgeIntervals:
		ids := make([]ent.Value, 0, len(m.removedintervals))
		for id := range m.removedintervals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DataSourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedintervals {
		edges = append(edges, datasource.EdgeIntervals)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DataSourceMutation) EdgeCleared(name string) bool {
	switch name {
	case datasource.EdgeIntervals:
		return m.clearedintervals
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DataSourceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DataSource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DataSourceMutation) ResetEdge(name string) error {
	switch name {
	case datasource.EdgeIntervals:
		m.ResetIntervals()
		return nil
	}
	return fmt.Errorf("unknown DataSource edge %s", name)
}

// DividendMutation represents an operation that mutates the Dividend nodes in the graph.
type DividendMutation struct {
	config
	op               Op
	typ              string
	id               *int
	rate             *float64
	addrate          *float64
	declaration_date *time.Time
	ex_dividend_date *time.Time
	record_date      *time.Time
	pay_date         *time.Time
	clearedFields    map[string]struct{}
	stock            map[int]struct{}
	removedstock     map[int]struct{}
	clearedstock     bool
	done             bool
	oldValue         func(context.Context) (*Dividend, error)
	predicates       []predicate.Dividend
}

var _ ent.Mutation = (*DividendMutation)(nil)

// dividendOption allows management of the mutation configuration using functional options.
type dividendOption func(*DividendMutation)

// newDividendMutation creates new mutation for the Dividend entity.
func newDividendMutation(c config, op Op, opts ...dividendOption) *DividendMutation {
	m := &DividendMutation{
		config:        c,
		op:            op,
		typ:           TypeDividend,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDividendID sets the ID field of the mutation.
func withDividendID(id int) dividendOption {
	return func(m *DividendMutation) {
		var (
			err   error
			once  sync.Once
			value *Dividend
		)
		m.oldValue = func(ctx context.Context) (*Dividend, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dividend.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDividend sets the old Dividend of the mutation.
func withDividend(node *Dividend) dividendOption {
	return func(m *DividendMutation) {
		m.oldValue = func(context.Context) (*Dividend, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DividendMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DividendMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DividendMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DividendMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dividend.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRate sets the "rate" field.
func (m *DividendMutation) SetRate(f float64) {
	m.rate = &f
	m.addrate = nil
}

// Rate returns the value of the "rate" field in the mutation.
func (m *DividendMutation) Rate() (r float64, exists bool) {
	v := m.rate
	if v == nil {
		return
	}
	return *v, true
}

// OldRate returns the old "rate" field's value of the Dividend entity.
// If the Dividend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DividendMutation) OldRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRate: %w", err)
	}
	return oldValue.Rate, nil
}

// AddRate adds f to the "rate" field.
func (m *DividendMutation) AddRate(f float64) {
	if m.addrate != nil {
		*m.addrate += f
	} else {
		m.addrate = &f
	}
}

// AddedRate returns the value that was added to the "rate" field in this mutation.
func (m *DividendMutation) AddedRate() (r float64, exists bool) {
	v := m.addrate
	if v == nil {
		return
	}
	return *v, true
}

// ResetRate resets all changes to the "rate" field.
func (m *DividendMutation) ResetRate() {
	m.rate = nil
	m.addrate = nil
}

// SetDeclarationDate sets the "declaration_date" field.
func (m *DividendMutation) SetDeclarationDate(t time.Time) {
	m.declaration_date = &t
}

// DeclarationDate returns the value of the "declaration_date" field in the mutation.
func (m *DividendMutation) DeclarationDate() (r time.Time, exists bool) {
	v := m.declaration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDeclarationDate returns the old "declaration_date" field's value of the Dividend entity.
// If the Dividend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DividendMutation) OldDeclarationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeclarationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeclarationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeclarationDate: %w", err)
	}
	return oldValue.DeclarationDate, nil
}

// ResetDeclarationDate resets all changes to the "declaration_date" field.
func (m *DividendMutation) ResetDeclarationDate() {
	m.declaration_date = nil
}

// SetExDividendDate sets the "ex_dividend_date" field.
func (m *DividendMutation) SetExDividendDate(t time.Time) {
	m.ex_dividend_date = &t
}

// ExDividendDate returns the value of the "ex_dividend_date" field in the mutation.
func (m *DividendMutation) ExDividendDate() (r time.Time, exists bool) {
	v := m.ex_dividend_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExDividendDate returns the old "ex_dividend_date" field's value of the Dividend entity.
// If the Dividend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DividendMutation) OldExDividendDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExDividendDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExDividendDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExDividendDate: %w", err)
	}
	return oldValue.ExDividendDate, nil
}

// ResetExDividendDate resets all changes to the "ex_dividend_date" field.
func (m *DividendMutation) ResetExDividendDate() {
	m.ex_dividend_date = nil
}

// SetRecordDate sets the "record_date" field.
func (m *DividendMutation) SetRecordDate(t time.Time) {
	m.record_date = &t
}

// RecordDate returns the value of the "record_date" field in the mutation.
func (m *DividendMutation) RecordDate() (r time.Time, exists bool) {
	v := m.record_date
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordDate returns the old "record_date" field's value of the Dividend entity.
// If the Dividend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DividendMutation) OldRecordDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordDate: %w", err)
	}
	return oldValue.RecordDate, nil
}

// ResetRecordDate resets all changes to the "record_date" field.
func (m *DividendMutation) ResetRecordDate() {
	m.record_date = nil
}

// SetPayDate sets the "pay_date" field.
func (m *DividendMutation) SetPayDate(t time.Time) {
	m.pay_date = &t
}

// PayDate returns the value of the "pay_date" field in the mutation.
func (m *DividendMutation) PayDate() (r time.Time, exists bool) {
	v := m.pay_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPayDate returns the old "pay_date" field's value of the Dividend entity.
// If the Dividend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DividendMutation) OldPayDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayDate: %w", err)
	}
	return oldValue.PayDate, nil
}

// ResetPayDate resets all changes to the "pay_date" field.
func (m *DividendMutation) ResetPayDate() {
	m.pay_date = nil
}

// AddStockIDs adds the "stock" edge to the Entity entity by ids.
func (m *DividendMutation) AddStockIDs(ids ...int) {
	if m.stock == nil {
		m.stock = make(map[int]struct{})
	}
	for i := range ids {
		m.stock[ids[i]] = struct{}{}
	}
}

// ClearStock clears the "stock" edge to the Entity entity.
func (m *DividendMutation) ClearStock() {
	m.clearedstock = true
}

// StockCleared reports if the "stock" edge to the Entity entity was cleared.
func (m *DividendMutation) StockCleared() bool {
	return m.clearedstock
}

// RemoveStockIDs removes the "stock" edge to the Entity entity by IDs.
func (m *DividendMutation) RemoveStockIDs(ids ...int) {
	if m.removedstock == nil {
		m.removedstock = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.stock, ids[i])
		m.removedstock[ids[i]] = struct{}{}
	}
}

// RemovedStock returns the removed IDs of the "stock" edge to the Entity entity.
func (m *DividendMutation) RemovedStockIDs() (ids []int) {
	for id := range m.removedstock {
		ids = append(ids, id)
	}
	return
}

// StockIDs returns the "stock" edge IDs in the mutation.
func (m *DividendMutation) StockIDs() (ids []int) {
	for id := range m.stock {
		ids = append(ids, id)
	}
	return
}

// ResetStock resets all changes to the "stock" edge.
func (m *DividendMutation) ResetStock() {
	m.stock = nil
	m.clearedstock = false
	m.removedstock = nil
}

// Where appends a list predicates to the DividendMutation builder.
func (m *DividendMutation) Where(ps ...predicate.Dividend) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DividendMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DividendMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Dividend, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DividendMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DividendMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Dividend).
func (m *DividendMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DividendMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.rate != nil {
		fields = append(fields, dividend.FieldRate)
	}
	if m.declaration_date != nil {
		fields = append(fields, dividend.FieldDeclarationDate)
	}
	if m.ex_dividend_date != nil {
		fields = append(fields, dividend.FieldExDividendDate)
	}
	if m.record_date != nil {
		fields = append(fields, dividend.FieldRecordDate)
	}
	if m.pay_date != nil {
		fields = append(fields, dividend.FieldPayDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DividendMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dividend.FieldRate:
		return m.Rate()
	case dividend.FieldDeclarationDate:
		return m.DeclarationDate()
	case dividend.FieldExDividendDate:
		return m.ExDividendDate()
	case dividend.FieldRecordDate:
		return m.RecordDate()
	case dividend.FieldPayDate:
		return m.PayDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DividendMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dividend.FieldRate:
		return m.OldRate(ctx)
	case dividend.FieldDeclarationDate:
		return m.OldDeclarationDate(ctx)
	case dividend.FieldExDividendDate:
		return m.OldExDividendDate(ctx)
	case dividend.FieldRecordDate:
		return m.OldRecordDate(ctx)
	case dividend.FieldPayDate:
		return m.OldPayDate(ctx)
	}
	return nil, fmt.Errorf("unknown Dividend field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DividendMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dividend.FieldRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRate(v)
		return nil
	case dividend.FieldDeclarationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeclarationDate(v)
		return nil
	case dividend.FieldExDividendDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExDividendDate(v)
		return nil
	case dividend.FieldRecordDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordDate(v)
		return nil
	case dividend.FieldPayDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayDate(v)
		return nil
	}
	return fmt.Errorf("unknown Dividend field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DividendMutation) AddedFields() []string {
	var fields []string
	if m.addrate != nil {
		fields = append(fields, dividend.FieldRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DividendMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dividend.FieldRate:
		return m.AddedRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DividendMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dividend.FieldRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRate(v)
		return nil
	}
	return fmt.Errorf("unknown Dividend numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DividendMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DividendMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DividendMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Dividend nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DividendMutation) ResetField(name string) error {
	switch name {
	case dividend.FieldRate:
		m.ResetRate()
		return nil
	case dividend.FieldDeclarationDate:
		m.ResetDeclarationDate()
		return nil
	case dividend.FieldExDividendDate:
		m.ResetExDividendDate()
		return nil
	case dividend.FieldRecordDate:
		m.ResetRecordDate()
		return nil
	case dividend.FieldPayDate:
		m.ResetPayDate()
		return nil
	}
	return fmt.Errorf("unknown Dividend field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DividendMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.stock != nil {
		edges = append(edges, dividend.EdgeStock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DividendMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dividend.EdgeStock:
		ids := make([]ent.Value, 0, len(m.stock))
		for id := range m.stock {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DividendMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstock != nil {
		edges = append(edges, dividend.EdgeStock)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DividendMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dividend.EdgeStock:
		ids := make([]ent.Value, 0, len(m.removedstock))
		for id := range m.removedstock {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DividendMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstock {
		edges = append(edges, dividend.EdgeStock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DividendMutation) EdgeCleared(name string) bool {
	switch name {
	case dividend.EdgeStock:
		return m.clearedstock
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DividendMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Dividend unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DividendMutation) ResetEdge(name string) error {
	switch name {
	case dividend.EdgeStock:
		m.ResetStock()
		return nil
	}
	return fmt.Errorf("unknown Dividend edge %s", name)
}

// EntityMutation represents an operation that mutates the Entity nodes in the graph.
type EntityMutation struct {
	config
	op                Op
	typ               string
	id                *int
	active            *bool
	ticker            *string
	name              *string
	description       *string
	list_date         *time.Time
	options           *bool
	tradable          *bool
	clearedFields     map[string]struct{}
	exchanges         map[int]struct{}
	removedexchanges  map[int]struct{}
	clearedexchanges  bool
	intervals         map[int]struct{}
	removedintervals  map[int]struct{}
	clearedintervals  bool
	dividends         map[int]struct{}
	removeddividends  map[int]struct{}
	cleareddividends  bool
	splits            map[int]struct{}
	removedsplits     map[int]struct{}
	clearedsplits     bool
	financials        map[int]struct{}
	removedfinancials map[int]struct{}
	clearedfinancials bool
	done              bool
	oldValue          func(context.Context) (*Entity, error)
	predicates        []predicate.Entity
}

var _ ent.Mutation = (*EntityMutation)(nil)

// entityOption allows management of the mutation configuration using functional options.
type entityOption func(*EntityMutation)

// newEntityMutation creates new mutation for the Entity entity.
func newEntityMutation(c config, op Op, opts ...entityOption) *EntityMutation {
	m := &EntityMutation{
		config:        c,
		op:            op,
		typ:           TypeEntity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntityID sets the ID field of the mutation.
func withEntityID(id int) entityOption {
	return func(m *EntityMutation) {
		var (
			err   error
			once  sync.Once
			value *Entity
		)
		m.oldValue = func(ctx context.Context) (*Entity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Entity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntity sets the old Entity of the mutation.
func withEntity(node *Entity) entityOption {
	return func(m *EntityMutation) {
		m.oldValue = func(context.Context) (*Entity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Entity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActive sets the "active" field.
func (m *EntityMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *EntityMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *EntityMutation) ResetActive() {
	m.active = nil
}

// SetTicker sets the "ticker" field.
func (m *EntityMutation) SetTicker(s string) {
	m.ticker = &s
}

// Ticker returns the value of the "ticker" field in the mutation.
func (m *EntityMutation) Ticker() (r string, exists bool) {
	v := m.ticker
	if v == nil {
		return
	}
	return *v, true
}

// OldTicker returns the old "ticker" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldTicker(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicker: %w", err)
	}
	return oldValue.Ticker, nil
}

// ResetTicker resets all changes to the "ticker" field.
func (m *EntityMutation) ResetTicker() {
	m.ticker = nil
}

// SetName sets the "name" field.
func (m *EntityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EntityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EntityMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EntityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EntityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *EntityMutation) ResetDescription() {
	m.description = nil
}

// SetListDate sets the "list_date" field.
func (m *EntityMutation) SetListDate(t time.Time) {
	m.list_date = &t
}

// ListDate returns the value of the "list_date" field in the mutation.
func (m *EntityMutation) ListDate() (r time.Time, exists bool) {
	v := m.list_date
	if v == nil {
		return
	}
	return *v, true
}

// OldListDate returns the old "list_date" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldListDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldListDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldListDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldListDate: %w", err)
	}
	return oldValue.ListDate, nil
}

// ResetListDate resets all changes to the "list_date" field.
func (m *EntityMutation) ResetListDate() {
	m.list_date = nil
}

// SetOptions sets the "options" field.
func (m *EntityMutation) SetOptions(b bool) {
	m.options = &b
}

// Options returns the value of the "options" field in the mutation.
func (m *EntityMutation) Options() (r bool, exists bool) {
	v := m.options
	if v == nil {
		return
	}
	return *v, true
}

// OldOptions returns the old "options" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldOptions(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptions: %w", err)
	}
	return oldValue.Options, nil
}

// ResetOptions resets all changes to the "options" field.
func (m *EntityMutation) ResetOptions() {
	m.options = nil
}

// SetTradable sets the "tradable" field.
func (m *EntityMutation) SetTradable(b bool) {
	m.tradable = &b
}

// Tradable returns the value of the "tradable" field in the mutation.
func (m *EntityMutation) Tradable() (r bool, exists bool) {
	v := m.tradable
	if v == nil {
		return
	}
	return *v, true
}

// OldTradable returns the old "tradable" field's value of the Entity entity.
// If the Entity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityMutation) OldTradable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTradable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTradable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTradable: %w", err)
	}
	return oldValue.Tradable, nil
}

// ResetTradable resets all changes to the "tradable" field.
func (m *EntityMutation) ResetTradable() {
	m.tradable = nil
}

// AddExchangeIDs adds the "exchanges" edge to the Exchange entity by ids.
func (m *EntityMutation) AddExchangeIDs(ids ...int) {
	if m.exchanges == nil {
		m.exchanges = make(map[int]struct{})
	}
	for i := range ids {
		m.exchanges[ids[i]] = struct{}{}
	}
}

// ClearExchanges clears the "exchanges" edge to the Exchange entity.
func (m *EntityMutation) ClearExchanges() {
	m.clearedexchanges = true
}

// ExchangesCleared reports if the "exchanges" edge to the Exchange entity was cleared.
func (m *EntityMutation) ExchangesCleared() bool {
	return m.clearedexchanges
}

// RemoveExchangeIDs removes the "exchanges" edge to the Exchange entity by IDs.
func (m *EntityMutation) RemoveExchangeIDs(ids ...int) {
	if m.removedexchanges == nil {
		m.removedexchanges = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.exchanges, ids[i])
		m.removedexchanges[ids[i]] = struct{}{}
	}
}

// RemovedExchanges returns the removed IDs of the "exchanges" edge to the Exchange entity.
func (m *EntityMutation) RemovedExchangesIDs() (ids []int) {
	for id := range m.removedexchanges {
		ids = append(ids, id)
	}
	return
}

// ExchangesIDs returns the "exchanges" edge IDs in the mutation.
func (m *EntityMutation) ExchangesIDs() (ids []int) {
	for id := range m.exchanges {
		ids = append(ids, id)
	}
	return
}

// ResetExchanges resets all changes to the "exchanges" edge.
func (m *EntityMutation) ResetExchanges() {
	m.exchanges = nil
	m.clearedexchanges = false
	m.removedexchanges = nil
}

// AddIntervalIDs adds the "intervals" edge to the Interval entity by ids.
func (m *EntityMutation) AddIntervalIDs(ids ...int) {
	if m.intervals == nil {
		m.intervals = make(map[int]struct{})
	}
	for i := range ids {
		m.intervals[ids[i]] = struct{}{}
	}
}

// ClearIntervals clears the "intervals" edge to the Interval entity.
func (m *EntityMutation) ClearIntervals() {
	m.clearedintervals = true
}

// IntervalsCleared reports if the "intervals" edge to the Interval entity was cleared.
func (m *EntityMutation) IntervalsCleared() bool {
	return m.clearedintervals
}

// RemoveIntervalIDs removes the "intervals" edge to the Interval entity by IDs.
func (m *EntityMutation) RemoveIntervalIDs(ids ...int) {
	if m.removedintervals == nil {
		m.removedintervals = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.intervals, ids[i])
		m.removedintervals[ids[i]] = struct{}{}
	}
}

// RemovedIntervals returns the removed IDs of the "intervals" edge to the Interval entity.
func (m *EntityMutation) RemovedIntervalsIDs() (ids []int) {
	for id := range m.removedintervals {
		ids = append(ids, id)
	}
	return
}

// IntervalsIDs returns the "intervals" edge IDs in the mutation.
func (m *EntityMutation) IntervalsIDs() (ids []int) {
	for id := range m.intervals {
		ids = append(ids, id)
	}
	return
}

// ResetIntervals resets all changes to the "intervals" edge.
func (m *EntityMutation) ResetIntervals() {
	m.intervals = nil
	m.clearedintervals = false
	m.removedintervals = nil
}

// AddDividendIDs adds the "dividends" edge to the Dividend entity by ids.
func (m *EntityMutation) AddDividendIDs(ids ...int) {
	if m.dividends == nil {
		m.dividends = make(map[int]struct{})
	}
	for i := range ids {
		m.dividends[ids[i]] = struct{}{}
	}
}

// ClearDividends clears the "dividends" edge to the Dividend entity.
func (m *EntityMutation) ClearDividends() {
	m.cleareddividends = true
}

// DividendsCleared reports if the "dividends" edge to the Dividend entity was cleared.
func (m *EntityMutation) DividendsCleared() bool {
	return m.cleareddividends
}

// RemoveDividendIDs removes the "dividends" edge to the Dividend entity by IDs.
func (m *EntityMutation) RemoveDividendIDs(ids ...int) {
	if m.removeddividends == nil {
		m.removeddividends = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.dividends, ids[i])
		m.removeddividends[ids[i]] = struct{}{}
	}
}

// RemovedDividends returns the removed IDs of the "dividends" edge to the Dividend entity.
func (m *EntityMutation) RemovedDividendsIDs() (ids []int) {
	for id := range m.removeddividends {
		ids = append(ids, id)
	}
	return
}

// DividendsIDs returns the "dividends" edge IDs in the mutation.
func (m *EntityMutation) DividendsIDs() (ids []int) {
	for id := range m.dividends {
		ids = append(ids, id)
	}
	return
}

// ResetDividends resets all changes to the "dividends" edge.
func (m *EntityMutation) ResetDividends() {
	m.dividends = nil
	m.cleareddividends = false
	m.removeddividends = nil
}

// AddSplitIDs adds the "splits" edge to the Split entity by ids.
func (m *EntityMutation) AddSplitIDs(ids ...int) {
	if m.splits == nil {
		m.splits = make(map[int]struct{})
	}
	for i := range ids {
		m.splits[ids[i]] = struct{}{}
	}
}

// ClearSplits clears the "splits" edge to the Split entity.
func (m *EntityMutation) ClearSplits() {
	m.clearedsplits = true
}

// SplitsCleared reports if the "splits" edge to the Split entity was cleared.
func (m *EntityMutation) SplitsCleared() bool {
	return m.clearedsplits
}

// RemoveSplitIDs removes the "splits" edge to the Split entity by IDs.
func (m *EntityMutation) RemoveSplitIDs(ids ...int) {
	if m.removedsplits == nil {
		m.removedsplits = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.splits, ids[i])
		m.removedsplits[ids[i]] = struct{}{}
	}
}

// RemovedSplits returns the removed IDs of the "splits" edge to the Split entity.
func (m *EntityMutation) RemovedSplitsIDs() (ids []int) {
	for id := range m.removedsplits {
		ids = append(ids, id)
	}
	return
}

// SplitsIDs returns the "splits" edge IDs in the mutation.
func (m *EntityMutation) SplitsIDs() (ids []int) {
	for id := range m.splits {
		ids = append(ids, id)
	}
	return
}

// ResetSplits resets all changes to the "splits" edge.
func (m *EntityMutation) ResetSplits() {
	m.splits = nil
	m.clearedsplits = false
	m.removedsplits = nil
}

// AddFinancialIDs adds the "financials" edge to the Financial entity by ids.
func (m *EntityMutation) AddFinancialIDs(ids ...int) {
	if m.financials == nil {
		m.financials = make(map[int]struct{})
	}
	for i := range ids {
		m.financials[ids[i]] = struct{}{}
	}
}

// ClearFinancials clears the "financials" edge to the Financial entity.
func (m *EntityMutation) ClearFinancials() {
	m.clearedfinancials = true
}

// FinancialsCleared reports if the "financials" edge to the Financial entity was cleared.
func (m *EntityMutation) FinancialsCleared() bool {
	return m.clearedfinancials
}

// RemoveFinancialIDs removes the "financials" edge to the Financial entity by IDs.
func (m *EntityMutation) RemoveFinancialIDs(ids ...int) {
	if m.removedfinancials == nil {
		m.removedfinancials = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.financials, ids[i])
		m.removedfinancials[ids[i]] = struct{}{}
	}
}

// RemovedFinancials returns the removed IDs of the "financials" edge to the Financial entity.
func (m *EntityMutation) RemovedFinancialsIDs() (ids []int) {
	for id := range m.removedfinancials {
		ids = append(ids, id)
	}
	return
}

// FinancialsIDs returns the "financials" edge IDs in the mutation.
func (m *EntityMutation) FinancialsIDs() (ids []int) {
	for id := range m.financials {
		ids = append(ids, id)
	}
	return
}

// ResetFinancials resets all changes to the "financials" edge.
func (m *EntityMutation) ResetFinancials() {
	m.financials = nil
	m.clearedfinancials = false
	m.removedfinancials = nil
}

// Where appends a list predicates to the EntityMutation builder.
func (m *EntityMutation) Where(ps ...predicate.Entity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EntityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EntityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Entity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EntityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EntityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Entity).
func (m *EntityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntityMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.active != nil {
		fields = append(fields, entity.FieldActive)
	}
	if m.ticker != nil {
		fields = append(fields, entity.FieldTicker)
	}
	if m.name != nil {
		fields = append(fields, entity.FieldName)
	}
	if m.description != nil {
		fields = append(fields, entity.FieldDescription)
	}
	if m.list_date != nil {
		fields = append(fields, entity.FieldListDate)
	}
	if m.options != nil {
		fields = append(fields, entity.FieldOptions)
	}
	if m.tradable != nil {
		fields = append(fields, entity.FieldTradable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entity.FieldActive:
		return m.Active()
	case entity.FieldTicker:
		return m.Ticker()
	case entity.FieldName:
		return m.Name()
	case entity.FieldDescription:
		return m.Description()
	case entity.FieldListDate:
		return m.ListDate()
	case entity.FieldOptions:
		return m.Options()
	case entity.FieldTradable:
		return m.Tradable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entity.FieldActive:
		return m.OldActive(ctx)
	case entity.FieldTicker:
		return m.OldTicker(ctx)
	case entity.FieldName:
		return m.OldName(ctx)
	case entity.FieldDescription:
		return m.OldDescription(ctx)
	case entity.FieldListDate:
		return m.OldListDate(ctx)
	case entity.FieldOptions:
		return m.OldOptions(ctx)
	case entity.FieldTradable:
		return m.OldTradable(ctx)
	}
	return nil, fmt.Errorf("unknown Entity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entity.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case entity.FieldTicker:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicker(v)
		return nil
	case entity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case entity.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case entity.FieldListDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetListDate(v)
		return nil
	case entity.FieldOptions:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptions(v)
		return nil
	case entity.FieldTradable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTradable(v)
		return nil
	}
	return fmt.Errorf("unknown Entity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Entity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Entity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntityMutation) ResetField(name string) error {
	switch name {
	case entity.FieldActive:
		m.ResetActive()
		return nil
	case entity.FieldTicker:
		m.ResetTicker()
		return nil
	case entity.FieldName:
		m.ResetName()
		return nil
	case entity.FieldDescription:
		m.ResetDescription()
		return nil
	case entity.FieldListDate:
		m.ResetListDate()
		return nil
	case entity.FieldOptions:
		m.ResetOptions()
		return nil
	case entity.FieldTradable:
		m.ResetTradable()
		return nil
	}
	return fmt.Errorf("unknown Entity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntityMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.exchanges != nil {
		edges = append(edges, entity.EdgeExchanges)
	}
	if m.intervals != nil {
		edges = append(edges, entity.EdgeIntervals)
	}
	if m.dividends != nil {
		edges = append(edges, entity.EdgeDividends)
	}
	if m.splits != nil {
		edges = append(edges, entity.EdgeSplits)
	}
	if m.financials != nil {
		edges = append(edges, entity.EdgeFinancials)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entity.EdgeExchanges:
		ids := make([]ent.Value, 0, len(m.exchanges))
		for id := range m.exchanges {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeIntervals:
		ids := make([]ent.Value, 0, len(m.intervals))
		for id := range m.intervals {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeDividends:
		ids := make([]ent.Value, 0, len(m.dividends))
		for id := range m.dividends {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeSplits:
		ids := make([]ent.Value, 0, len(m.splits))
		for id := range m.splits {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeFinancials:
		ids := make([]ent.Value, 0, len(m.financials))
		for id := range m.financials {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedexchanges != nil {
		edges = append(edges, entity.EdgeExchanges)
	}
	if m.removedintervals != nil {
		edges = append(edges, entity.EdgeIntervals)
	}
	if m.removeddividends != nil {
		edges = append(edges, entity.EdgeDividends)
	}
	if m.removedsplits != nil {
		edges = append(edges, entity.EdgeSplits)
	}
	if m.removedfinancials != nil {
		edges = append(edges, entity.EdgeFinancials)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case entity.EdgeExchanges:
		ids := make([]ent.Value, 0, len(m.removedexchanges))
		for id := range m.removedexchanges {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeIntervals:
		ids := make([]ent.Value, 0, len(m.removedintervals))
		for id := range m.removedintervals {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeDividends:
		ids := make([]ent.Value, 0, len(m.removeddividends))
		for id := range m.removeddividends {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeSplits:
		ids := make([]ent.Value, 0, len(m.removedsplits))
		for id := range m.removedsplits {
			ids = append(ids, id)
		}
		return ids
	case entity.EdgeFinancials:
		ids := make([]ent.Value, 0, len(m.removedfinancials))
		for id := range m.removedfinancials {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedexchanges {
		edges = append(edges, entity.EdgeExchanges)
	}
	if m.clearedintervals {
		edges = append(edges, entity.EdgeIntervals)
	}
	if m.cleareddividends {
		edges = append(edges, entity.EdgeDividends)
	}
	if m.clearedsplits {
		edges = append(edges, entity.EdgeSplits)
	}
	if m.clearedfinancials {
		edges = append(edges, entity.EdgeFinancials)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntityMutation) EdgeCleared(name string) bool {
	switch name {
	case entity.EdgeExchanges:
		return m.clearedexchanges
	case entity.EdgeIntervals:
		return m.clearedintervals
	case entity.EdgeDividends:
		return m.cleareddividends
	case entity.EdgeSplits:
		return m.clearedsplits
	case entity.EdgeFinancials:
		return m.clearedfinancials
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Entity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntityMutation) ResetEdge(name string) error {
	switch name {
	case entity.EdgeExchanges:
		m.ResetExchanges()
		return nil
	case entity.EdgeIntervals:
		m.ResetIntervals()
		return nil
	case entity.EdgeDividends:
		m.ResetDividends()
		return nil
	case entity.EdgeSplits:
		m.ResetSplits()
		return nil
	case entity.EdgeFinancials:
		m.ResetFinancials()
		return nil
	}
	return fmt.Errorf("unknown Entity edge %s", name)
}

// ExchangeMutation represents an operation that mutates the Exchange nodes in the graph.
type ExchangeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	code          *string
	name          *string
	clearedFields map[string]struct{}
	stocks        map[int]struct{}
	removedstocks map[int]struct{}
	clearedstocks bool
	done          bool
	oldValue      func(context.Context) (*Exchange, error)
	predicates    []predicate.Exchange
}

var _ ent.Mutation = (*ExchangeMutation)(nil)

// exchangeOption allows management of the mutation configuration using functional options.
type exchangeOption func(*ExchangeMutation)

// newExchangeMutation creates new mutation for the Exchange entity.
func newExchangeMutation(c config, op Op, opts ...exchangeOption) *ExchangeMutation {
	m := &ExchangeMutation{
		config:        c,
		op:            op,
		typ:           TypeExchange,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExchangeID sets the ID field of the mutation.
func withExchangeID(id int) exchangeOption {
	return func(m *ExchangeMutation) {
		var (
			err   error
			once  sync.Once
			value *Exchange
		)
		m.oldValue = func(ctx context.Context) (*Exchange, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exchange.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExchange sets the old Exchange of the mutation.
func withExchange(node *Exchange) exchangeOption {
	return func(m *ExchangeMutation) {
		m.oldValue = func(context.Context) (*Exchange, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExchangeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExchangeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExchangeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExchangeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exchange.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *ExchangeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ExchangeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ExchangeMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *ExchangeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ExchangeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ExchangeMutation) ResetName() {
	m.name = nil
}

// AddStockIDs adds the "stocks" edge to the Entity entity by ids.
func (m *ExchangeMutation) AddStockIDs(ids ...int) {
	if m.stocks == nil {
		m.stocks = make(map[int]struct{})
	}
	for i := range ids {
		m.stocks[ids[i]] = struct{}{}
	}
}

// ClearStocks clears the "stocks" edge to the Entity entity.
func (m *ExchangeMutation) ClearStocks() {
	m.clearedstocks = true
}

// StocksCleared reports if the "stocks" edge to the Entity entity was cleared.
func (m *ExchangeMutation) StocksCleared() bool {
	return m.clearedstocks
}

// RemoveStockIDs removes the "stocks" edge to the Entity entity by IDs.
func (m *ExchangeMutation) RemoveStockIDs(ids ...int) {
	if m.removedstocks == nil {
		m.removedstocks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.stocks, ids[i])
		m.removedstocks[ids[i]] = struct{}{}
	}
}

// RemovedStocks returns the removed IDs of the "stocks" edge to the Entity entity.
func (m *ExchangeMutation) RemovedStocksIDs() (ids []int) {
	for id := range m.removedstocks {
		ids = append(ids, id)
	}
	return
}

// StocksIDs returns the "stocks" edge IDs in the mutation.
func (m *ExchangeMutation) StocksIDs() (ids []int) {
	for id := range m.stocks {
		ids = append(ids, id)
	}
	return
}

// ResetStocks resets all changes to the "stocks" edge.
func (m *ExchangeMutation) ResetStocks() {
	m.stocks = nil
	m.clearedstocks = false
	m.removedstocks = nil
}

// Where appends a list predicates to the ExchangeMutation builder.
func (m *ExchangeMutation) Where(ps ...predicate.Exchange) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExchangeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExchangeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Exchange, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExchangeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExchangeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Exchange).
func (m *ExchangeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExchangeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.code != nil {
		fields = append(fields, exchange.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, exchange.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExchangeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exchange.FieldCode:
		return m.Code()
	case exchange.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExchangeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exchange.FieldCode:
		return m.OldCode(ctx)
	case exchange.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Exchange field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exchange.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case exchange.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExchangeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExchangeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Exchange numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExchangeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExchangeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExchangeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Exchange nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExchangeMutation) ResetField(name string) error {
	switch name {
	case exchange.FieldCode:
		m.ResetCode()
		return nil
	case exchange.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExchangeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.stocks != nil {
		edges = append(edges, exchange.EdgeStocks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExchangeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exchange.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.stocks))
		for id := range m.stocks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExchangeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstocks != nil {
		edges = append(edges, exchange.EdgeStocks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExchangeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case exchange.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.removedstocks))
		for id := range m.removedstocks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExchangeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstocks {
		edges = append(edges, exchange.EdgeStocks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExchangeMutation) EdgeCleared(name string) bool {
	switch name {
	case exchange.EdgeStocks:
		return m.clearedstocks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExchangeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Exchange unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExchangeMutation) ResetEdge(name string) error {
	switch name {
	case exchange.EdgeStocks:
		m.ResetStocks()
		return nil
	}
	return fmt.Errorf("unknown Exchange edge %s", name)
}

// FinancialMutation represents an operation that mutates the Financial nodes in the graph.
type FinancialMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	stock         map[int]struct{}
	removedstock  map[int]struct{}
	clearedstock  bool
	done          bool
	oldValue      func(context.Context) (*Financial, error)
	predicates    []predicate.Financial
}

var _ ent.Mutation = (*FinancialMutation)(nil)

// financialOption allows management of the mutation configuration using functional options.
type financialOption func(*FinancialMutation)

// newFinancialMutation creates new mutation for the Financial entity.
func newFinancialMutation(c config, op Op, opts ...financialOption) *FinancialMutation {
	m := &FinancialMutation{
		config:        c,
		op:            op,
		typ:           TypeFinancial,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFinancialID sets the ID field of the mutation.
func withFinancialID(id int) financialOption {
	return func(m *FinancialMutation) {
		var (
			err   error
			once  sync.Once
			value *Financial
		)
		m.oldValue = func(ctx context.Context) (*Financial, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Financial.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFinancial sets the old Financial of the mutation.
func withFinancial(node *Financial) financialOption {
	return func(m *FinancialMutation) {
		m.oldValue = func(context.Context) (*Financial, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FinancialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FinancialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FinancialMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FinancialMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Financial.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// AddStockIDs adds the "stock" edge to the Entity entity by ids.
func (m *FinancialMutation) AddStockIDs(ids ...int) {
	if m.stock == nil {
		m.stock = make(map[int]struct{})
	}
	for i := range ids {
		m.stock[ids[i]] = struct{}{}
	}
}

// ClearStock clears the "stock" edge to the Entity entity.
func (m *FinancialMutation) ClearStock() {
	m.clearedstock = true
}

// StockCleared reports if the "stock" edge to the Entity entity was cleared.
func (m *FinancialMutation) StockCleared() bool {
	return m.clearedstock
}

// RemoveStockIDs removes the "stock" edge to the Entity entity by IDs.
func (m *FinancialMutation) RemoveStockIDs(ids ...int) {
	if m.removedstock == nil {
		m.removedstock = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.stock, ids[i])
		m.removedstock[ids[i]] = struct{}{}
	}
}

// RemovedStock returns the removed IDs of the "stock" edge to the Entity entity.
func (m *FinancialMutation) RemovedStockIDs() (ids []int) {
	for id := range m.removedstock {
		ids = append(ids, id)
	}
	return
}

// StockIDs returns the "stock" edge IDs in the mutation.
func (m *FinancialMutation) StockIDs() (ids []int) {
	for id := range m.stock {
		ids = append(ids, id)
	}
	return
}

// ResetStock resets all changes to the "stock" edge.
func (m *FinancialMutation) ResetStock() {
	m.stock = nil
	m.clearedstock = false
	m.removedstock = nil
}

// Where appends a list predicates to the FinancialMutation builder.
func (m *FinancialMutation) Where(ps ...predicate.Financial) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FinancialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FinancialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Financial, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FinancialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FinancialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Financial).
func (m *FinancialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FinancialMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FinancialMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FinancialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Financial field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FinancialMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Financial field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FinancialMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FinancialMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FinancialMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Financial numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FinancialMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FinancialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FinancialMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Financial nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FinancialMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Financial field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FinancialMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.stock != nil {
		edges = append(edges, financial.EdgeStock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FinancialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case financial.EdgeStock:
		ids := make([]ent.Value, 0, len(m.stock))
		for id := range m.stock {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FinancialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstock != nil {
		edges = append(edges, financial.EdgeStock)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FinancialMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case financial.EdgeStock:
		ids := make([]ent.Value, 0, len(m.removedstock))
		for id := range m.removedstock {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FinancialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstock {
		edges = append(edges, financial.EdgeStock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FinancialMutation) EdgeCleared(name string) bool {
	switch name {
	case financial.EdgeStock:
		return m.clearedstock
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FinancialMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Financial unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FinancialMutation) ResetEdge(name string) error {
	switch name {
	case financial.EdgeStock:
		m.ResetStock()
		return nil
	}
	return fmt.Errorf("unknown Financial edge %s", name)
}

// IntervalMutation represents an operation that mutates the Interval nodes in the graph.
type IntervalMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	active             *bool
	interval           *interval.Interval
	clearedFields      map[string]struct{}
	data_source        *int
	cleareddata_source bool
	stock              *int
	clearedstock       bool
	bars               map[int]struct{}
	removedbars        map[int]struct{}
	clearedbars        bool
	trades             map[int]struct{}
	removedtrades      map[int]struct{}
	clearedtrades      bool
	done               bool
	oldValue           func(context.Context) (*Interval, error)
	predicates         []predicate.Interval
}

var _ ent.Mutation = (*IntervalMutation)(nil)

// intervalOption allows management of the mutation configuration using functional options.
type intervalOption func(*IntervalMutation)

// newIntervalMutation creates new mutation for the Interval entity.
func newIntervalMutation(c config, op Op, opts ...intervalOption) *IntervalMutation {
	m := &IntervalMutation{
		config:        c,
		op:            op,
		typ:           TypeInterval,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIntervalID sets the ID field of the mutation.
func withIntervalID(id int) intervalOption {
	return func(m *IntervalMutation) {
		var (
			err   error
			once  sync.Once
			value *Interval
		)
		m.oldValue = func(ctx context.Context) (*Interval, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Interval.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInterval sets the old Interval of the mutation.
func withInterval(node *Interval) intervalOption {
	return func(m *IntervalMutation) {
		m.oldValue = func(context.Context) (*Interval, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IntervalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IntervalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IntervalMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IntervalMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Interval.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActive sets the "active" field.
func (m *IntervalMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *IntervalMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Interval entity.
// If the Interval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntervalMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *IntervalMutation) ResetActive() {
	m.active = nil
}

// SetInterval sets the "interval" field.
func (m *IntervalMutation) SetInterval(i interval.Interval) {
	m.interval = &i
}

// Interval returns the value of the "interval" field in the mutation.
func (m *IntervalMutation) Interval() (r interval.Interval, exists bool) {
	v := m.interval
	if v == nil {
		return
	}
	return *v, true
}

// OldInterval returns the old "interval" field's value of the Interval entity.
// If the Interval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntervalMutation) OldInterval(ctx context.Context) (v interval.Interval, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterval: %w", err)
	}
	return oldValue.Interval, nil
}

// ResetInterval resets all changes to the "interval" field.
func (m *IntervalMutation) ResetInterval() {
	m.interval = nil
}

// SetStockID sets the "stock_id" field.
func (m *IntervalMutation) SetStockID(i int) {
	m.stock = &i
}

// StockID returns the value of the "stock_id" field in the mutation.
func (m *IntervalMutation) StockID() (r int, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStockID returns the old "stock_id" field's value of the Interval entity.
// If the Interval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntervalMutation) OldStockID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStockID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStockID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStockID: %w", err)
	}
	return oldValue.StockID, nil
}

// ResetStockID resets all changes to the "stock_id" field.
func (m *IntervalMutation) ResetStockID() {
	m.stock = nil
}

// SetDataSourceID sets the "data_source_id" field.
func (m *IntervalMutation) SetDataSourceID(i int) {
	m.data_source = &i
}

// DataSourceID returns the value of the "data_source_id" field in the mutation.
func (m *IntervalMutation) DataSourceID() (r int, exists bool) {
	v := m.data_source
	if v == nil {
		return
	}
	return *v, true
}

// OldDataSourceID returns the old "data_source_id" field's value of the Interval entity.
// If the Interval object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IntervalMutation) OldDataSourceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataSourceID: %w", err)
	}
	return oldValue.DataSourceID, nil
}

// ResetDataSourceID resets all changes to the "data_source_id" field.
func (m *IntervalMutation) ResetDataSourceID() {
	m.data_source = nil
}

// ClearDataSource clears the "data_source" edge to the DataSource entity.
func (m *IntervalMutation) ClearDataSource() {
	m.cleareddata_source = true
	m.clearedFields[interval.FieldDataSourceID] = struct{}{}
}

// DataSourceCleared reports if the "data_source" edge to the DataSource entity was cleared.
func (m *IntervalMutation) DataSourceCleared() bool {
	return m.cleareddata_source
}

// DataSourceIDs returns the "data_source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DataSourceID instead. It exists only for internal usage by the builders.
func (m *IntervalMutation) DataSourceIDs() (ids []int) {
	if id := m.data_source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDataSource resets all changes to the "data_source" edge.
func (m *IntervalMutation) ResetDataSource() {
	m.data_source = nil
	m.cleareddata_source = false
}

// ClearStock clears the "stock" edge to the Entity entity.
func (m *IntervalMutation) ClearStock() {
	m.clearedstock = true
	m.clearedFields[interval.FieldStockID] = struct{}{}
}

// StockCleared reports if the "stock" edge to the Entity entity was cleared.
func (m *IntervalMutation) StockCleared() bool {
	return m.clearedstock
}

// StockIDs returns the "stock" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StockID instead. It exists only for internal usage by the builders.
func (m *IntervalMutation) StockIDs() (ids []int) {
	if id := m.stock; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStock resets all changes to the "stock" edge.
func (m *IntervalMutation) ResetStock() {
	m.stock = nil
	m.clearedstock = false
}

// AddBarIDs adds the "bars" edge to the BarTimeRange entity by ids.
func (m *IntervalMutation) AddBarIDs(ids ...int) {
	if m.bars == nil {
		m.bars = make(map[int]struct{})
	}
	for i := range ids {
		m.bars[ids[i]] = struct{}{}
	}
}

// ClearBars clears the "bars" edge to the BarTimeRange entity.
func (m *IntervalMutation) ClearBars() {
	m.clearedbars = true
}

// BarsCleared reports if the "bars" edge to the BarTimeRange entity was cleared.
func (m *IntervalMutation) BarsCleared() bool {
	return m.clearedbars
}

// RemoveBarIDs removes the "bars" edge to the BarTimeRange entity by IDs.
func (m *IntervalMutation) RemoveBarIDs(ids ...int) {
	if m.removedbars == nil {
		m.removedbars = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.bars, ids[i])
		m.removedbars[ids[i]] = struct{}{}
	}
}

// RemovedBars returns the removed IDs of the "bars" edge to the BarTimeRange entity.
func (m *IntervalMutation) RemovedBarsIDs() (ids []int) {
	for id := range m.removedbars {
		ids = append(ids, id)
	}
	return
}

// BarsIDs returns the "bars" edge IDs in the mutation.
func (m *IntervalMutation) BarsIDs() (ids []int) {
	for id := range m.bars {
		ids = append(ids, id)
	}
	return
}

// ResetBars resets all changes to the "bars" edge.
func (m *IntervalMutation) ResetBars() {
	m.bars = nil
	m.clearedbars = false
	m.removedbars = nil
}

// AddTradeIDs adds the "trades" edge to the TradeTimeRange entity by ids.
func (m *IntervalMutation) AddTradeIDs(ids ...int) {
	if m.trades == nil {
		m.trades = make(map[int]struct{})
	}
	for i := range ids {
		m.trades[ids[i]] = struct{}{}
	}
}

// ClearTrades clears the "trades" edge to the TradeTimeRange entity.
func (m *IntervalMutation) ClearTrades() {
	m.clearedtrades = true
}

// TradesCleared reports if the "trades" edge to the TradeTimeRange entity was cleared.
func (m *IntervalMutation) TradesCleared() bool {
	return m.clearedtrades
}

// RemoveTradeIDs removes the "trades" edge to the TradeTimeRange entity by IDs.
func (m *IntervalMutation) RemoveTradeIDs(ids ...int) {
	if m.removedtrades == nil {
		m.removedtrades = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.trades, ids[i])
		m.removedtrades[ids[i]] = struct{}{}
	}
}

// RemovedTrades returns the removed IDs of the "trades" edge to the TradeTimeRange entity.
func (m *IntervalMutation) RemovedTradesIDs() (ids []int) {
	for id := range m.removedtrades {
		ids = append(ids, id)
	}
	return
}

// TradesIDs returns the "trades" edge IDs in the mutation.
func (m *IntervalMutation) TradesIDs() (ids []int) {
	for id := range m.trades {
		ids = append(ids, id)
	}
	return
}

// ResetTrades resets all changes to the "trades" edge.
func (m *IntervalMutation) ResetTrades() {
	m.trades = nil
	m.clearedtrades = false
	m.removedtrades = nil
}

// Where appends a list predicates to the IntervalMutation builder.
func (m *IntervalMutation) Where(ps ...predicate.Interval) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IntervalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IntervalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Interval, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IntervalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IntervalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Interval).
func (m *IntervalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IntervalMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.active != nil {
		fields = append(fields, interval.FieldActive)
	}
	if m.interval != nil {
		fields = append(fields, interval.FieldInterval)
	}
	if m.stock != nil {
		fields = append(fields, interval.FieldStockID)
	}
	if m.data_source != nil {
		fields = append(fields, interval.FieldDataSourceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IntervalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case interval.FieldActive:
		return m.Active()
	case interval.FieldInterval:
		return m.Interval()
	case interval.FieldStockID:
		return m.StockID()
	case interval.FieldDataSourceID:
		return m.DataSourceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IntervalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case interval.FieldActive:
		return m.OldActive(ctx)
	case interval.FieldInterval:
		return m.OldInterval(ctx)
	case interval.FieldStockID:
		return m.OldStockID(ctx)
	case interval.FieldDataSourceID:
		return m.OldDataSourceID(ctx)
	}
	return nil, fmt.Errorf("unknown Interval field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IntervalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case interval.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case interval.FieldInterval:
		v, ok := value.(interval.Interval)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterval(v)
		return nil
	case interval.FieldStockID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStockID(v)
		return nil
	case interval.FieldDataSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataSourceID(v)
		return nil
	}
	return fmt.Errorf("unknown Interval field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IntervalMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IntervalMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IntervalMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Interval numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IntervalMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IntervalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IntervalMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Interval nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IntervalMutation) ResetField(name string) error {
	switch name {
	case interval.FieldActive:
		m.ResetActive()
		return nil
	case interval.FieldInterval:
		m.ResetInterval()
		return nil
	case interval.FieldStockID:
		m.ResetStockID()
		return nil
	case interval.FieldDataSourceID:
		m.ResetDataSourceID()
		return nil
	}
	return fmt.Errorf("unknown Interval field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IntervalMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.data_source != nil {
		edges = append(edges, interval.EdgeDataSource)
	}
	if m.stock != nil {
		edges = append(edges, interval.EdgeStock)
	}
	if m.bars != nil {
		edges = append(edges, interval.EdgeBars)
	}
	if m.trades != nil {
		edges = append(edges, interval.EdgeTrades)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IntervalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case interval.EdgeDataSource:
		if id := m.data_source; id != nil {
			return []ent.Value{*id}
		}
	case interval.EdgeStock:
		if id := m.stock; id != nil {
			return []ent.Value{*id}
		}
	case interval.EdgeBars:
		ids := make([]ent.Value, 0, len(m.bars))
		for id := range m.bars {
			ids = append(ids, id)
		}
		return ids
	case interval.EdgeTrades:
		ids := make([]ent.Value, 0, len(m.trades))
		for id := range m.trades {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IntervalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedbars != nil {
		edges = append(edges, interval.EdgeBars)
	}
	if m.removedtrades != nil {
		edges = append(edges, interval.EdgeTrades)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IntervalMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case interval.EdgeBars:
		ids := make([]ent.Value, 0, len(m.removedbars))
		for id := range m.removedbars {
			ids = append(ids, id)
		}
		return ids
	case interval.EdgeTrades:
		ids := make([]ent.Value, 0, len(m.removedtrades))
		for id := range m.removedtrades {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IntervalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareddata_source {
		edges = append(edges, interval.EdgeDataSource)
	}
	if m.clearedstock {
		edges = append(edges, interval.EdgeStock)
	}
	if m.clearedbars {
		edges = append(edges, interval.EdgeBars)
	}
	if m.clearedtrades {
		edges = append(edges, interval.EdgeTrades)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IntervalMutation) EdgeCleared(name string) bool {
	switch name {
	case interval.EdgeDataSource:
		return m.cleareddata_source
	case interval.EdgeStock:
		return m.clearedstock
	case interval.EdgeBars:
		return m.clearedbars
	case interval.EdgeTrades:
		return m.clearedtrades
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IntervalMutation) ClearEdge(name string) error {
	switch name {
	case interval.EdgeDataSource:
		m.ClearDataSource()
		return nil
	case interval.EdgeStock:
		m.ClearStock()
		return nil
	}
	return fmt.Errorf("unknown Interval unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IntervalMutation) ResetEdge(name string) error {
	switch name {
	case interval.EdgeDataSource:
		m.ResetDataSource()
		return nil
	case interval.EdgeStock:
		m.ResetStock()
		return nil
	case interval.EdgeBars:
		m.ResetBars()
		return nil
	case interval.EdgeTrades:
		m.ResetTrades()
		return nil
	}
	return fmt.Errorf("unknown Interval edge %s", name)
}

// MarketHoursMutation represents an operation that mutates the MarketHours nodes in the graph.
type MarketHoursMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	date               *time.Time
	start_time         *time.Time
	end_time           *time.Time
	clearedFields      map[string]struct{}
	market_info        *int
	clearedmarket_info bool
	done               bool
	oldValue           func(context.Context) (*MarketHours, error)
	predicates         []predicate.MarketHours
}

var _ ent.Mutation = (*MarketHoursMutation)(nil)

// markethoursOption allows management of the mutation configuration using functional options.
type markethoursOption func(*MarketHoursMutation)

// newMarketHoursMutation creates new mutation for the MarketHours entity.
func newMarketHoursMutation(c config, op Op, opts ...markethoursOption) *MarketHoursMutation {
	m := &MarketHoursMutation{
		config:        c,
		op:            op,
		typ:           TypeMarketHours,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMarketHoursID sets the ID field of the mutation.
func withMarketHoursID(id int) markethoursOption {
	return func(m *MarketHoursMutation) {
		var (
			err   error
			once  sync.Once
			value *MarketHours
		)
		m.oldValue = func(ctx context.Context) (*MarketHours, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MarketHours.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMarketHours sets the old MarketHours of the mutation.
func withMarketHours(node *MarketHours) markethoursOption {
	return func(m *MarketHoursMutation) {
		m.oldValue = func(context.Context) (*MarketHours, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MarketHoursMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MarketHoursMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MarketHoursMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MarketHoursMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MarketHours.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDate sets the "date" field.
func (m *MarketHoursMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *MarketHoursMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the MarketHours entity.
// If the MarketHours object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketHoursMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *MarketHoursMutation) ResetDate() {
	m.date = nil
}

// SetStartTime sets the "start_time" field.
func (m *MarketHoursMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *MarketHoursMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the MarketHours entity.
// If the MarketHours object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketHoursMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *MarketHoursMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *MarketHoursMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *MarketHoursMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the MarketHours entity.
// If the MarketHours object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketHoursMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *MarketHoursMutation) ResetEndTime() {
	m.end_time = nil
}

// SetMarketInfoID sets the "market_info" edge to the MarketInfo entity by id.
func (m *MarketHoursMutation) SetMarketInfoID(id int) {
	m.market_info = &id
}

// ClearMarketInfo clears the "market_info" edge to the MarketInfo entity.
func (m *MarketHoursMutation) ClearMarketInfo() {
	m.clearedmarket_info = true
}

// MarketInfoCleared reports if the "market_info" edge to the MarketInfo entity was cleared.
func (m *MarketHoursMutation) MarketInfoCleared() bool {
	return m.clearedmarket_info
}

// MarketInfoID returns the "market_info" edge ID in the mutation.
func (m *MarketHoursMutation) MarketInfoID() (id int, exists bool) {
	if m.market_info != nil {
		return *m.market_info, true
	}
	return
}

// MarketInfoIDs returns the "market_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MarketInfoID instead. It exists only for internal usage by the builders.
func (m *MarketHoursMutation) MarketInfoIDs() (ids []int) {
	if id := m.market_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMarketInfo resets all changes to the "market_info" edge.
func (m *MarketHoursMutation) ResetMarketInfo() {
	m.market_info = nil
	m.clearedmarket_info = false
}

// Where appends a list predicates to the MarketHoursMutation builder.
func (m *MarketHoursMutation) Where(ps ...predicate.MarketHours) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MarketHoursMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MarketHoursMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MarketHours, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MarketHoursMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MarketHoursMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MarketHours).
func (m *MarketHoursMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MarketHoursMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.date != nil {
		fields = append(fields, markethours.FieldDate)
	}
	if m.start_time != nil {
		fields = append(fields, markethours.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, markethours.FieldEndTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MarketHoursMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case markethours.FieldDate:
		return m.Date()
	case markethours.FieldStartTime:
		return m.StartTime()
	case markethours.FieldEndTime:
		return m.EndTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MarketHoursMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case markethours.FieldDate:
		return m.OldDate(ctx)
	case markethours.FieldStartTime:
		return m.OldStartTime(ctx)
	case markethours.FieldEndTime:
		return m.OldEndTime(ctx)
	}
	return nil, fmt.Errorf("unknown MarketHours field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MarketHoursMutation) SetField(name string, value ent.Value) error {
	switch name {
	case markethours.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case markethours.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case markethours.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown MarketHours field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MarketHoursMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MarketHoursMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MarketHoursMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MarketHours numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MarketHoursMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MarketHoursMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MarketHoursMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MarketHours nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MarketHoursMutation) ResetField(name string) error {
	switch name {
	case markethours.FieldDate:
		m.ResetDate()
		return nil
	case markethours.FieldStartTime:
		m.ResetStartTime()
		return nil
	case markethours.FieldEndTime:
		m.ResetEndTime()
		return nil
	}
	return fmt.Errorf("unknown MarketHours field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MarketHoursMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.market_info != nil {
		edges = append(edges, markethours.EdgeMarketInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MarketHoursMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case markethours.EdgeMarketInfo:
		if id := m.market_info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MarketHoursMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MarketHoursMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MarketHoursMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmarket_info {
		edges = append(edges, markethours.EdgeMarketInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MarketHoursMutation) EdgeCleared(name string) bool {
	switch name {
	case markethours.EdgeMarketInfo:
		return m.clearedmarket_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MarketHoursMutation) ClearEdge(name string) error {
	switch name {
	case markethours.EdgeMarketInfo:
		m.ClearMarketInfo()
		return nil
	}
	return fmt.Errorf("unknown MarketHours unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MarketHoursMutation) ResetEdge(name string) error {
	switch name {
	case markethours.EdgeMarketInfo:
		m.ResetMarketInfo()
		return nil
	}
	return fmt.Errorf("unknown MarketHours edge %s", name)
}

// MarketInfoMutation represents an operation that mutates the MarketInfo nodes in the graph.
type MarketInfoMutation struct {
	config
	op            Op
	typ           string
	id            *int
	hours_start   *time.Time
	hours_end     *time.Time
	clearedFields map[string]struct{}
	hours         map[int]struct{}
	removedhours  map[int]struct{}
	clearedhours  bool
	done          bool
	oldValue      func(context.Context) (*MarketInfo, error)
	predicates    []predicate.MarketInfo
}

var _ ent.Mutation = (*MarketInfoMutation)(nil)

// marketinfoOption allows management of the mutation configuration using functional options.
type marketinfoOption func(*MarketInfoMutation)

// newMarketInfoMutation creates new mutation for the MarketInfo entity.
func newMarketInfoMutation(c config, op Op, opts ...marketinfoOption) *MarketInfoMutation {
	m := &MarketInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeMarketInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMarketInfoID sets the ID field of the mutation.
func withMarketInfoID(id int) marketinfoOption {
	return func(m *MarketInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *MarketInfo
		)
		m.oldValue = func(ctx context.Context) (*MarketInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MarketInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMarketInfo sets the old MarketInfo of the mutation.
func withMarketInfo(node *MarketInfo) marketinfoOption {
	return func(m *MarketInfoMutation) {
		m.oldValue = func(context.Context) (*MarketInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MarketInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MarketInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MarketInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MarketInfoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MarketInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHoursStart sets the "hours_start" field.
func (m *MarketInfoMutation) SetHoursStart(t time.Time) {
	m.hours_start = &t
}

// HoursStart returns the value of the "hours_start" field in the mutation.
func (m *MarketInfoMutation) HoursStart() (r time.Time, exists bool) {
	v := m.hours_start
	if v == nil {
		return
	}
	return *v, true
}

// OldHoursStart returns the old "hours_start" field's value of the MarketInfo entity.
// If the MarketInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketInfoMutation) OldHoursStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHoursStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHoursStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHoursStart: %w", err)
	}
	return oldValue.HoursStart, nil
}

// ResetHoursStart resets all changes to the "hours_start" field.
func (m *MarketInfoMutation) ResetHoursStart() {
	m.hours_start = nil
}

// SetHoursEnd sets the "hours_end" field.
func (m *MarketInfoMutation) SetHoursEnd(t time.Time) {
	m.hours_end = &t
}

// HoursEnd returns the value of the "hours_end" field in the mutation.
func (m *MarketInfoMutation) HoursEnd() (r time.Time, exists bool) {
	v := m.hours_end
	if v == nil {
		return
	}
	return *v, true
}

// OldHoursEnd returns the old "hours_end" field's value of the MarketInfo entity.
// If the MarketInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MarketInfoMutation) OldHoursEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHoursEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHoursEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHoursEnd: %w", err)
	}
	return oldValue.HoursEnd, nil
}

// ResetHoursEnd resets all changes to the "hours_end" field.
func (m *MarketInfoMutation) ResetHoursEnd() {
	m.hours_end = nil
}

// AddHourIDs adds the "hours" edge to the MarketHours entity by ids.
func (m *MarketInfoMutation) AddHourIDs(ids ...int) {
	if m.hours == nil {
		m.hours = make(map[int]struct{})
	}
	for i := range ids {
		m.hours[ids[i]] = struct{}{}
	}
}

// ClearHours clears the "hours" edge to the MarketHours entity.
func (m *MarketInfoMutation) ClearHours() {
	m.clearedhours = true
}

// HoursCleared reports if the "hours" edge to the MarketHours entity was cleared.
func (m *MarketInfoMutation) HoursCleared() bool {
	return m.clearedhours
}

// RemoveHourIDs removes the "hours" edge to the MarketHours entity by IDs.
func (m *MarketInfoMutation) RemoveHourIDs(ids ...int) {
	if m.removedhours == nil {
		m.removedhours = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.hours, ids[i])
		m.removedhours[ids[i]] = struct{}{}
	}
}

// RemovedHours returns the removed IDs of the "hours" edge to the MarketHours entity.
func (m *MarketInfoMutation) RemovedHoursIDs() (ids []int) {
	for id := range m.removedhours {
		ids = append(ids, id)
	}
	return
}

// HoursIDs returns the "hours" edge IDs in the mutation.
func (m *MarketInfoMutation) HoursIDs() (ids []int) {
	for id := range m.hours {
		ids = append(ids, id)
	}
	return
}

// ResetHours resets all changes to the "hours" edge.
func (m *MarketInfoMutation) ResetHours() {
	m.hours = nil
	m.clearedhours = false
	m.removedhours = nil
}

// Where appends a list predicates to the MarketInfoMutation builder.
func (m *MarketInfoMutation) Where(ps ...predicate.MarketInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MarketInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MarketInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MarketInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MarketInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MarketInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MarketInfo).
func (m *MarketInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MarketInfoMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.hours_start != nil {
		fields = append(fields, marketinfo.FieldHoursStart)
	}
	if m.hours_end != nil {
		fields = append(fields, marketinfo.FieldHoursEnd)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MarketInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case marketinfo.FieldHoursStart:
		return m.HoursStart()
	case marketinfo.FieldHoursEnd:
		return m.HoursEnd()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MarketInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case marketinfo.FieldHoursStart:
		return m.OldHoursStart(ctx)
	case marketinfo.FieldHoursEnd:
		return m.OldHoursEnd(ctx)
	}
	return nil, fmt.Errorf("unknown MarketInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MarketInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case marketinfo.FieldHoursStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHoursStart(v)
		return nil
	case marketinfo.FieldHoursEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHoursEnd(v)
		return nil
	}
	return fmt.Errorf("unknown MarketInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MarketInfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MarketInfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MarketInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MarketInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MarketInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MarketInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MarketInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MarketInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MarketInfoMutation) ResetField(name string) error {
	switch name {
	case marketinfo.FieldHoursStart:
		m.ResetHoursStart()
		return nil
	case marketinfo.FieldHoursEnd:
		m.ResetHoursEnd()
		return nil
	}
	return fmt.Errorf("unknown MarketInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MarketInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.hours != nil {
		edges = append(edges, marketinfo.EdgeHours)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MarketInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case marketinfo.EdgeHours:
		ids := make([]ent.Value, 0, len(m.hours))
		for id := range m.hours {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MarketInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedhours != nil {
		edges = append(edges, marketinfo.EdgeHours)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MarketInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case marketinfo.EdgeHours:
		ids := make([]ent.Value, 0, len(m.removedhours))
		for id := range m.removedhours {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MarketInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhours {
		edges = append(edges, marketinfo.EdgeHours)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MarketInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case marketinfo.EdgeHours:
		return m.clearedhours
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MarketInfoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MarketInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MarketInfoMutation) ResetEdge(name string) error {
	switch name {
	case marketinfo.EdgeHours:
		m.ResetHours()
		return nil
	}
	return fmt.Errorf("unknown MarketInfo edge %s", name)
}

// SplitMutation represents an operation that mutates the Split nodes in the graph.
type SplitMutation struct {
	config
	op             Op
	typ            string
	id             *int
	execution_date *time.Time
	from           *float64
	addfrom        *float64
	to             *float64
	addto          *float64
	clearedFields  map[string]struct{}
	stock          *int
	clearedstock   bool
	done           bool
	oldValue       func(context.Context) (*Split, error)
	predicates     []predicate.Split
}

var _ ent.Mutation = (*SplitMutation)(nil)

// splitOption allows management of the mutation configuration using functional options.
type splitOption func(*SplitMutation)

// newSplitMutation creates new mutation for the Split entity.
func newSplitMutation(c config, op Op, opts ...splitOption) *SplitMutation {
	m := &SplitMutation{
		config:        c,
		op:            op,
		typ:           TypeSplit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSplitID sets the ID field of the mutation.
func withSplitID(id int) splitOption {
	return func(m *SplitMutation) {
		var (
			err   error
			once  sync.Once
			value *Split
		)
		m.oldValue = func(ctx context.Context) (*Split, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Split.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSplit sets the old Split of the mutation.
func withSplit(node *Split) splitOption {
	return func(m *SplitMutation) {
		m.oldValue = func(context.Context) (*Split, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SplitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SplitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SplitMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SplitMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Split.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExecutionDate sets the "execution_date" field.
func (m *SplitMutation) SetExecutionDate(t time.Time) {
	m.execution_date = &t
}

// ExecutionDate returns the value of the "execution_date" field in the mutation.
func (m *SplitMutation) ExecutionDate() (r time.Time, exists bool) {
	v := m.execution_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionDate returns the old "execution_date" field's value of the Split entity.
// If the Split object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SplitMutation) OldExecutionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionDate: %w", err)
	}
	return oldValue.ExecutionDate, nil
}

// ResetExecutionDate resets all changes to the "execution_date" field.
func (m *SplitMutation) ResetExecutionDate() {
	m.execution_date = nil
}

// SetFrom sets the "from" field.
func (m *SplitMutation) SetFrom(f float64) {
	m.from = &f
	m.addfrom = nil
}

// From returns the value of the "from" field in the mutation.
func (m *SplitMutation) From() (r float64, exists bool) {
	v := m.from
	if v == nil {
		return
	}
	return *v, true
}

// OldFrom returns the old "from" field's value of the Split entity.
// If the Split object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SplitMutation) OldFrom(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrom: %w", err)
	}
	return oldValue.From, nil
}

// AddFrom adds f to the "from" field.
func (m *SplitMutation) AddFrom(f float64) {
	if m.addfrom != nil {
		*m.addfrom += f
	} else {
		m.addfrom = &f
	}
}

// AddedFrom returns the value that was added to the "from" field in this mutation.
func (m *SplitMutation) AddedFrom() (r float64, exists bool) {
	v := m.addfrom
	if v == nil {
		return
	}
	return *v, true
}

// ResetFrom resets all changes to the "from" field.
func (m *SplitMutation) ResetFrom() {
	m.from = nil
	m.addfrom = nil
}

// SetTo sets the "to" field.
func (m *SplitMutation) SetTo(f float64) {
	m.to = &f
	m.addto = nil
}

// To returns the value of the "to" field in the mutation.
func (m *SplitMutation) To() (r float64, exists bool) {
	v := m.to
	if v == nil {
		return
	}
	return *v, true
}

// OldTo returns the old "to" field's value of the Split entity.
// If the Split object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SplitMutation) OldTo(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTo: %w", err)
	}
	return oldValue.To, nil
}

// AddTo adds f to the "to" field.
func (m *SplitMutation) AddTo(f float64) {
	if m.addto != nil {
		*m.addto += f
	} else {
		m.addto = &f
	}
}

// AddedTo returns the value that was added to the "to" field in this mutation.
func (m *SplitMutation) AddedTo() (r float64, exists bool) {
	v := m.addto
	if v == nil {
		return
	}
	return *v, true
}

// ResetTo resets all changes to the "to" field.
func (m *SplitMutation) ResetTo() {
	m.to = nil
	m.addto = nil
}

// SetStockID sets the "stock" edge to the Entity entity by id.
func (m *SplitMutation) SetStockID(id int) {
	m.stock = &id
}

// ClearStock clears the "stock" edge to the Entity entity.
func (m *SplitMutation) ClearStock() {
	m.clearedstock = true
}

// StockCleared reports if the "stock" edge to the Entity entity was cleared.
func (m *SplitMutation) StockCleared() bool {
	return m.clearedstock
}

// StockID returns the "stock" edge ID in the mutation.
func (m *SplitMutation) StockID() (id int, exists bool) {
	if m.stock != nil {
		return *m.stock, true
	}
	return
}

// StockIDs returns the "stock" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StockID instead. It exists only for internal usage by the builders.
func (m *SplitMutation) StockIDs() (ids []int) {
	if id := m.stock; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStock resets all changes to the "stock" edge.
func (m *SplitMutation) ResetStock() {
	m.stock = nil
	m.clearedstock = false
}

// Where appends a list predicates to the SplitMutation builder.
func (m *SplitMutation) Where(ps ...predicate.Split) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SplitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SplitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Split, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SplitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SplitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Split).
func (m *SplitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SplitMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.execution_date != nil {
		fields = append(fields, split.FieldExecutionDate)
	}
	if m.from != nil {
		fields = append(fields, split.FieldFrom)
	}
	if m.to != nil {
		fields = append(fields, split.FieldTo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SplitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case split.FieldExecutionDate:
		return m.ExecutionDate()
	case split.FieldFrom:
		return m.From()
	case split.FieldTo:
		return m.To()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SplitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case split.FieldExecutionDate:
		return m.OldExecutionDate(ctx)
	case split.FieldFrom:
		return m.OldFrom(ctx)
	case split.FieldTo:
		return m.OldTo(ctx)
	}
	return nil, fmt.Errorf("unknown Split field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SplitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case split.FieldExecutionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionDate(v)
		return nil
	case split.FieldFrom:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrom(v)
		return nil
	case split.FieldTo:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTo(v)
		return nil
	}
	return fmt.Errorf("unknown Split field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SplitMutation) AddedFields() []string {
	var fields []string
	if m.addfrom != nil {
		fields = append(fields, split.FieldFrom)
	}
	if m.addto != nil {
		fields = append(fields, split.FieldTo)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SplitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case split.FieldFrom:
		return m.AddedFrom()
	case split.FieldTo:
		return m.AddedTo()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SplitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case split.FieldFrom:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrom(v)
		return nil
	case split.FieldTo:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTo(v)
		return nil
	}
	return fmt.Errorf("unknown Split numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SplitMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SplitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SplitMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Split nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SplitMutation) ResetField(name string) error {
	switch name {
	case split.FieldExecutionDate:
		m.ResetExecutionDate()
		return nil
	case split.FieldFrom:
		m.ResetFrom()
		return nil
	case split.FieldTo:
		m.ResetTo()
		return nil
	}
	return fmt.Errorf("unknown Split field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SplitMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.stock != nil {
		edges = append(edges, split.EdgeStock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SplitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case split.EdgeStock:
		if id := m.stock; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SplitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SplitMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SplitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstock {
		edges = append(edges, split.EdgeStock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SplitMutation) EdgeCleared(name string) bool {
	switch name {
	case split.EdgeStock:
		return m.clearedstock
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SplitMutation) ClearEdge(name string) error {
	switch name {
	case split.EdgeStock:
		m.ClearStock()
		return nil
	}
	return fmt.Errorf("unknown Split unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SplitMutation) ResetEdge(name string) error {
	switch name {
	case split.EdgeStock:
		m.ResetStock()
		return nil
	}
	return fmt.Errorf("unknown Split edge %s", name)
}

// TradeConditionMutation represents an operation that mutates the TradeCondition nodes in the graph.
type TradeConditionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	condition     *string
	clearedFields map[string]struct{}
	record        map[int]struct{}
	removedrecord map[int]struct{}
	clearedrecord bool
	done          bool
	oldValue      func(context.Context) (*TradeCondition, error)
	predicates    []predicate.TradeCondition
}

var _ ent.Mutation = (*TradeConditionMutation)(nil)

// tradeconditionOption allows management of the mutation configuration using functional options.
type tradeconditionOption func(*TradeConditionMutation)

// newTradeConditionMutation creates new mutation for the TradeCondition entity.
func newTradeConditionMutation(c config, op Op, opts ...tradeconditionOption) *TradeConditionMutation {
	m := &TradeConditionMutation{
		config:        c,
		op:            op,
		typ:           TypeTradeCondition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTradeConditionID sets the ID field of the mutation.
func withTradeConditionID(id int) tradeconditionOption {
	return func(m *TradeConditionMutation) {
		var (
			err   error
			once  sync.Once
			value *TradeCondition
		)
		m.oldValue = func(ctx context.Context) (*TradeCondition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TradeCondition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTradeCondition sets the old TradeCondition of the mutation.
func withTradeCondition(node *TradeCondition) tradeconditionOption {
	return func(m *TradeConditionMutation) {
		m.oldValue = func(context.Context) (*TradeCondition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TradeConditionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TradeConditionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TradeConditionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TradeConditionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TradeCondition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCondition sets the "condition" field.
func (m *TradeConditionMutation) SetCondition(s string) {
	m.condition = &s
}

// Condition returns the value of the "condition" field in the mutation.
func (m *TradeConditionMutation) Condition() (r string, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the TradeCondition entity.
// If the TradeCondition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeConditionMutation) OldCondition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// ResetCondition resets all changes to the "condition" field.
func (m *TradeConditionMutation) ResetCondition() {
	m.condition = nil
}

// AddRecordIDs adds the "record" edge to the TradeRecord entity by ids.
func (m *TradeConditionMutation) AddRecordIDs(ids ...int) {
	if m.record == nil {
		m.record = make(map[int]struct{})
	}
	for i := range ids {
		m.record[ids[i]] = struct{}{}
	}
}

// ClearRecord clears the "record" edge to the TradeRecord entity.
func (m *TradeConditionMutation) ClearRecord() {
	m.clearedrecord = true
}

// RecordCleared reports if the "record" edge to the TradeRecord entity was cleared.
func (m *TradeConditionMutation) RecordCleared() bool {
	return m.clearedrecord
}

// RemoveRecordIDs removes the "record" edge to the TradeRecord entity by IDs.
func (m *TradeConditionMutation) RemoveRecordIDs(ids ...int) {
	if m.removedrecord == nil {
		m.removedrecord = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.record, ids[i])
		m.removedrecord[ids[i]] = struct{}{}
	}
}

// RemovedRecord returns the removed IDs of the "record" edge to the TradeRecord entity.
func (m *TradeConditionMutation) RemovedRecordIDs() (ids []int) {
	for id := range m.removedrecord {
		ids = append(ids, id)
	}
	return
}

// RecordIDs returns the "record" edge IDs in the mutation.
func (m *TradeConditionMutation) RecordIDs() (ids []int) {
	for id := range m.record {
		ids = append(ids, id)
	}
	return
}

// ResetRecord resets all changes to the "record" edge.
func (m *TradeConditionMutation) ResetRecord() {
	m.record = nil
	m.clearedrecord = false
	m.removedrecord = nil
}

// Where appends a list predicates to the TradeConditionMutation builder.
func (m *TradeConditionMutation) Where(ps ...predicate.TradeCondition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TradeConditionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TradeConditionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TradeCondition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TradeConditionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TradeConditionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TradeCondition).
func (m *TradeConditionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TradeConditionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.condition != nil {
		fields = append(fields, tradecondition.FieldCondition)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TradeConditionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tradecondition.FieldCondition:
		return m.Condition()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TradeConditionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tradecondition.FieldCondition:
		return m.OldCondition(ctx)
	}
	return nil, fmt.Errorf("unknown TradeCondition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TradeConditionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tradecondition.FieldCondition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	}
	return fmt.Errorf("unknown TradeCondition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TradeConditionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TradeConditionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TradeConditionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TradeCondition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TradeConditionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TradeConditionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TradeConditionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TradeCondition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TradeConditionMutation) ResetField(name string) error {
	switch name {
	case tradecondition.FieldCondition:
		m.ResetCondition()
		return nil
	}
	return fmt.Errorf("unknown TradeCondition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TradeConditionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.record != nil {
		edges = append(edges, tradecondition.EdgeRecord)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TradeConditionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tradecondition.EdgeRecord:
		ids := make([]ent.Value, 0, len(m.record))
		for id := range m.record {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TradeConditionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrecord != nil {
		edges = append(edges, tradecondition.EdgeRecord)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TradeConditionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tradecondition.EdgeRecord:
		ids := make([]ent.Value, 0, len(m.removedrecord))
		for id := range m.removedrecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TradeConditionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrecord {
		edges = append(edges, tradecondition.EdgeRecord)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TradeConditionMutation) EdgeCleared(name string) bool {
	switch name {
	case tradecondition.EdgeRecord:
		return m.clearedrecord
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TradeConditionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TradeCondition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TradeConditionMutation) ResetEdge(name string) error {
	switch name {
	case tradecondition.EdgeRecord:
		m.ResetRecord()
		return nil
	}
	return fmt.Errorf("unknown TradeCondition edge %s", name)
}

// TradeCorrectionMutation represents an operation that mutates the TradeCorrection nodes in the graph.
type TradeCorrectionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	correction    *string
	clearedFields map[string]struct{}
	record        map[int]struct{}
	removedrecord map[int]struct{}
	clearedrecord bool
	done          bool
	oldValue      func(context.Context) (*TradeCorrection, error)
	predicates    []predicate.TradeCorrection
}

var _ ent.Mutation = (*TradeCorrectionMutation)(nil)

// tradecorrectionOption allows management of the mutation configuration using functional options.
type tradecorrectionOption func(*TradeCorrectionMutation)

// newTradeCorrectionMutation creates new mutation for the TradeCorrection entity.
func newTradeCorrectionMutation(c config, op Op, opts ...tradecorrectionOption) *TradeCorrectionMutation {
	m := &TradeCorrectionMutation{
		config:        c,
		op:            op,
		typ:           TypeTradeCorrection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTradeCorrectionID sets the ID field of the mutation.
func withTradeCorrectionID(id int) tradecorrectionOption {
	return func(m *TradeCorrectionMutation) {
		var (
			err   error
			once  sync.Once
			value *TradeCorrection
		)
		m.oldValue = func(ctx context.Context) (*TradeCorrection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TradeCorrection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTradeCorrection sets the old TradeCorrection of the mutation.
func withTradeCorrection(node *TradeCorrection) tradecorrectionOption {
	return func(m *TradeCorrectionMutation) {
		m.oldValue = func(context.Context) (*TradeCorrection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TradeCorrectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TradeCorrectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TradeCorrectionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TradeCorrectionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TradeCorrection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCorrection sets the "correction" field.
func (m *TradeCorrectionMutation) SetCorrection(s string) {
	m.correction = &s
}

// Correction returns the value of the "correction" field in the mutation.
func (m *TradeCorrectionMutation) Correction() (r string, exists bool) {
	v := m.correction
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrection returns the old "correction" field's value of the TradeCorrection entity.
// If the TradeCorrection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeCorrectionMutation) OldCorrection(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrection: %w", err)
	}
	return oldValue.Correction, nil
}

// ResetCorrection resets all changes to the "correction" field.
func (m *TradeCorrectionMutation) ResetCorrection() {
	m.correction = nil
}

// AddRecordIDs adds the "record" edge to the TradeRecord entity by ids.
func (m *TradeCorrectionMutation) AddRecordIDs(ids ...int) {
	if m.record == nil {
		m.record = make(map[int]struct{})
	}
	for i := range ids {
		m.record[ids[i]] = struct{}{}
	}
}

// ClearRecord clears the "record" edge to the TradeRecord entity.
func (m *TradeCorrectionMutation) ClearRecord() {
	m.clearedrecord = true
}

// RecordCleared reports if the "record" edge to the TradeRecord entity was cleared.
func (m *TradeCorrectionMutation) RecordCleared() bool {
	return m.clearedrecord
}

// RemoveRecordIDs removes the "record" edge to the TradeRecord entity by IDs.
func (m *TradeCorrectionMutation) RemoveRecordIDs(ids ...int) {
	if m.removedrecord == nil {
		m.removedrecord = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.record, ids[i])
		m.removedrecord[ids[i]] = struct{}{}
	}
}

// RemovedRecord returns the removed IDs of the "record" edge to the TradeRecord entity.
func (m *TradeCorrectionMutation) RemovedRecordIDs() (ids []int) {
	for id := range m.removedrecord {
		ids = append(ids, id)
	}
	return
}

// RecordIDs returns the "record" edge IDs in the mutation.
func (m *TradeCorrectionMutation) RecordIDs() (ids []int) {
	for id := range m.record {
		ids = append(ids, id)
	}
	return
}

// ResetRecord resets all changes to the "record" edge.
func (m *TradeCorrectionMutation) ResetRecord() {
	m.record = nil
	m.clearedrecord = false
	m.removedrecord = nil
}

// Where appends a list predicates to the TradeCorrectionMutation builder.
func (m *TradeCorrectionMutation) Where(ps ...predicate.TradeCorrection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TradeCorrectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TradeCorrectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TradeCorrection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TradeCorrectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TradeCorrectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TradeCorrection).
func (m *TradeCorrectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TradeCorrectionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.correction != nil {
		fields = append(fields, tradecorrection.FieldCorrection)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TradeCorrectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tradecorrection.FieldCorrection:
		return m.Correction()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TradeCorrectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tradecorrection.FieldCorrection:
		return m.OldCorrection(ctx)
	}
	return nil, fmt.Errorf("unknown TradeCorrection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TradeCorrectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tradecorrection.FieldCorrection:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrection(v)
		return nil
	}
	return fmt.Errorf("unknown TradeCorrection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TradeCorrectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TradeCorrectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TradeCorrectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TradeCorrection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TradeCorrectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TradeCorrectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TradeCorrectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TradeCorrection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TradeCorrectionMutation) ResetField(name string) error {
	switch name {
	case tradecorrection.FieldCorrection:
		m.ResetCorrection()
		return nil
	}
	return fmt.Errorf("unknown TradeCorrection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TradeCorrectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.record != nil {
		edges = append(edges, tradecorrection.EdgeRecord)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TradeCorrectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tradecorrection.EdgeRecord:
		ids := make([]ent.Value, 0, len(m.record))
		for id := range m.record {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TradeCorrectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrecord != nil {
		edges = append(edges, tradecorrection.EdgeRecord)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TradeCorrectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tradecorrection.EdgeRecord:
		ids := make([]ent.Value, 0, len(m.removedrecord))
		for id := range m.removedrecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TradeCorrectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrecord {
		edges = append(edges, tradecorrection.EdgeRecord)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TradeCorrectionMutation) EdgeCleared(name string) bool {
	switch name {
	case tradecorrection.EdgeRecord:
		return m.clearedrecord
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TradeCorrectionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TradeCorrection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TradeCorrectionMutation) ResetEdge(name string) error {
	switch name {
	case tradecorrection.EdgeRecord:
		m.ResetRecord()
		return nil
	}
	return fmt.Errorf("unknown TradeCorrection edge %s", name)
}

// TradeRecordMutation represents an operation that mutates the TradeRecord nodes in the graph.
type TradeRecordMutation struct {
	config
	op                Op
	typ               string
	id                *int
	price             *float64
	addprice          *float64
	timestamp         *time.Time
	volume            *int32
	addvolume         *int32
	clearedFields     map[string]struct{}
	time_range        *int
	clearedtime_range bool
	conditions        map[int]struct{}
	removedconditions map[int]struct{}
	clearedconditions bool
	correction        map[int]struct{}
	removedcorrection map[int]struct{}
	clearedcorrection bool
	exchange          map[int]struct{}
	removedexchange   map[int]struct{}
	clearedexchange   bool
	done              bool
	oldValue          func(context.Context) (*TradeRecord, error)
	predicates        []predicate.TradeRecord
}

var _ ent.Mutation = (*TradeRecordMutation)(nil)

// traderecordOption allows management of the mutation configuration using functional options.
type traderecordOption func(*TradeRecordMutation)

// newTradeRecordMutation creates new mutation for the TradeRecord entity.
func newTradeRecordMutation(c config, op Op, opts ...traderecordOption) *TradeRecordMutation {
	m := &TradeRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeTradeRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTradeRecordID sets the ID field of the mutation.
func withTradeRecordID(id int) traderecordOption {
	return func(m *TradeRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *TradeRecord
		)
		m.oldValue = func(ctx context.Context) (*TradeRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TradeRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTradeRecord sets the old TradeRecord of the mutation.
func withTradeRecord(node *TradeRecord) traderecordOption {
	return func(m *TradeRecordMutation) {
		m.oldValue = func(context.Context) (*TradeRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TradeRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TradeRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TradeRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TradeRecordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TradeRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPrice sets the "price" field.
func (m *TradeRecordMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *TradeRecordMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the TradeRecord entity.
// If the TradeRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeRecordMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *TradeRecordMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *TradeRecordMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *TradeRecordMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *TradeRecordMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *TradeRecordMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the TradeRecord entity.
// If the TradeRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeRecordMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *TradeRecordMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetVolume sets the "volume" field.
func (m *TradeRecordMutation) SetVolume(i int32) {
	m.volume = &i
	m.addvolume = nil
}

// Volume returns the value of the "volume" field in the mutation.
func (m *TradeRecordMutation) Volume() (r int32, exists bool) {
	v := m.volume
	if v == nil {
		return
	}
	return *v, true
}

// OldVolume returns the old "volume" field's value of the TradeRecord entity.
// If the TradeRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeRecordMutation) OldVolume(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolume is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolume requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolume: %w", err)
	}
	return oldValue.Volume, nil
}

// AddVolume adds i to the "volume" field.
func (m *TradeRecordMutation) AddVolume(i int32) {
	if m.addvolume != nil {
		*m.addvolume += i
	} else {
		m.addvolume = &i
	}
}

// AddedVolume returns the value that was added to the "volume" field in this mutation.
func (m *TradeRecordMutation) AddedVolume() (r int32, exists bool) {
	v := m.addvolume
	if v == nil {
		return
	}
	return *v, true
}

// ResetVolume resets all changes to the "volume" field.
func (m *TradeRecordMutation) ResetVolume() {
	m.volume = nil
	m.addvolume = nil
}

// SetTimeRangeID sets the "time_range_id" field.
func (m *TradeRecordMutation) SetTimeRangeID(i int) {
	m.time_range = &i
}

// TimeRangeID returns the value of the "time_range_id" field in the mutation.
func (m *TradeRecordMutation) TimeRangeID() (r int, exists bool) {
	v := m.time_range
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeRangeID returns the old "time_range_id" field's value of the TradeRecord entity.
// If the TradeRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeRecordMutation) OldTimeRangeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeRangeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeRangeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeRangeID: %w", err)
	}
	return oldValue.TimeRangeID, nil
}

// ResetTimeRangeID resets all changes to the "time_range_id" field.
func (m *TradeRecordMutation) ResetTimeRangeID() {
	m.time_range = nil
}

// ClearTimeRange clears the "time_range" edge to the TradeTimeRange entity.
func (m *TradeRecordMutation) ClearTimeRange() {
	m.clearedtime_range = true
	m.clearedFields[traderecord.FieldTimeRangeID] = struct{}{}
}

// TimeRangeCleared reports if the "time_range" edge to the TradeTimeRange entity was cleared.
func (m *TradeRecordMutation) TimeRangeCleared() bool {
	return m.clearedtime_range
}

// TimeRangeIDs returns the "time_range" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TimeRangeID instead. It exists only for internal usage by the builders.
func (m *TradeRecordMutation) TimeRangeIDs() (ids []int) {
	if id := m.time_range; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTimeRange resets all changes to the "time_range" edge.
func (m *TradeRecordMutation) ResetTimeRange() {
	m.time_range = nil
	m.clearedtime_range = false
}

// AddConditionIDs adds the "conditions" edge to the TradeCondition entity by ids.
func (m *TradeRecordMutation) AddConditionIDs(ids ...int) {
	if m.conditions == nil {
		m.conditions = make(map[int]struct{})
	}
	for i := range ids {
		m.conditions[ids[i]] = struct{}{}
	}
}

// ClearConditions clears the "conditions" edge to the TradeCondition entity.
func (m *TradeRecordMutation) ClearConditions() {
	m.clearedconditions = true
}

// ConditionsCleared reports if the "conditions" edge to the TradeCondition entity was cleared.
func (m *TradeRecordMutation) ConditionsCleared() bool {
	return m.clearedconditions
}

// RemoveConditionIDs removes the "conditions" edge to the TradeCondition entity by IDs.
func (m *TradeRecordMutation) RemoveConditionIDs(ids ...int) {
	if m.removedconditions == nil {
		m.removedconditions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.conditions, ids[i])
		m.removedconditions[ids[i]] = struct{}{}
	}
}

// RemovedConditions returns the removed IDs of the "conditions" edge to the TradeCondition entity.
func (m *TradeRecordMutation) RemovedConditionsIDs() (ids []int) {
	for id := range m.removedconditions {
		ids = append(ids, id)
	}
	return
}

// ConditionsIDs returns the "conditions" edge IDs in the mutation.
func (m *TradeRecordMutation) ConditionsIDs() (ids []int) {
	for id := range m.conditions {
		ids = append(ids, id)
	}
	return
}

// ResetConditions resets all changes to the "conditions" edge.
func (m *TradeRecordMutation) ResetConditions() {
	m.conditions = nil
	m.clearedconditions = false
	m.removedconditions = nil
}

// AddCorrectionIDs adds the "correction" edge to the TradeCorrection entity by ids.
func (m *TradeRecordMutation) AddCorrectionIDs(ids ...int) {
	if m.correction == nil {
		m.correction = make(map[int]struct{})
	}
	for i := range ids {
		m.correction[ids[i]] = struct{}{}
	}
}

// ClearCorrection clears the "correction" edge to the TradeCorrection entity.
func (m *TradeRecordMutation) ClearCorrection() {
	m.clearedcorrection = true
}

// CorrectionCleared reports if the "correction" edge to the TradeCorrection entity was cleared.
func (m *TradeRecordMutation) CorrectionCleared() bool {
	return m.clearedcorrection
}

// RemoveCorrectionIDs removes the "correction" edge to the TradeCorrection entity by IDs.
func (m *TradeRecordMutation) RemoveCorrectionIDs(ids ...int) {
	if m.removedcorrection == nil {
		m.removedcorrection = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.correction, ids[i])
		m.removedcorrection[ids[i]] = struct{}{}
	}
}

// RemovedCorrection returns the removed IDs of the "correction" edge to the TradeCorrection entity.
func (m *TradeRecordMutation) RemovedCorrectionIDs() (ids []int) {
	for id := range m.removedcorrection {
		ids = append(ids, id)
	}
	return
}

// CorrectionIDs returns the "correction" edge IDs in the mutation.
func (m *TradeRecordMutation) CorrectionIDs() (ids []int) {
	for id := range m.correction {
		ids = append(ids, id)
	}
	return
}

// ResetCorrection resets all changes to the "correction" edge.
func (m *TradeRecordMutation) ResetCorrection() {
	m.correction = nil
	m.clearedcorrection = false
	m.removedcorrection = nil
}

// AddExchangeIDs adds the "exchange" edge to the Exchange entity by ids.
func (m *TradeRecordMutation) AddExchangeIDs(ids ...int) {
	if m.exchange == nil {
		m.exchange = make(map[int]struct{})
	}
	for i := range ids {
		m.exchange[ids[i]] = struct{}{}
	}
}

// ClearExchange clears the "exchange" edge to the Exchange entity.
func (m *TradeRecordMutation) ClearExchange() {
	m.clearedexchange = true
}

// ExchangeCleared reports if the "exchange" edge to the Exchange entity was cleared.
func (m *TradeRecordMutation) ExchangeCleared() bool {
	return m.clearedexchange
}

// RemoveExchangeIDs removes the "exchange" edge to the Exchange entity by IDs.
func (m *TradeRecordMutation) RemoveExchangeIDs(ids ...int) {
	if m.removedexchange == nil {
		m.removedexchange = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.exchange, ids[i])
		m.removedexchange[ids[i]] = struct{}{}
	}
}

// RemovedExchange returns the removed IDs of the "exchange" edge to the Exchange entity.
func (m *TradeRecordMutation) RemovedExchangeIDs() (ids []int) {
	for id := range m.removedexchange {
		ids = append(ids, id)
	}
	return
}

// ExchangeIDs returns the "exchange" edge IDs in the mutation.
func (m *TradeRecordMutation) ExchangeIDs() (ids []int) {
	for id := range m.exchange {
		ids = append(ids, id)
	}
	return
}

// ResetExchange resets all changes to the "exchange" edge.
func (m *TradeRecordMutation) ResetExchange() {
	m.exchange = nil
	m.clearedexchange = false
	m.removedexchange = nil
}

// Where appends a list predicates to the TradeRecordMutation builder.
func (m *TradeRecordMutation) Where(ps ...predicate.TradeRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TradeRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TradeRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TradeRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TradeRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TradeRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TradeRecord).
func (m *TradeRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TradeRecordMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.price != nil {
		fields = append(fields, traderecord.FieldPrice)
	}
	if m.timestamp != nil {
		fields = append(fields, traderecord.FieldTimestamp)
	}
	if m.volume != nil {
		fields = append(fields, traderecord.FieldVolume)
	}
	if m.time_range != nil {
		fields = append(fields, traderecord.FieldTimeRangeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TradeRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case traderecord.FieldPrice:
		return m.Price()
	case traderecord.FieldTimestamp:
		return m.Timestamp()
	case traderecord.FieldVolume:
		return m.Volume()
	case traderecord.FieldTimeRangeID:
		return m.TimeRangeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TradeRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case traderecord.FieldPrice:
		return m.OldPrice(ctx)
	case traderecord.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case traderecord.FieldVolume:
		return m.OldVolume(ctx)
	case traderecord.FieldTimeRangeID:
		return m.OldTimeRangeID(ctx)
	}
	return nil, fmt.Errorf("unknown TradeRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TradeRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case traderecord.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case traderecord.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case traderecord.FieldVolume:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolume(v)
		return nil
	case traderecord.FieldTimeRangeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeRangeID(v)
		return nil
	}
	return fmt.Errorf("unknown TradeRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TradeRecordMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, traderecord.FieldPrice)
	}
	if m.addvolume != nil {
		fields = append(fields, traderecord.FieldVolume)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TradeRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case traderecord.FieldPrice:
		return m.AddedPrice()
	case traderecord.FieldVolume:
		return m.AddedVolume()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TradeRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case traderecord.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case traderecord.FieldVolume:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVolume(v)
		return nil
	}
	return fmt.Errorf("unknown TradeRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TradeRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TradeRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TradeRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TradeRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TradeRecordMutation) ResetField(name string) error {
	switch name {
	case traderecord.FieldPrice:
		m.ResetPrice()
		return nil
	case traderecord.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case traderecord.FieldVolume:
		m.ResetVolume()
		return nil
	case traderecord.FieldTimeRangeID:
		m.ResetTimeRangeID()
		return nil
	}
	return fmt.Errorf("unknown TradeRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TradeRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.time_range != nil {
		edges = append(edges, traderecord.EdgeTimeRange)
	}
	if m.conditions != nil {
		edges = append(edges, traderecord.EdgeConditions)
	}
	if m.correction != nil {
		edges = append(edges, traderecord.EdgeCorrection)
	}
	if m.exchange != nil {
		edges = append(edges, traderecord.EdgeExchange)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TradeRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case traderecord.EdgeTimeRange:
		if id := m.time_range; id != nil {
			return []ent.Value{*id}
		}
	case traderecord.EdgeConditions:
		ids := make([]ent.Value, 0, len(m.conditions))
		for id := range m.conditions {
			ids = append(ids, id)
		}
		return ids
	case traderecord.EdgeCorrection:
		ids := make([]ent.Value, 0, len(m.correction))
		for id := range m.correction {
			ids = append(ids, id)
		}
		return ids
	case traderecord.EdgeExchange:
		ids := make([]ent.Value, 0, len(m.exchange))
		for id := range m.exchange {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TradeRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedconditions != nil {
		edges = append(edges, traderecord.EdgeConditions)
	}
	if m.removedcorrection != nil {
		edges = append(edges, traderecord.EdgeCorrection)
	}
	if m.removedexchange != nil {
		edges = append(edges, traderecord.EdgeExchange)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TradeRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case traderecord.EdgeConditions:
		ids := make([]ent.Value, 0, len(m.removedconditions))
		for id := range m.removedconditions {
			ids = append(ids, id)
		}
		return ids
	case traderecord.EdgeCorrection:
		ids := make([]ent.Value, 0, len(m.removedcorrection))
		for id := range m.removedcorrection {
			ids = append(ids, id)
		}
		return ids
	case traderecord.EdgeExchange:
		ids := make([]ent.Value, 0, len(m.removedexchange))
		for id := range m.removedexchange {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TradeRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtime_range {
		edges = append(edges, traderecord.EdgeTimeRange)
	}
	if m.clearedconditions {
		edges = append(edges, traderecord.EdgeConditions)
	}
	if m.clearedcorrection {
		edges = append(edges, traderecord.EdgeCorrection)
	}
	if m.clearedexchange {
		edges = append(edges, traderecord.EdgeExchange)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TradeRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case traderecord.EdgeTimeRange:
		return m.clearedtime_range
	case traderecord.EdgeConditions:
		return m.clearedconditions
	case traderecord.EdgeCorrection:
		return m.clearedcorrection
	case traderecord.EdgeExchange:
		return m.clearedexchange
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TradeRecordMutation) ClearEdge(name string) error {
	switch name {
	case traderecord.EdgeTimeRange:
		m.ClearTimeRange()
		return nil
	}
	return fmt.Errorf("unknown TradeRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TradeRecordMutation) ResetEdge(name string) error {
	switch name {
	case traderecord.EdgeTimeRange:
		m.ResetTimeRange()
		return nil
	case traderecord.EdgeConditions:
		m.ResetConditions()
		return nil
	case traderecord.EdgeCorrection:
		m.ResetCorrection()
		return nil
	case traderecord.EdgeExchange:
		m.ResetExchange()
		return nil
	}
	return fmt.Errorf("unknown TradeRecord edge %s", name)
}

// TradeTimeRangeMutation represents an operation that mutates the TradeTimeRange nodes in the graph.
type TradeTimeRangeMutation struct {
	config
	op              Op
	typ             string
	id              *int
	start           *time.Time
	end             *time.Time
	clearedFields   map[string]struct{}
	interval        *int
	clearedinterval bool
	records         map[int]struct{}
	removedrecords  map[int]struct{}
	clearedrecords  bool
	done            bool
	oldValue        func(context.Context) (*TradeTimeRange, error)
	predicates      []predicate.TradeTimeRange
}

var _ ent.Mutation = (*TradeTimeRangeMutation)(nil)

// tradetimerangeOption allows management of the mutation configuration using functional options.
type tradetimerangeOption func(*TradeTimeRangeMutation)

// newTradeTimeRangeMutation creates new mutation for the TradeTimeRange entity.
func newTradeTimeRangeMutation(c config, op Op, opts ...tradetimerangeOption) *TradeTimeRangeMutation {
	m := &TradeTimeRangeMutation{
		config:        c,
		op:            op,
		typ:           TypeTradeTimeRange,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTradeTimeRangeID sets the ID field of the mutation.
func withTradeTimeRangeID(id int) tradetimerangeOption {
	return func(m *TradeTimeRangeMutation) {
		var (
			err   error
			once  sync.Once
			value *TradeTimeRange
		)
		m.oldValue = func(ctx context.Context) (*TradeTimeRange, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TradeTimeRange.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTradeTimeRange sets the old TradeTimeRange of the mutation.
func withTradeTimeRange(node *TradeTimeRange) tradetimerangeOption {
	return func(m *TradeTimeRangeMutation) {
		m.oldValue = func(context.Context) (*TradeTimeRange, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TradeTimeRangeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TradeTimeRangeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TradeTimeRangeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TradeTimeRangeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TradeTimeRange.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStart sets the "start" field.
func (m *TradeTimeRangeMutation) SetStart(t time.Time) {
	m.start = &t
}

// Start returns the value of the "start" field in the mutation.
func (m *TradeTimeRangeMutation) Start() (r time.Time, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the TradeTimeRange entity.
// If the TradeTimeRange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeTimeRangeMutation) OldStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// ResetStart resets all changes to the "start" field.
func (m *TradeTimeRangeMutation) ResetStart() {
	m.start = nil
}

// SetEnd sets the "end" field.
func (m *TradeTimeRangeMutation) SetEnd(t time.Time) {
	m.end = &t
}

// End returns the value of the "end" field in the mutation.
func (m *TradeTimeRangeMutation) End() (r time.Time, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the TradeTimeRange entity.
// If the TradeTimeRange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeTimeRangeMutation) OldEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// ResetEnd resets all changes to the "end" field.
func (m *TradeTimeRangeMutation) ResetEnd() {
	m.end = nil
}

// SetIntervalID sets the "interval_id" field.
func (m *TradeTimeRangeMutation) SetIntervalID(i int) {
	m.interval = &i
}

// IntervalID returns the value of the "interval_id" field in the mutation.
func (m *TradeTimeRangeMutation) IntervalID() (r int, exists bool) {
	v := m.interval
	if v == nil {
		return
	}
	return *v, true
}

// OldIntervalID returns the old "interval_id" field's value of the TradeTimeRange entity.
// If the TradeTimeRange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TradeTimeRangeMutation) OldIntervalID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntervalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntervalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntervalID: %w", err)
	}
	return oldValue.IntervalID, nil
}

// ResetIntervalID resets all changes to the "interval_id" field.
func (m *TradeTimeRangeMutation) ResetIntervalID() {
	m.interval = nil
}

// ClearInterval clears the "interval" edge to the Interval entity.
func (m *TradeTimeRangeMutation) ClearInterval() {
	m.clearedinterval = true
	m.clearedFields[tradetimerange.FieldIntervalID] = struct{}{}
}

// IntervalCleared reports if the "interval" edge to the Interval entity was cleared.
func (m *TradeTimeRangeMutation) IntervalCleared() bool {
	return m.clearedinterval
}

// IntervalIDs returns the "interval" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IntervalID instead. It exists only for internal usage by the builders.
func (m *TradeTimeRangeMutation) IntervalIDs() (ids []int) {
	if id := m.interval; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInterval resets all changes to the "interval" edge.
func (m *TradeTimeRangeMutation) ResetInterval() {
	m.interval = nil
	m.clearedinterval = false
}

// AddRecordIDs adds the "records" edge to the TradeRecord entity by ids.
func (m *TradeTimeRangeMutation) AddRecordIDs(ids ...int) {
	if m.records == nil {
		m.records = make(map[int]struct{})
	}
	for i := range ids {
		m.records[ids[i]] = struct{}{}
	}
}

// ClearRecords clears the "records" edge to the TradeRecord entity.
func (m *TradeTimeRangeMutation) ClearRecords() {
	m.clearedrecords = true
}

// RecordsCleared reports if the "records" edge to the TradeRecord entity was cleared.
func (m *TradeTimeRangeMutation) RecordsCleared() bool {
	return m.clearedrecords
}

// RemoveRecordIDs removes the "records" edge to the TradeRecord entity by IDs.
func (m *TradeTimeRangeMutation) RemoveRecordIDs(ids ...int) {
	if m.removedrecords == nil {
		m.removedrecords = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.records, ids[i])
		m.removedrecords[ids[i]] = struct{}{}
	}
}

// RemovedRecords returns the removed IDs of the "records" edge to the TradeRecord entity.
func (m *TradeTimeRangeMutation) RemovedRecordsIDs() (ids []int) {
	for id := range m.removedrecords {
		ids = append(ids, id)
	}
	return
}

// RecordsIDs returns the "records" edge IDs in the mutation.
func (m *TradeTimeRangeMutation) RecordsIDs() (ids []int) {
	for id := range m.records {
		ids = append(ids, id)
	}
	return
}

// ResetRecords resets all changes to the "records" edge.
func (m *TradeTimeRangeMutation) ResetRecords() {
	m.records = nil
	m.clearedrecords = false
	m.removedrecords = nil
}

// Where appends a list predicates to the TradeTimeRangeMutation builder.
func (m *TradeTimeRangeMutation) Where(ps ...predicate.TradeTimeRange) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TradeTimeRangeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TradeTimeRangeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TradeTimeRange, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TradeTimeRangeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TradeTimeRangeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TradeTimeRange).
func (m *TradeTimeRangeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TradeTimeRangeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.start != nil {
		fields = append(fields, tradetimerange.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, tradetimerange.FieldEnd)
	}
	if m.interval != nil {
		fields = append(fields, tradetimerange.FieldIntervalID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TradeTimeRangeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tradetimerange.FieldStart:
		return m.Start()
	case tradetimerange.FieldEnd:
		return m.End()
	case tradetimerange.FieldIntervalID:
		return m.IntervalID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TradeTimeRangeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tradetimerange.FieldStart:
		return m.OldStart(ctx)
	case tradetimerange.FieldEnd:
		return m.OldEnd(ctx)
	case tradetimerange.FieldIntervalID:
		return m.OldIntervalID(ctx)
	}
	return nil, fmt.Errorf("unknown TradeTimeRange field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TradeTimeRangeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tradetimerange.FieldStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case tradetimerange.FieldEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case tradetimerange.FieldIntervalID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntervalID(v)
		return nil
	}
	return fmt.Errorf("unknown TradeTimeRange field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TradeTimeRangeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TradeTimeRangeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TradeTimeRangeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TradeTimeRange numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TradeTimeRangeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TradeTimeRangeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TradeTimeRangeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TradeTimeRange nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TradeTimeRangeMutation) ResetField(name string) error {
	switch name {
	case tradetimerange.FieldStart:
		m.ResetStart()
		return nil
	case tradetimerange.FieldEnd:
		m.ResetEnd()
		return nil
	case tradetimerange.FieldIntervalID:
		m.ResetIntervalID()
		return nil
	}
	return fmt.Errorf("unknown TradeTimeRange field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TradeTimeRangeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.interval != nil {
		edges = append(edges, tradetimerange.EdgeInterval)
	}
	if m.records != nil {
		edges = append(edges, tradetimerange.EdgeRecords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TradeTimeRangeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tradetimerange.EdgeInterval:
		if id := m.interval; id != nil {
			return []ent.Value{*id}
		}
	case tradetimerange.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.records))
		for id := range m.records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TradeTimeRangeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrecords != nil {
		edges = append(edges, tradetimerange.EdgeRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TradeTimeRangeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tradetimerange.EdgeRecords:
		ids := make([]ent.Value, 0, len(m.removedrecords))
		for id := range m.removedrecords {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TradeTimeRangeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinterval {
		edges = append(edges, tradetimerange.EdgeInterval)
	}
	if m.clearedrecords {
		edges = append(edges, tradetimerange.EdgeRecords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TradeTimeRangeMutation) EdgeCleared(name string) bool {
	switch name {
	case tradetimerange.EdgeInterval:
		return m.clearedinterval
	case tradetimerange.EdgeRecords:
		return m.clearedrecords
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TradeTimeRangeMutation) ClearEdge(name string) error {
	switch name {
	case tradetimerange.EdgeInterval:
		m.ClearInterval()
		return nil
	}
	return fmt.Errorf("unknown TradeTimeRange unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TradeTimeRangeMutation) ResetEdge(name string) error {
	switch name {
	case tradetimerange.EdgeInterval:
		m.ResetInterval()
		return nil
	case tradetimerange.EdgeRecords:
		m.ResetRecords()
		return nil
	}
	return fmt.Errorf("unknown TradeTimeRange edge %s", name)
}
