// Code generated by ent, DO NOT EDIT.

package ogent

import (
	"context"
	"net/http"

	"github.com/go-faster/jx"
	"github.com/nathanhack/sibyl/ent"
	"github.com/nathanhack/sibyl/ent/bargroup"
	"github.com/nathanhack/sibyl/ent/barrecord"
	"github.com/nathanhack/sibyl/ent/bartimerange"
	"github.com/nathanhack/sibyl/ent/datasource"
	"github.com/nathanhack/sibyl/ent/dividend"
	"github.com/nathanhack/sibyl/ent/entity"
	"github.com/nathanhack/sibyl/ent/exchange"
	"github.com/nathanhack/sibyl/ent/financial"
	"github.com/nathanhack/sibyl/ent/interval"
	"github.com/nathanhack/sibyl/ent/markethours"
	"github.com/nathanhack/sibyl/ent/marketinfo"
	"github.com/nathanhack/sibyl/ent/split"
	"github.com/nathanhack/sibyl/ent/tradecondition"
	"github.com/nathanhack/sibyl/ent/tradecorrection"
	"github.com/nathanhack/sibyl/ent/traderecord"
	"github.com/nathanhack/sibyl/ent/tradetimerange"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *ent.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *ent.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

// CreateBarGroup handles POST /bar-groups requests.
func (h *OgentHandler) CreateBarGroup(ctx context.Context, req *CreateBarGroupReq) (CreateBarGroupRes, error) {
	b := h.client.BarGroup.Create()
	// Add all fields.
	b.SetFirst(req.First)
	b.SetLast(req.Last)
	b.SetCount(req.Count)
	b.SetTimeRangeID(req.TimeRangeID)
	// Add all edges.
	b.SetTimeRangeID(req.TimeRange)
	b.AddRecordIDs(req.Records...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.BarGroup.Query().Where(bargroup.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewBarGroupCreate(e), nil
}

// ReadBarGroup handles GET /bar-groups/{id} requests.
func (h *OgentHandler) ReadBarGroup(ctx context.Context, params ReadBarGroupParams) (ReadBarGroupRes, error) {
	q := h.client.BarGroup.Query().Where(bargroup.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewBarGroupRead(e), nil
}

// UpdateBarGroup handles PATCH /bar-groups/{id} requests.
func (h *OgentHandler) UpdateBarGroup(ctx context.Context, req *UpdateBarGroupReq, params UpdateBarGroupParams) (UpdateBarGroupRes, error) {
	b := h.client.BarGroup.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.First.Get(); ok {
		b.SetFirst(v)
	}
	if v, ok := req.Last.Get(); ok {
		b.SetLast(v)
	}
	if v, ok := req.Count.Get(); ok {
		b.SetCount(v)
	}
	if v, ok := req.TimeRangeID.Get(); ok {
		b.SetTimeRangeID(v)
	}
	// Add all edges.
	if v, ok := req.TimeRange.Get(); ok {
		b.SetTimeRangeID(v)
	}
	if req.Records != nil {
		b.ClearRecords().AddRecordIDs(req.Records...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.BarGroup.Query().Where(bargroup.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewBarGroupUpdate(e), nil
}

// DeleteBarGroup handles DELETE /bar-groups/{id} requests.
func (h *OgentHandler) DeleteBarGroup(ctx context.Context, params DeleteBarGroupParams) (DeleteBarGroupRes, error) {
	err := h.client.BarGroup.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteBarGroupNoContent), nil

}

// ListBarGroup handles GET /bar-groups requests.
func (h *OgentHandler) ListBarGroup(ctx context.Context, params ListBarGroupParams) (ListBarGroupRes, error) {
	q := h.client.BarGroup.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewBarGroupLists(es)
	return (*ListBarGroupOKApplicationJSON)(&r), nil
}

// ReadBarGroupTimeRange handles GET /bar-groups/{id}/time-range requests.
func (h *OgentHandler) ReadBarGroupTimeRange(ctx context.Context, params ReadBarGroupTimeRangeParams) (ReadBarGroupTimeRangeRes, error) {
	q := h.client.BarGroup.Query().Where(bargroup.IDEQ(params.ID)).QueryTimeRange()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewBarGroupTimeRangeRead(e), nil
}

// ListBarGroupRecords handles GET /bar-groups/{id}/records requests.
func (h *OgentHandler) ListBarGroupRecords(ctx context.Context, params ListBarGroupRecordsParams) (ListBarGroupRecordsRes, error) {
	q := h.client.BarGroup.Query().Where(bargroup.IDEQ(params.ID)).QueryRecords()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewBarGroupRecordsLists(es)
	return (*ListBarGroupRecordsOKApplicationJSON)(&r), nil
}

// CreateBarRecord handles POST /bar-records requests.
func (h *OgentHandler) CreateBarRecord(ctx context.Context, req *CreateBarRecordReq) (CreateBarRecordRes, error) {
	b := h.client.BarRecord.Create()
	// Add all fields.
	b.SetClose(req.Close)
	b.SetHigh(req.High)
	b.SetLow(req.Low)
	b.SetOpen(req.Open)
	b.SetTimestamp(req.Timestamp)
	b.SetVolume(req.Volume)
	b.SetTransactions(req.Transactions)
	// Add all edges.
	if v, ok := req.Group.Get(); ok {
		b.SetGroupID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.BarRecord.Query().Where(barrecord.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewBarRecordCreate(e), nil
}

// ReadBarRecord handles GET /bar-records/{id} requests.
func (h *OgentHandler) ReadBarRecord(ctx context.Context, params ReadBarRecordParams) (ReadBarRecordRes, error) {
	q := h.client.BarRecord.Query().Where(barrecord.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewBarRecordRead(e), nil
}

// UpdateBarRecord handles PATCH /bar-records/{id} requests.
func (h *OgentHandler) UpdateBarRecord(ctx context.Context, req *UpdateBarRecordReq, params UpdateBarRecordParams) (UpdateBarRecordRes, error) {
	b := h.client.BarRecord.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Close.Get(); ok {
		b.SetClose(v)
	}
	if v, ok := req.High.Get(); ok {
		b.SetHigh(v)
	}
	if v, ok := req.Low.Get(); ok {
		b.SetLow(v)
	}
	if v, ok := req.Open.Get(); ok {
		b.SetOpen(v)
	}
	if v, ok := req.Timestamp.Get(); ok {
		b.SetTimestamp(v)
	}
	if v, ok := req.Volume.Get(); ok {
		b.SetVolume(v)
	}
	if v, ok := req.Transactions.Get(); ok {
		b.SetTransactions(v)
	}
	// Add all edges.
	if v, ok := req.Group.Get(); ok {
		b.SetGroupID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.BarRecord.Query().Where(barrecord.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewBarRecordUpdate(e), nil
}

// DeleteBarRecord handles DELETE /bar-records/{id} requests.
func (h *OgentHandler) DeleteBarRecord(ctx context.Context, params DeleteBarRecordParams) (DeleteBarRecordRes, error) {
	err := h.client.BarRecord.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteBarRecordNoContent), nil

}

// ListBarRecord handles GET /bar-records requests.
func (h *OgentHandler) ListBarRecord(ctx context.Context, params ListBarRecordParams) (ListBarRecordRes, error) {
	q := h.client.BarRecord.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewBarRecordLists(es)
	return (*ListBarRecordOKApplicationJSON)(&r), nil
}

// ReadBarRecordGroup handles GET /bar-records/{id}/group requests.
func (h *OgentHandler) ReadBarRecordGroup(ctx context.Context, params ReadBarRecordGroupParams) (ReadBarRecordGroupRes, error) {
	q := h.client.BarRecord.Query().Where(barrecord.IDEQ(params.ID)).QueryGroup()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewBarRecordGroupRead(e), nil
}

// CreateBarTimeRange handles POST /bar-time-ranges requests.
func (h *OgentHandler) CreateBarTimeRange(ctx context.Context, req *CreateBarTimeRangeReq) (CreateBarTimeRangeRes, error) {
	b := h.client.BarTimeRange.Create()
	// Add all fields.
	b.SetStart(req.Start)
	b.SetEnd(req.End)
	b.SetCount(req.Count)
	b.SetIntervalID(req.IntervalID)
	b.SetStatus(bartimerange.Status(req.Status))
	b.SetUpdateTime(req.UpdateTime)
	// Add all edges.
	b.SetIntervalID(req.Interval)
	b.AddGroupIDs(req.Groups...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.BarTimeRange.Query().Where(bartimerange.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewBarTimeRangeCreate(e), nil
}

// ReadBarTimeRange handles GET /bar-time-ranges/{id} requests.
func (h *OgentHandler) ReadBarTimeRange(ctx context.Context, params ReadBarTimeRangeParams) (ReadBarTimeRangeRes, error) {
	q := h.client.BarTimeRange.Query().Where(bartimerange.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewBarTimeRangeRead(e), nil
}

// UpdateBarTimeRange handles PATCH /bar-time-ranges/{id} requests.
func (h *OgentHandler) UpdateBarTimeRange(ctx context.Context, req *UpdateBarTimeRangeReq, params UpdateBarTimeRangeParams) (UpdateBarTimeRangeRes, error) {
	b := h.client.BarTimeRange.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Start.Get(); ok {
		b.SetStart(v)
	}
	if v, ok := req.End.Get(); ok {
		b.SetEnd(v)
	}
	if v, ok := req.Count.Get(); ok {
		b.SetCount(v)
	}
	if v, ok := req.IntervalID.Get(); ok {
		b.SetIntervalID(v)
	}
	if v, ok := req.Status.Get(); ok {
		b.SetStatus(bartimerange.Status(v))
	}
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	// Add all edges.
	if v, ok := req.Interval.Get(); ok {
		b.SetIntervalID(v)
	}
	if req.Groups != nil {
		b.ClearGroups().AddGroupIDs(req.Groups...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.BarTimeRange.Query().Where(bartimerange.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewBarTimeRangeUpdate(e), nil
}

// DeleteBarTimeRange handles DELETE /bar-time-ranges/{id} requests.
func (h *OgentHandler) DeleteBarTimeRange(ctx context.Context, params DeleteBarTimeRangeParams) (DeleteBarTimeRangeRes, error) {
	err := h.client.BarTimeRange.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteBarTimeRangeNoContent), nil

}

// ListBarTimeRange handles GET /bar-time-ranges requests.
func (h *OgentHandler) ListBarTimeRange(ctx context.Context, params ListBarTimeRangeParams) (ListBarTimeRangeRes, error) {
	q := h.client.BarTimeRange.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewBarTimeRangeLists(es)
	return (*ListBarTimeRangeOKApplicationJSON)(&r), nil
}

// ReadBarTimeRangeInterval handles GET /bar-time-ranges/{id}/interval requests.
func (h *OgentHandler) ReadBarTimeRangeInterval(ctx context.Context, params ReadBarTimeRangeIntervalParams) (ReadBarTimeRangeIntervalRes, error) {
	q := h.client.BarTimeRange.Query().Where(bartimerange.IDEQ(params.ID)).QueryInterval()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewBarTimeRangeIntervalRead(e), nil
}

// ListBarTimeRangeGroups handles GET /bar-time-ranges/{id}/groups requests.
func (h *OgentHandler) ListBarTimeRangeGroups(ctx context.Context, params ListBarTimeRangeGroupsParams) (ListBarTimeRangeGroupsRes, error) {
	q := h.client.BarTimeRange.Query().Where(bartimerange.IDEQ(params.ID)).QueryGroups()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewBarTimeRangeGroupsLists(es)
	return (*ListBarTimeRangeGroupsOKApplicationJSON)(&r), nil
}

// CreateDataSource handles POST /data-sources requests.
func (h *OgentHandler) CreateDataSource(ctx context.Context, req *CreateDataSourceReq) (CreateDataSourceRes, error) {
	b := h.client.DataSource.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetAddress(req.Address)
	// Add all edges.
	b.AddIntervalIDs(req.Intervals...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.DataSource.Query().Where(datasource.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewDataSourceCreate(e), nil
}

// ReadDataSource handles GET /data-sources/{id} requests.
func (h *OgentHandler) ReadDataSource(ctx context.Context, params ReadDataSourceParams) (ReadDataSourceRes, error) {
	q := h.client.DataSource.Query().Where(datasource.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewDataSourceRead(e), nil
}

// UpdateDataSource handles PATCH /data-sources/{id} requests.
func (h *OgentHandler) UpdateDataSource(ctx context.Context, req *UpdateDataSourceReq, params UpdateDataSourceParams) (UpdateDataSourceRes, error) {
	b := h.client.DataSource.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Address.Get(); ok {
		b.SetAddress(v)
	}
	// Add all edges.
	if req.Intervals != nil {
		b.ClearIntervals().AddIntervalIDs(req.Intervals...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.DataSource.Query().Where(datasource.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewDataSourceUpdate(e), nil
}

// DeleteDataSource handles DELETE /data-sources/{id} requests.
func (h *OgentHandler) DeleteDataSource(ctx context.Context, params DeleteDataSourceParams) (DeleteDataSourceRes, error) {
	err := h.client.DataSource.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteDataSourceNoContent), nil

}

// ListDataSource handles GET /data-sources requests.
func (h *OgentHandler) ListDataSource(ctx context.Context, params ListDataSourceParams) (ListDataSourceRes, error) {
	q := h.client.DataSource.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewDataSourceLists(es)
	return (*ListDataSourceOKApplicationJSON)(&r), nil
}

// ListDataSourceIntervals handles GET /data-sources/{id}/intervals requests.
func (h *OgentHandler) ListDataSourceIntervals(ctx context.Context, params ListDataSourceIntervalsParams) (ListDataSourceIntervalsRes, error) {
	q := h.client.DataSource.Query().Where(datasource.IDEQ(params.ID)).QueryIntervals()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewDataSourceIntervalsLists(es)
	return (*ListDataSourceIntervalsOKApplicationJSON)(&r), nil
}

// CreateDividend handles POST /dividends requests.
func (h *OgentHandler) CreateDividend(ctx context.Context, req *CreateDividendReq) (CreateDividendRes, error) {
	b := h.client.Dividend.Create()
	// Add all fields.
	b.SetCashAmount(req.CashAmount)
	b.SetDeclarationDate(req.DeclarationDate)
	b.SetDividendType(dividend.DividendType(req.DividendType))
	b.SetExDividendDate(req.ExDividendDate)
	b.SetFrequency(req.Frequency)
	b.SetRecordDate(req.RecordDate)
	b.SetPayDate(req.PayDate)
	// Add all edges.
	b.AddStockIDs(req.Stock...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Dividend.Query().Where(dividend.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewDividendCreate(e), nil
}

// ReadDividend handles GET /dividends/{id} requests.
func (h *OgentHandler) ReadDividend(ctx context.Context, params ReadDividendParams) (ReadDividendRes, error) {
	q := h.client.Dividend.Query().Where(dividend.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewDividendRead(e), nil
}

// UpdateDividend handles PATCH /dividends/{id} requests.
func (h *OgentHandler) UpdateDividend(ctx context.Context, req *UpdateDividendReq, params UpdateDividendParams) (UpdateDividendRes, error) {
	b := h.client.Dividend.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.CashAmount.Get(); ok {
		b.SetCashAmount(v)
	}
	if v, ok := req.DeclarationDate.Get(); ok {
		b.SetDeclarationDate(v)
	}
	if v, ok := req.DividendType.Get(); ok {
		b.SetDividendType(dividend.DividendType(v))
	}
	if v, ok := req.ExDividendDate.Get(); ok {
		b.SetExDividendDate(v)
	}
	if v, ok := req.Frequency.Get(); ok {
		b.SetFrequency(v)
	}
	if v, ok := req.RecordDate.Get(); ok {
		b.SetRecordDate(v)
	}
	if v, ok := req.PayDate.Get(); ok {
		b.SetPayDate(v)
	}
	// Add all edges.
	if req.Stock != nil {
		b.ClearStock().AddStockIDs(req.Stock...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Dividend.Query().Where(dividend.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewDividendUpdate(e), nil
}

// DeleteDividend handles DELETE /dividends/{id} requests.
func (h *OgentHandler) DeleteDividend(ctx context.Context, params DeleteDividendParams) (DeleteDividendRes, error) {
	err := h.client.Dividend.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteDividendNoContent), nil

}

// ListDividend handles GET /dividends requests.
func (h *OgentHandler) ListDividend(ctx context.Context, params ListDividendParams) (ListDividendRes, error) {
	q := h.client.Dividend.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewDividendLists(es)
	return (*ListDividendOKApplicationJSON)(&r), nil
}

// ListDividendStock handles GET /dividends/{id}/stock requests.
func (h *OgentHandler) ListDividendStock(ctx context.Context, params ListDividendStockParams) (ListDividendStockRes, error) {
	q := h.client.Dividend.Query().Where(dividend.IDEQ(params.ID)).QueryStock()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewDividendStockLists(es)
	return (*ListDividendStockOKApplicationJSON)(&r), nil
}

// CreateEntity handles POST /entities requests.
func (h *OgentHandler) CreateEntity(ctx context.Context, req *CreateEntityReq) (CreateEntityRes, error) {
	b := h.client.Entity.Create()
	// Add all fields.
	b.SetActive(req.Active)
	b.SetTicker(req.Ticker)
	b.SetName(req.Name)
	b.SetDescription(req.Description)
	b.SetListDate(req.ListDate)
	if v, ok := req.Delisted.Get(); ok {
		b.SetDelisted(v)
	}
	// Add all edges.
	b.AddExchangeIDs(req.Exchanges...)
	b.AddIntervalIDs(req.Intervals...)
	b.AddDividendIDs(req.Dividends...)
	b.AddSplitIDs(req.Splits...)
	b.AddFinancialIDs(req.Financials...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Entity.Query().Where(entity.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewEntityCreate(e), nil
}

// ReadEntity handles GET /entities/{id} requests.
func (h *OgentHandler) ReadEntity(ctx context.Context, params ReadEntityParams) (ReadEntityRes, error) {
	q := h.client.Entity.Query().Where(entity.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewEntityRead(e), nil
}

// UpdateEntity handles PATCH /entities/{id} requests.
func (h *OgentHandler) UpdateEntity(ctx context.Context, req *UpdateEntityReq, params UpdateEntityParams) (UpdateEntityRes, error) {
	b := h.client.Entity.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Active.Get(); ok {
		b.SetActive(v)
	}
	if v, ok := req.Ticker.Get(); ok {
		b.SetTicker(v)
	}
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Description.Get(); ok {
		b.SetDescription(v)
	}
	if v, ok := req.ListDate.Get(); ok {
		b.SetListDate(v)
	}
	if v, ok := req.Delisted.Get(); ok {
		b.SetDelisted(v)
	}
	// Add all edges.
	if req.Exchanges != nil {
		b.ClearExchanges().AddExchangeIDs(req.Exchanges...)
	}
	if req.Intervals != nil {
		b.ClearIntervals().AddIntervalIDs(req.Intervals...)
	}
	if req.Dividends != nil {
		b.ClearDividends().AddDividendIDs(req.Dividends...)
	}
	if req.Splits != nil {
		b.ClearSplits().AddSplitIDs(req.Splits...)
	}
	if req.Financials != nil {
		b.ClearFinancials().AddFinancialIDs(req.Financials...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Entity.Query().Where(entity.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewEntityUpdate(e), nil
}

// DeleteEntity handles DELETE /entities/{id} requests.
func (h *OgentHandler) DeleteEntity(ctx context.Context, params DeleteEntityParams) (DeleteEntityRes, error) {
	err := h.client.Entity.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteEntityNoContent), nil

}

// ListEntity handles GET /entities requests.
func (h *OgentHandler) ListEntity(ctx context.Context, params ListEntityParams) (ListEntityRes, error) {
	q := h.client.Entity.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewEntityLists(es)
	return (*ListEntityOKApplicationJSON)(&r), nil
}

// ListEntityExchanges handles GET /entities/{id}/exchanges requests.
func (h *OgentHandler) ListEntityExchanges(ctx context.Context, params ListEntityExchangesParams) (ListEntityExchangesRes, error) {
	q := h.client.Entity.Query().Where(entity.IDEQ(params.ID)).QueryExchanges()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewEntityExchangesLists(es)
	return (*ListEntityExchangesOKApplicationJSON)(&r), nil
}

// ListEntityIntervals handles GET /entities/{id}/intervals requests.
func (h *OgentHandler) ListEntityIntervals(ctx context.Context, params ListEntityIntervalsParams) (ListEntityIntervalsRes, error) {
	q := h.client.Entity.Query().Where(entity.IDEQ(params.ID)).QueryIntervals()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewEntityIntervalsLists(es)
	return (*ListEntityIntervalsOKApplicationJSON)(&r), nil
}

// ListEntityDividends handles GET /entities/{id}/dividends requests.
func (h *OgentHandler) ListEntityDividends(ctx context.Context, params ListEntityDividendsParams) (ListEntityDividendsRes, error) {
	q := h.client.Entity.Query().Where(entity.IDEQ(params.ID)).QueryDividends()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewEntityDividendsLists(es)
	return (*ListEntityDividendsOKApplicationJSON)(&r), nil
}

// ListEntitySplits handles GET /entities/{id}/splits requests.
func (h *OgentHandler) ListEntitySplits(ctx context.Context, params ListEntitySplitsParams) (ListEntitySplitsRes, error) {
	q := h.client.Entity.Query().Where(entity.IDEQ(params.ID)).QuerySplits()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewEntitySplitsLists(es)
	return (*ListEntitySplitsOKApplicationJSON)(&r), nil
}

// ListEntityFinancials handles GET /entities/{id}/financials requests.
func (h *OgentHandler) ListEntityFinancials(ctx context.Context, params ListEntityFinancialsParams) (ListEntityFinancialsRes, error) {
	q := h.client.Entity.Query().Where(entity.IDEQ(params.ID)).QueryFinancials()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewEntityFinancialsLists(es)
	return (*ListEntityFinancialsOKApplicationJSON)(&r), nil
}

// CreateExchange handles POST /exchanges requests.
func (h *OgentHandler) CreateExchange(ctx context.Context, req *CreateExchangeReq) (CreateExchangeRes, error) {
	b := h.client.Exchange.Create()
	// Add all fields.
	b.SetCode(req.Code)
	b.SetName(req.Name)
	// Add all edges.
	b.AddStockIDs(req.Stocks...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Exchange.Query().Where(exchange.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewExchangeCreate(e), nil
}

// ReadExchange handles GET /exchanges/{id} requests.
func (h *OgentHandler) ReadExchange(ctx context.Context, params ReadExchangeParams) (ReadExchangeRes, error) {
	q := h.client.Exchange.Query().Where(exchange.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewExchangeRead(e), nil
}

// UpdateExchange handles PATCH /exchanges/{id} requests.
func (h *OgentHandler) UpdateExchange(ctx context.Context, req *UpdateExchangeReq, params UpdateExchangeParams) (UpdateExchangeRes, error) {
	b := h.client.Exchange.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Code.Get(); ok {
		b.SetCode(v)
	}
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	// Add all edges.
	if req.Stocks != nil {
		b.ClearStocks().AddStockIDs(req.Stocks...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Exchange.Query().Where(exchange.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewExchangeUpdate(e), nil
}

// DeleteExchange handles DELETE /exchanges/{id} requests.
func (h *OgentHandler) DeleteExchange(ctx context.Context, params DeleteExchangeParams) (DeleteExchangeRes, error) {
	err := h.client.Exchange.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteExchangeNoContent), nil

}

// ListExchange handles GET /exchanges requests.
func (h *OgentHandler) ListExchange(ctx context.Context, params ListExchangeParams) (ListExchangeRes, error) {
	q := h.client.Exchange.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewExchangeLists(es)
	return (*ListExchangeOKApplicationJSON)(&r), nil
}

// ListExchangeStocks handles GET /exchanges/{id}/stocks requests.
func (h *OgentHandler) ListExchangeStocks(ctx context.Context, params ListExchangeStocksParams) (ListExchangeStocksRes, error) {
	q := h.client.Exchange.Query().Where(exchange.IDEQ(params.ID)).QueryStocks()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewExchangeStocksLists(es)
	return (*ListExchangeStocksOKApplicationJSON)(&r), nil
}

// CreateFinancial handles POST /financials requests.
func (h *OgentHandler) CreateFinancial(ctx context.Context, req *CreateFinancialReq) (CreateFinancialRes, error) {
	b := h.client.Financial.Create()
	// Add all fields.
	// Add all edges.
	b.AddStockIDs(req.Stock...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Financial.Query().Where(financial.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewFinancialCreate(e), nil
}

// ReadFinancial handles GET /financials/{id} requests.
func (h *OgentHandler) ReadFinancial(ctx context.Context, params ReadFinancialParams) (ReadFinancialRes, error) {
	q := h.client.Financial.Query().Where(financial.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewFinancialRead(e), nil
}

// UpdateFinancial handles PATCH /financials/{id} requests.
func (h *OgentHandler) UpdateFinancial(ctx context.Context, req *UpdateFinancialReq, params UpdateFinancialParams) (UpdateFinancialRes, error) {
	b := h.client.Financial.UpdateOneID(params.ID)
	// Add all fields.
	// Add all edges.
	if req.Stock != nil {
		b.ClearStock().AddStockIDs(req.Stock...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Financial.Query().Where(financial.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewFinancialUpdate(e), nil
}

// DeleteFinancial handles DELETE /financials/{id} requests.
func (h *OgentHandler) DeleteFinancial(ctx context.Context, params DeleteFinancialParams) (DeleteFinancialRes, error) {
	err := h.client.Financial.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteFinancialNoContent), nil

}

// ListFinancial handles GET /financials requests.
func (h *OgentHandler) ListFinancial(ctx context.Context, params ListFinancialParams) (ListFinancialRes, error) {
	q := h.client.Financial.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewFinancialLists(es)
	return (*ListFinancialOKApplicationJSON)(&r), nil
}

// ListFinancialStock handles GET /financials/{id}/stock requests.
func (h *OgentHandler) ListFinancialStock(ctx context.Context, params ListFinancialStockParams) (ListFinancialStockRes, error) {
	q := h.client.Financial.Query().Where(financial.IDEQ(params.ID)).QueryStock()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewFinancialStockLists(es)
	return (*ListFinancialStockOKApplicationJSON)(&r), nil
}

// CreateInterval handles POST /intervals requests.
func (h *OgentHandler) CreateInterval(ctx context.Context, req *CreateIntervalReq) (CreateIntervalRes, error) {
	b := h.client.Interval.Create()
	// Add all fields.
	b.SetActive(req.Active)
	b.SetInterval(interval.Interval(req.Interval))
	b.SetStockID(req.StockID)
	b.SetDataSourceID(req.DataSourceID)
	// Add all edges.
	b.SetDataSourceID(req.DataSource)
	b.SetStockID(req.Stock)
	b.AddBarIDs(req.Bars...)
	b.AddTradeIDs(req.Trades...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Interval.Query().Where(interval.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewIntervalCreate(e), nil
}

// ReadInterval handles GET /intervals/{id} requests.
func (h *OgentHandler) ReadInterval(ctx context.Context, params ReadIntervalParams) (ReadIntervalRes, error) {
	q := h.client.Interval.Query().Where(interval.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewIntervalRead(e), nil
}

// UpdateInterval handles PATCH /intervals/{id} requests.
func (h *OgentHandler) UpdateInterval(ctx context.Context, req *UpdateIntervalReq, params UpdateIntervalParams) (UpdateIntervalRes, error) {
	b := h.client.Interval.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Active.Get(); ok {
		b.SetActive(v)
	}
	if v, ok := req.Interval.Get(); ok {
		b.SetInterval(interval.Interval(v))
	}
	if v, ok := req.StockID.Get(); ok {
		b.SetStockID(v)
	}
	if v, ok := req.DataSourceID.Get(); ok {
		b.SetDataSourceID(v)
	}
	// Add all edges.
	if v, ok := req.DataSource.Get(); ok {
		b.SetDataSourceID(v)
	}
	if v, ok := req.Stock.Get(); ok {
		b.SetStockID(v)
	}
	if req.Bars != nil {
		b.ClearBars().AddBarIDs(req.Bars...)
	}
	if req.Trades != nil {
		b.ClearTrades().AddTradeIDs(req.Trades...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Interval.Query().Where(interval.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewIntervalUpdate(e), nil
}

// DeleteInterval handles DELETE /intervals/{id} requests.
func (h *OgentHandler) DeleteInterval(ctx context.Context, params DeleteIntervalParams) (DeleteIntervalRes, error) {
	err := h.client.Interval.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteIntervalNoContent), nil

}

// ListInterval handles GET /intervals requests.
func (h *OgentHandler) ListInterval(ctx context.Context, params ListIntervalParams) (ListIntervalRes, error) {
	q := h.client.Interval.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewIntervalLists(es)
	return (*ListIntervalOKApplicationJSON)(&r), nil
}

// ReadIntervalDataSource handles GET /intervals/{id}/data-source requests.
func (h *OgentHandler) ReadIntervalDataSource(ctx context.Context, params ReadIntervalDataSourceParams) (ReadIntervalDataSourceRes, error) {
	q := h.client.Interval.Query().Where(interval.IDEQ(params.ID)).QueryDataSource()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewIntervalDataSourceRead(e), nil
}

// ReadIntervalStock handles GET /intervals/{id}/stock requests.
func (h *OgentHandler) ReadIntervalStock(ctx context.Context, params ReadIntervalStockParams) (ReadIntervalStockRes, error) {
	q := h.client.Interval.Query().Where(interval.IDEQ(params.ID)).QueryStock()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewIntervalStockRead(e), nil
}

// ListIntervalBars handles GET /intervals/{id}/bars requests.
func (h *OgentHandler) ListIntervalBars(ctx context.Context, params ListIntervalBarsParams) (ListIntervalBarsRes, error) {
	q := h.client.Interval.Query().Where(interval.IDEQ(params.ID)).QueryBars()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewIntervalBarsLists(es)
	return (*ListIntervalBarsOKApplicationJSON)(&r), nil
}

// ListIntervalTrades handles GET /intervals/{id}/trades requests.
func (h *OgentHandler) ListIntervalTrades(ctx context.Context, params ListIntervalTradesParams) (ListIntervalTradesRes, error) {
	q := h.client.Interval.Query().Where(interval.IDEQ(params.ID)).QueryTrades()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewIntervalTradesLists(es)
	return (*ListIntervalTradesOKApplicationJSON)(&r), nil
}

// CreateMarketHours handles POST /market-hours-slice requests.
func (h *OgentHandler) CreateMarketHours(ctx context.Context, req *CreateMarketHoursReq) (CreateMarketHoursRes, error) {
	b := h.client.MarketHours.Create()
	// Add all fields.
	b.SetDate(req.Date)
	b.SetStartTime(req.StartTime)
	b.SetEndTime(req.EndTime)
	// Add all edges.
	if v, ok := req.MarketInfo.Get(); ok {
		b.SetMarketInfoID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.MarketHours.Query().Where(markethours.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewMarketHoursCreate(e), nil
}

// ReadMarketHours handles GET /market-hours-slice/{id} requests.
func (h *OgentHandler) ReadMarketHours(ctx context.Context, params ReadMarketHoursParams) (ReadMarketHoursRes, error) {
	q := h.client.MarketHours.Query().Where(markethours.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewMarketHoursRead(e), nil
}

// UpdateMarketHours handles PATCH /market-hours-slice/{id} requests.
func (h *OgentHandler) UpdateMarketHours(ctx context.Context, req *UpdateMarketHoursReq, params UpdateMarketHoursParams) (UpdateMarketHoursRes, error) {
	b := h.client.MarketHours.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Date.Get(); ok {
		b.SetDate(v)
	}
	if v, ok := req.StartTime.Get(); ok {
		b.SetStartTime(v)
	}
	if v, ok := req.EndTime.Get(); ok {
		b.SetEndTime(v)
	}
	// Add all edges.
	if v, ok := req.MarketInfo.Get(); ok {
		b.SetMarketInfoID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.MarketHours.Query().Where(markethours.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewMarketHoursUpdate(e), nil
}

// DeleteMarketHours handles DELETE /market-hours-slice/{id} requests.
func (h *OgentHandler) DeleteMarketHours(ctx context.Context, params DeleteMarketHoursParams) (DeleteMarketHoursRes, error) {
	err := h.client.MarketHours.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteMarketHoursNoContent), nil

}

// ListMarketHours handles GET /market-hours-slice requests.
func (h *OgentHandler) ListMarketHours(ctx context.Context, params ListMarketHoursParams) (ListMarketHoursRes, error) {
	q := h.client.MarketHours.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewMarketHoursLists(es)
	return (*ListMarketHoursOKApplicationJSON)(&r), nil
}

// ReadMarketHoursMarketInfo handles GET /market-hours-slice/{id}/market-info requests.
func (h *OgentHandler) ReadMarketHoursMarketInfo(ctx context.Context, params ReadMarketHoursMarketInfoParams) (ReadMarketHoursMarketInfoRes, error) {
	q := h.client.MarketHours.Query().Where(markethours.IDEQ(params.ID)).QueryMarketInfo()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewMarketHoursMarketInfoRead(e), nil
}

// CreateMarketInfo handles POST /market-infos requests.
func (h *OgentHandler) CreateMarketInfo(ctx context.Context, req *CreateMarketInfoReq) (CreateMarketInfoRes, error) {
	b := h.client.MarketInfo.Create()
	// Add all fields.
	b.SetHoursStart(req.HoursStart)
	b.SetHoursEnd(req.HoursEnd)
	// Add all edges.
	b.AddHourIDs(req.Hours...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.MarketInfo.Query().Where(marketinfo.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewMarketInfoCreate(e), nil
}

// ReadMarketInfo handles GET /market-infos/{id} requests.
func (h *OgentHandler) ReadMarketInfo(ctx context.Context, params ReadMarketInfoParams) (ReadMarketInfoRes, error) {
	q := h.client.MarketInfo.Query().Where(marketinfo.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewMarketInfoRead(e), nil
}

// UpdateMarketInfo handles PATCH /market-infos/{id} requests.
func (h *OgentHandler) UpdateMarketInfo(ctx context.Context, req *UpdateMarketInfoReq, params UpdateMarketInfoParams) (UpdateMarketInfoRes, error) {
	b := h.client.MarketInfo.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.HoursStart.Get(); ok {
		b.SetHoursStart(v)
	}
	if v, ok := req.HoursEnd.Get(); ok {
		b.SetHoursEnd(v)
	}
	// Add all edges.
	if req.Hours != nil {
		b.ClearHours().AddHourIDs(req.Hours...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.MarketInfo.Query().Where(marketinfo.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewMarketInfoUpdate(e), nil
}

// DeleteMarketInfo handles DELETE /market-infos/{id} requests.
func (h *OgentHandler) DeleteMarketInfo(ctx context.Context, params DeleteMarketInfoParams) (DeleteMarketInfoRes, error) {
	err := h.client.MarketInfo.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteMarketInfoNoContent), nil

}

// ListMarketInfo handles GET /market-infos requests.
func (h *OgentHandler) ListMarketInfo(ctx context.Context, params ListMarketInfoParams) (ListMarketInfoRes, error) {
	q := h.client.MarketInfo.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewMarketInfoLists(es)
	return (*ListMarketInfoOKApplicationJSON)(&r), nil
}

// ListMarketInfoHours handles GET /market-infos/{id}/hours requests.
func (h *OgentHandler) ListMarketInfoHours(ctx context.Context, params ListMarketInfoHoursParams) (ListMarketInfoHoursRes, error) {
	q := h.client.MarketInfo.Query().Where(marketinfo.IDEQ(params.ID)).QueryHours()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewMarketInfoHoursLists(es)
	return (*ListMarketInfoHoursOKApplicationJSON)(&r), nil
}

// CreateSplit handles POST /splits requests.
func (h *OgentHandler) CreateSplit(ctx context.Context, req *CreateSplitReq) (CreateSplitRes, error) {
	b := h.client.Split.Create()
	// Add all fields.
	b.SetExecutionDate(req.ExecutionDate)
	b.SetFrom(req.From)
	b.SetTo(req.To)
	// Add all edges.
	if v, ok := req.Stock.Get(); ok {
		b.SetStockID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Split.Query().Where(split.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewSplitCreate(e), nil
}

// ReadSplit handles GET /splits/{id} requests.
func (h *OgentHandler) ReadSplit(ctx context.Context, params ReadSplitParams) (ReadSplitRes, error) {
	q := h.client.Split.Query().Where(split.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewSplitRead(e), nil
}

// UpdateSplit handles PATCH /splits/{id} requests.
func (h *OgentHandler) UpdateSplit(ctx context.Context, req *UpdateSplitReq, params UpdateSplitParams) (UpdateSplitRes, error) {
	b := h.client.Split.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.ExecutionDate.Get(); ok {
		b.SetExecutionDate(v)
	}
	if v, ok := req.From.Get(); ok {
		b.SetFrom(v)
	}
	if v, ok := req.To.Get(); ok {
		b.SetTo(v)
	}
	// Add all edges.
	if v, ok := req.Stock.Get(); ok {
		b.SetStockID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Split.Query().Where(split.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewSplitUpdate(e), nil
}

// DeleteSplit handles DELETE /splits/{id} requests.
func (h *OgentHandler) DeleteSplit(ctx context.Context, params DeleteSplitParams) (DeleteSplitRes, error) {
	err := h.client.Split.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteSplitNoContent), nil

}

// ListSplit handles GET /splits requests.
func (h *OgentHandler) ListSplit(ctx context.Context, params ListSplitParams) (ListSplitRes, error) {
	q := h.client.Split.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewSplitLists(es)
	return (*ListSplitOKApplicationJSON)(&r), nil
}

// ReadSplitStock handles GET /splits/{id}/stock requests.
func (h *OgentHandler) ReadSplitStock(ctx context.Context, params ReadSplitStockParams) (ReadSplitStockRes, error) {
	q := h.client.Split.Query().Where(split.IDEQ(params.ID)).QueryStock()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewSplitStockRead(e), nil
}

// CreateTradeCondition handles POST /trade-conditions requests.
func (h *OgentHandler) CreateTradeCondition(ctx context.Context, req *CreateTradeConditionReq) (CreateTradeConditionRes, error) {
	b := h.client.TradeCondition.Create()
	// Add all fields.
	b.SetCondition(req.Condition)
	// Add all edges.
	b.AddRecordIDs(req.Record...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.TradeCondition.Query().Where(tradecondition.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTradeConditionCreate(e), nil
}

// ReadTradeCondition handles GET /trade-conditions/{id} requests.
func (h *OgentHandler) ReadTradeCondition(ctx context.Context, params ReadTradeConditionParams) (ReadTradeConditionRes, error) {
	q := h.client.TradeCondition.Query().Where(tradecondition.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewTradeConditionRead(e), nil
}

// UpdateTradeCondition handles PATCH /trade-conditions/{id} requests.
func (h *OgentHandler) UpdateTradeCondition(ctx context.Context, req *UpdateTradeConditionReq, params UpdateTradeConditionParams) (UpdateTradeConditionRes, error) {
	b := h.client.TradeCondition.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Condition.Get(); ok {
		b.SetCondition(v)
	}
	// Add all edges.
	if req.Record != nil {
		b.ClearRecord().AddRecordIDs(req.Record...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.TradeCondition.Query().Where(tradecondition.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTradeConditionUpdate(e), nil
}

// DeleteTradeCondition handles DELETE /trade-conditions/{id} requests.
func (h *OgentHandler) DeleteTradeCondition(ctx context.Context, params DeleteTradeConditionParams) (DeleteTradeConditionRes, error) {
	err := h.client.TradeCondition.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteTradeConditionNoContent), nil

}

// ListTradeCondition handles GET /trade-conditions requests.
func (h *OgentHandler) ListTradeCondition(ctx context.Context, params ListTradeConditionParams) (ListTradeConditionRes, error) {
	q := h.client.TradeCondition.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTradeConditionLists(es)
	return (*ListTradeConditionOKApplicationJSON)(&r), nil
}

// ListTradeConditionRecord handles GET /trade-conditions/{id}/record requests.
func (h *OgentHandler) ListTradeConditionRecord(ctx context.Context, params ListTradeConditionRecordParams) (ListTradeConditionRecordRes, error) {
	q := h.client.TradeCondition.Query().Where(tradecondition.IDEQ(params.ID)).QueryRecord()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTradeConditionRecordLists(es)
	return (*ListTradeConditionRecordOKApplicationJSON)(&r), nil
}

// CreateTradeCorrection handles POST /trade-corrections requests.
func (h *OgentHandler) CreateTradeCorrection(ctx context.Context, req *CreateTradeCorrectionReq) (CreateTradeCorrectionRes, error) {
	b := h.client.TradeCorrection.Create()
	// Add all fields.
	b.SetCorrection(req.Correction)
	// Add all edges.
	b.AddRecordIDs(req.Record...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.TradeCorrection.Query().Where(tradecorrection.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTradeCorrectionCreate(e), nil
}

// ReadTradeCorrection handles GET /trade-corrections/{id} requests.
func (h *OgentHandler) ReadTradeCorrection(ctx context.Context, params ReadTradeCorrectionParams) (ReadTradeCorrectionRes, error) {
	q := h.client.TradeCorrection.Query().Where(tradecorrection.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewTradeCorrectionRead(e), nil
}

// UpdateTradeCorrection handles PATCH /trade-corrections/{id} requests.
func (h *OgentHandler) UpdateTradeCorrection(ctx context.Context, req *UpdateTradeCorrectionReq, params UpdateTradeCorrectionParams) (UpdateTradeCorrectionRes, error) {
	b := h.client.TradeCorrection.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Correction.Get(); ok {
		b.SetCorrection(v)
	}
	// Add all edges.
	if req.Record != nil {
		b.ClearRecord().AddRecordIDs(req.Record...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.TradeCorrection.Query().Where(tradecorrection.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTradeCorrectionUpdate(e), nil
}

// DeleteTradeCorrection handles DELETE /trade-corrections/{id} requests.
func (h *OgentHandler) DeleteTradeCorrection(ctx context.Context, params DeleteTradeCorrectionParams) (DeleteTradeCorrectionRes, error) {
	err := h.client.TradeCorrection.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteTradeCorrectionNoContent), nil

}

// ListTradeCorrection handles GET /trade-corrections requests.
func (h *OgentHandler) ListTradeCorrection(ctx context.Context, params ListTradeCorrectionParams) (ListTradeCorrectionRes, error) {
	q := h.client.TradeCorrection.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTradeCorrectionLists(es)
	return (*ListTradeCorrectionOKApplicationJSON)(&r), nil
}

// ListTradeCorrectionRecord handles GET /trade-corrections/{id}/record requests.
func (h *OgentHandler) ListTradeCorrectionRecord(ctx context.Context, params ListTradeCorrectionRecordParams) (ListTradeCorrectionRecordRes, error) {
	q := h.client.TradeCorrection.Query().Where(tradecorrection.IDEQ(params.ID)).QueryRecord()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTradeCorrectionRecordLists(es)
	return (*ListTradeCorrectionRecordOKApplicationJSON)(&r), nil
}

// CreateTradeRecord handles POST /trade-records requests.
func (h *OgentHandler) CreateTradeRecord(ctx context.Context, req *CreateTradeRecordReq) (CreateTradeRecordRes, error) {
	b := h.client.TradeRecord.Create()
	// Add all fields.
	b.SetPrice(req.Price)
	b.SetTimestamp(req.Timestamp)
	b.SetVolume(req.Volume)
	b.SetTimeRangeID(req.TimeRangeID)
	// Add all edges.
	b.SetTimeRangeID(req.TimeRange)
	b.AddConditionIDs(req.Conditions...)
	b.AddCorrectionIDs(req.Correction...)
	b.AddExchangeIDs(req.Exchange...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.TradeRecord.Query().Where(traderecord.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTradeRecordCreate(e), nil
}

// ReadTradeRecord handles GET /trade-records/{id} requests.
func (h *OgentHandler) ReadTradeRecord(ctx context.Context, params ReadTradeRecordParams) (ReadTradeRecordRes, error) {
	q := h.client.TradeRecord.Query().Where(traderecord.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewTradeRecordRead(e), nil
}

// UpdateTradeRecord handles PATCH /trade-records/{id} requests.
func (h *OgentHandler) UpdateTradeRecord(ctx context.Context, req *UpdateTradeRecordReq, params UpdateTradeRecordParams) (UpdateTradeRecordRes, error) {
	b := h.client.TradeRecord.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Price.Get(); ok {
		b.SetPrice(v)
	}
	if v, ok := req.Timestamp.Get(); ok {
		b.SetTimestamp(v)
	}
	if v, ok := req.Volume.Get(); ok {
		b.SetVolume(v)
	}
	if v, ok := req.TimeRangeID.Get(); ok {
		b.SetTimeRangeID(v)
	}
	// Add all edges.
	if v, ok := req.TimeRange.Get(); ok {
		b.SetTimeRangeID(v)
	}
	if req.Conditions != nil {
		b.ClearConditions().AddConditionIDs(req.Conditions...)
	}
	if req.Correction != nil {
		b.ClearCorrection().AddCorrectionIDs(req.Correction...)
	}
	if req.Exchange != nil {
		b.ClearExchange().AddExchangeIDs(req.Exchange...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.TradeRecord.Query().Where(traderecord.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTradeRecordUpdate(e), nil
}

// DeleteTradeRecord handles DELETE /trade-records/{id} requests.
func (h *OgentHandler) DeleteTradeRecord(ctx context.Context, params DeleteTradeRecordParams) (DeleteTradeRecordRes, error) {
	err := h.client.TradeRecord.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteTradeRecordNoContent), nil

}

// ListTradeRecord handles GET /trade-records requests.
func (h *OgentHandler) ListTradeRecord(ctx context.Context, params ListTradeRecordParams) (ListTradeRecordRes, error) {
	q := h.client.TradeRecord.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTradeRecordLists(es)
	return (*ListTradeRecordOKApplicationJSON)(&r), nil
}

// ReadTradeRecordTimeRange handles GET /trade-records/{id}/time-range requests.
func (h *OgentHandler) ReadTradeRecordTimeRange(ctx context.Context, params ReadTradeRecordTimeRangeParams) (ReadTradeRecordTimeRangeRes, error) {
	q := h.client.TradeRecord.Query().Where(traderecord.IDEQ(params.ID)).QueryTimeRange()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewTradeRecordTimeRangeRead(e), nil
}

// ListTradeRecordConditions handles GET /trade-records/{id}/conditions requests.
func (h *OgentHandler) ListTradeRecordConditions(ctx context.Context, params ListTradeRecordConditionsParams) (ListTradeRecordConditionsRes, error) {
	q := h.client.TradeRecord.Query().Where(traderecord.IDEQ(params.ID)).QueryConditions()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTradeRecordConditionsLists(es)
	return (*ListTradeRecordConditionsOKApplicationJSON)(&r), nil
}

// ListTradeRecordCorrection handles GET /trade-records/{id}/correction requests.
func (h *OgentHandler) ListTradeRecordCorrection(ctx context.Context, params ListTradeRecordCorrectionParams) (ListTradeRecordCorrectionRes, error) {
	q := h.client.TradeRecord.Query().Where(traderecord.IDEQ(params.ID)).QueryCorrection()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTradeRecordCorrectionLists(es)
	return (*ListTradeRecordCorrectionOKApplicationJSON)(&r), nil
}

// ListTradeRecordExchange handles GET /trade-records/{id}/exchange requests.
func (h *OgentHandler) ListTradeRecordExchange(ctx context.Context, params ListTradeRecordExchangeParams) (ListTradeRecordExchangeRes, error) {
	q := h.client.TradeRecord.Query().Where(traderecord.IDEQ(params.ID)).QueryExchange()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTradeRecordExchangeLists(es)
	return (*ListTradeRecordExchangeOKApplicationJSON)(&r), nil
}

// CreateTradeTimeRange handles POST /trade-time-ranges requests.
func (h *OgentHandler) CreateTradeTimeRange(ctx context.Context, req *CreateTradeTimeRangeReq) (CreateTradeTimeRangeRes, error) {
	b := h.client.TradeTimeRange.Create()
	// Add all fields.
	b.SetStart(req.Start)
	b.SetEnd(req.End)
	b.SetIntervalID(req.IntervalID)
	// Add all edges.
	b.SetIntervalID(req.Interval)
	b.AddRecordIDs(req.Records...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.TradeTimeRange.Query().Where(tradetimerange.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTradeTimeRangeCreate(e), nil
}

// ReadTradeTimeRange handles GET /trade-time-ranges/{id} requests.
func (h *OgentHandler) ReadTradeTimeRange(ctx context.Context, params ReadTradeTimeRangeParams) (ReadTradeTimeRangeRes, error) {
	q := h.client.TradeTimeRange.Query().Where(tradetimerange.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewTradeTimeRangeRead(e), nil
}

// UpdateTradeTimeRange handles PATCH /trade-time-ranges/{id} requests.
func (h *OgentHandler) UpdateTradeTimeRange(ctx context.Context, req *UpdateTradeTimeRangeReq, params UpdateTradeTimeRangeParams) (UpdateTradeTimeRangeRes, error) {
	b := h.client.TradeTimeRange.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Start.Get(); ok {
		b.SetStart(v)
	}
	if v, ok := req.End.Get(); ok {
		b.SetEnd(v)
	}
	if v, ok := req.IntervalID.Get(); ok {
		b.SetIntervalID(v)
	}
	// Add all edges.
	if v, ok := req.Interval.Get(); ok {
		b.SetIntervalID(v)
	}
	if req.Records != nil {
		b.ClearRecords().AddRecordIDs(req.Records...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.TradeTimeRange.Query().Where(tradetimerange.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTradeTimeRangeUpdate(e), nil
}

// DeleteTradeTimeRange handles DELETE /trade-time-ranges/{id} requests.
func (h *OgentHandler) DeleteTradeTimeRange(ctx context.Context, params DeleteTradeTimeRangeParams) (DeleteTradeTimeRangeRes, error) {
	err := h.client.TradeTimeRange.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteTradeTimeRangeNoContent), nil

}

// ListTradeTimeRange handles GET /trade-time-ranges requests.
func (h *OgentHandler) ListTradeTimeRange(ctx context.Context, params ListTradeTimeRangeParams) (ListTradeTimeRangeRes, error) {
	q := h.client.TradeTimeRange.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTradeTimeRangeLists(es)
	return (*ListTradeTimeRangeOKApplicationJSON)(&r), nil
}

// ReadTradeTimeRangeInterval handles GET /trade-time-ranges/{id}/interval requests.
func (h *OgentHandler) ReadTradeTimeRangeInterval(ctx context.Context, params ReadTradeTimeRangeIntervalParams) (ReadTradeTimeRangeIntervalRes, error) {
	q := h.client.TradeTimeRange.Query().Where(tradetimerange.IDEQ(params.ID)).QueryInterval()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewTradeTimeRangeIntervalRead(e), nil
}

// ListTradeTimeRangeRecords handles GET /trade-time-ranges/{id}/records requests.
func (h *OgentHandler) ListTradeTimeRangeRecords(ctx context.Context, params ListTradeTimeRangeRecordsParams) (ListTradeTimeRangeRecordsRes, error) {
	q := h.client.TradeTimeRange.Query().Where(tradetimerange.IDEQ(params.ID)).QueryRecords()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTradeTimeRangeRecordsLists(es)
	return (*ListTradeTimeRangeRecordsOKApplicationJSON)(&r), nil
}
