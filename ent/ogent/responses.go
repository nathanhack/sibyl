// Code generated by ent, DO NOT EDIT.

package ogent

import "github.com/nathanhack/sibyl/ent"

func NewBarGroupCreate(e *ent.BarGroup) *BarGroupCreate {
	if e == nil {
		return nil
	}
	var ret BarGroupCreate
	ret.ID = e.ID
	ret.First = e.First
	ret.Last = e.Last
	ret.Count = e.Count
	ret.TimeRangeID = e.TimeRangeID
	return &ret
}

func NewBarGroupCreates(es []*ent.BarGroup) []BarGroupCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]BarGroupCreate, len(es))
	for i, e := range es {
		r[i] = NewBarGroupCreate(e).Elem()
	}
	return r
}

func (bg *BarGroupCreate) Elem() BarGroupCreate {
	if bg == nil {
		return BarGroupCreate{}
	}
	return *bg
}

func NewBarGroupList(e *ent.BarGroup) *BarGroupList {
	if e == nil {
		return nil
	}
	var ret BarGroupList
	ret.ID = e.ID
	ret.First = e.First
	ret.Last = e.Last
	ret.Count = e.Count
	ret.TimeRangeID = e.TimeRangeID
	return &ret
}

func NewBarGroupLists(es []*ent.BarGroup) []BarGroupList {
	if len(es) == 0 {
		return nil
	}
	r := make([]BarGroupList, len(es))
	for i, e := range es {
		r[i] = NewBarGroupList(e).Elem()
	}
	return r
}

func (bg *BarGroupList) Elem() BarGroupList {
	if bg == nil {
		return BarGroupList{}
	}
	return *bg
}

func NewBarGroupRead(e *ent.BarGroup) *BarGroupRead {
	if e == nil {
		return nil
	}
	var ret BarGroupRead
	ret.ID = e.ID
	ret.First = e.First
	ret.Last = e.Last
	ret.Count = e.Count
	ret.TimeRangeID = e.TimeRangeID
	return &ret
}

func NewBarGroupReads(es []*ent.BarGroup) []BarGroupRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]BarGroupRead, len(es))
	for i, e := range es {
		r[i] = NewBarGroupRead(e).Elem()
	}
	return r
}

func (bg *BarGroupRead) Elem() BarGroupRead {
	if bg == nil {
		return BarGroupRead{}
	}
	return *bg
}

func NewBarGroupUpdate(e *ent.BarGroup) *BarGroupUpdate {
	if e == nil {
		return nil
	}
	var ret BarGroupUpdate
	ret.ID = e.ID
	ret.First = e.First
	ret.Last = e.Last
	ret.Count = e.Count
	ret.TimeRangeID = e.TimeRangeID
	return &ret
}

func NewBarGroupUpdates(es []*ent.BarGroup) []BarGroupUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]BarGroupUpdate, len(es))
	for i, e := range es {
		r[i] = NewBarGroupUpdate(e).Elem()
	}
	return r
}

func (bg *BarGroupUpdate) Elem() BarGroupUpdate {
	if bg == nil {
		return BarGroupUpdate{}
	}
	return *bg
}

func NewBarGroupRecordsList(e *ent.BarRecord) *BarGroupRecordsList {
	if e == nil {
		return nil
	}
	var ret BarGroupRecordsList
	ret.ID = e.ID
	ret.Close = e.Close
	ret.High = e.High
	ret.Low = e.Low
	ret.Open = e.Open
	ret.Timestamp = e.Timestamp
	ret.Volume = e.Volume
	ret.Transactions = e.Transactions
	return &ret
}

func NewBarGroupRecordsLists(es []*ent.BarRecord) []BarGroupRecordsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]BarGroupRecordsList, len(es))
	for i, e := range es {
		r[i] = NewBarGroupRecordsList(e).Elem()
	}
	return r
}

func (br *BarGroupRecordsList) Elem() BarGroupRecordsList {
	if br == nil {
		return BarGroupRecordsList{}
	}
	return *br
}

func NewBarGroupTimeRangeRead(e *ent.BarTimeRange) *BarGroupTimeRangeRead {
	if e == nil {
		return nil
	}
	var ret BarGroupTimeRangeRead
	ret.ID = e.ID
	ret.Start = e.Start
	ret.End = e.End
	ret.Count = e.Count
	ret.IntervalID = e.IntervalID
	ret.Status = BarGroupTimeRangeReadStatus(e.Status)
	ret.UpdateTime = e.UpdateTime
	return &ret
}

func NewBarGroupTimeRangeReads(es []*ent.BarTimeRange) []BarGroupTimeRangeRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]BarGroupTimeRangeRead, len(es))
	for i, e := range es {
		r[i] = NewBarGroupTimeRangeRead(e).Elem()
	}
	return r
}

func (btr *BarGroupTimeRangeRead) Elem() BarGroupTimeRangeRead {
	if btr == nil {
		return BarGroupTimeRangeRead{}
	}
	return *btr
}

func NewBarRecordCreate(e *ent.BarRecord) *BarRecordCreate {
	if e == nil {
		return nil
	}
	var ret BarRecordCreate
	ret.ID = e.ID
	ret.Close = e.Close
	ret.High = e.High
	ret.Low = e.Low
	ret.Open = e.Open
	ret.Timestamp = e.Timestamp
	ret.Volume = e.Volume
	ret.Transactions = e.Transactions
	return &ret
}

func NewBarRecordCreates(es []*ent.BarRecord) []BarRecordCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]BarRecordCreate, len(es))
	for i, e := range es {
		r[i] = NewBarRecordCreate(e).Elem()
	}
	return r
}

func (br *BarRecordCreate) Elem() BarRecordCreate {
	if br == nil {
		return BarRecordCreate{}
	}
	return *br
}

func NewBarRecordList(e *ent.BarRecord) *BarRecordList {
	if e == nil {
		return nil
	}
	var ret BarRecordList
	ret.ID = e.ID
	ret.Close = e.Close
	ret.High = e.High
	ret.Low = e.Low
	ret.Open = e.Open
	ret.Timestamp = e.Timestamp
	ret.Volume = e.Volume
	ret.Transactions = e.Transactions
	return &ret
}

func NewBarRecordLists(es []*ent.BarRecord) []BarRecordList {
	if len(es) == 0 {
		return nil
	}
	r := make([]BarRecordList, len(es))
	for i, e := range es {
		r[i] = NewBarRecordList(e).Elem()
	}
	return r
}

func (br *BarRecordList) Elem() BarRecordList {
	if br == nil {
		return BarRecordList{}
	}
	return *br
}

func NewBarRecordRead(e *ent.BarRecord) *BarRecordRead {
	if e == nil {
		return nil
	}
	var ret BarRecordRead
	ret.ID = e.ID
	ret.Close = e.Close
	ret.High = e.High
	ret.Low = e.Low
	ret.Open = e.Open
	ret.Timestamp = e.Timestamp
	ret.Volume = e.Volume
	ret.Transactions = e.Transactions
	return &ret
}

func NewBarRecordReads(es []*ent.BarRecord) []BarRecordRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]BarRecordRead, len(es))
	for i, e := range es {
		r[i] = NewBarRecordRead(e).Elem()
	}
	return r
}

func (br *BarRecordRead) Elem() BarRecordRead {
	if br == nil {
		return BarRecordRead{}
	}
	return *br
}

func NewBarRecordUpdate(e *ent.BarRecord) *BarRecordUpdate {
	if e == nil {
		return nil
	}
	var ret BarRecordUpdate
	ret.ID = e.ID
	ret.Close = e.Close
	ret.High = e.High
	ret.Low = e.Low
	ret.Open = e.Open
	ret.Timestamp = e.Timestamp
	ret.Volume = e.Volume
	ret.Transactions = e.Transactions
	return &ret
}

func NewBarRecordUpdates(es []*ent.BarRecord) []BarRecordUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]BarRecordUpdate, len(es))
	for i, e := range es {
		r[i] = NewBarRecordUpdate(e).Elem()
	}
	return r
}

func (br *BarRecordUpdate) Elem() BarRecordUpdate {
	if br == nil {
		return BarRecordUpdate{}
	}
	return *br
}

func NewBarRecordGroupRead(e *ent.BarGroup) *BarRecordGroupRead {
	if e == nil {
		return nil
	}
	var ret BarRecordGroupRead
	ret.ID = e.ID
	ret.First = e.First
	ret.Last = e.Last
	ret.Count = e.Count
	ret.TimeRangeID = e.TimeRangeID
	return &ret
}

func NewBarRecordGroupReads(es []*ent.BarGroup) []BarRecordGroupRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]BarRecordGroupRead, len(es))
	for i, e := range es {
		r[i] = NewBarRecordGroupRead(e).Elem()
	}
	return r
}

func (bg *BarRecordGroupRead) Elem() BarRecordGroupRead {
	if bg == nil {
		return BarRecordGroupRead{}
	}
	return *bg
}

func NewBarTimeRangeCreate(e *ent.BarTimeRange) *BarTimeRangeCreate {
	if e == nil {
		return nil
	}
	var ret BarTimeRangeCreate
	ret.ID = e.ID
	ret.Start = e.Start
	ret.End = e.End
	ret.Count = e.Count
	ret.IntervalID = e.IntervalID
	ret.Status = BarTimeRangeCreateStatus(e.Status)
	ret.UpdateTime = e.UpdateTime
	return &ret
}

func NewBarTimeRangeCreates(es []*ent.BarTimeRange) []BarTimeRangeCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]BarTimeRangeCreate, len(es))
	for i, e := range es {
		r[i] = NewBarTimeRangeCreate(e).Elem()
	}
	return r
}

func (btr *BarTimeRangeCreate) Elem() BarTimeRangeCreate {
	if btr == nil {
		return BarTimeRangeCreate{}
	}
	return *btr
}

func NewBarTimeRangeList(e *ent.BarTimeRange) *BarTimeRangeList {
	if e == nil {
		return nil
	}
	var ret BarTimeRangeList
	ret.ID = e.ID
	ret.Start = e.Start
	ret.End = e.End
	ret.Count = e.Count
	ret.IntervalID = e.IntervalID
	ret.Status = BarTimeRangeListStatus(e.Status)
	ret.UpdateTime = e.UpdateTime
	return &ret
}

func NewBarTimeRangeLists(es []*ent.BarTimeRange) []BarTimeRangeList {
	if len(es) == 0 {
		return nil
	}
	r := make([]BarTimeRangeList, len(es))
	for i, e := range es {
		r[i] = NewBarTimeRangeList(e).Elem()
	}
	return r
}

func (btr *BarTimeRangeList) Elem() BarTimeRangeList {
	if btr == nil {
		return BarTimeRangeList{}
	}
	return *btr
}

func NewBarTimeRangeRead(e *ent.BarTimeRange) *BarTimeRangeRead {
	if e == nil {
		return nil
	}
	var ret BarTimeRangeRead
	ret.ID = e.ID
	ret.Start = e.Start
	ret.End = e.End
	ret.Count = e.Count
	ret.IntervalID = e.IntervalID
	ret.Status = BarTimeRangeReadStatus(e.Status)
	ret.UpdateTime = e.UpdateTime
	return &ret
}

func NewBarTimeRangeReads(es []*ent.BarTimeRange) []BarTimeRangeRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]BarTimeRangeRead, len(es))
	for i, e := range es {
		r[i] = NewBarTimeRangeRead(e).Elem()
	}
	return r
}

func (btr *BarTimeRangeRead) Elem() BarTimeRangeRead {
	if btr == nil {
		return BarTimeRangeRead{}
	}
	return *btr
}

func NewBarTimeRangeUpdate(e *ent.BarTimeRange) *BarTimeRangeUpdate {
	if e == nil {
		return nil
	}
	var ret BarTimeRangeUpdate
	ret.ID = e.ID
	ret.Start = e.Start
	ret.End = e.End
	ret.Count = e.Count
	ret.IntervalID = e.IntervalID
	ret.Status = BarTimeRangeUpdateStatus(e.Status)
	ret.UpdateTime = e.UpdateTime
	return &ret
}

func NewBarTimeRangeUpdates(es []*ent.BarTimeRange) []BarTimeRangeUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]BarTimeRangeUpdate, len(es))
	for i, e := range es {
		r[i] = NewBarTimeRangeUpdate(e).Elem()
	}
	return r
}

func (btr *BarTimeRangeUpdate) Elem() BarTimeRangeUpdate {
	if btr == nil {
		return BarTimeRangeUpdate{}
	}
	return *btr
}

func NewBarTimeRangeGroupsList(e *ent.BarGroup) *BarTimeRangeGroupsList {
	if e == nil {
		return nil
	}
	var ret BarTimeRangeGroupsList
	ret.ID = e.ID
	ret.First = e.First
	ret.Last = e.Last
	ret.Count = e.Count
	ret.TimeRangeID = e.TimeRangeID
	return &ret
}

func NewBarTimeRangeGroupsLists(es []*ent.BarGroup) []BarTimeRangeGroupsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]BarTimeRangeGroupsList, len(es))
	for i, e := range es {
		r[i] = NewBarTimeRangeGroupsList(e).Elem()
	}
	return r
}

func (bg *BarTimeRangeGroupsList) Elem() BarTimeRangeGroupsList {
	if bg == nil {
		return BarTimeRangeGroupsList{}
	}
	return *bg
}

func NewBarTimeRangeIntervalRead(e *ent.Interval) *BarTimeRangeIntervalRead {
	if e == nil {
		return nil
	}
	var ret BarTimeRangeIntervalRead
	ret.ID = e.ID
	ret.Active = e.Active
	ret.Interval = BarTimeRangeIntervalReadInterval(e.Interval)
	ret.StockID = e.StockID
	ret.DataSourceID = e.DataSourceID
	return &ret
}

func NewBarTimeRangeIntervalReads(es []*ent.Interval) []BarTimeRangeIntervalRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]BarTimeRangeIntervalRead, len(es))
	for i, e := range es {
		r[i] = NewBarTimeRangeIntervalRead(e).Elem()
	}
	return r
}

func (i *BarTimeRangeIntervalRead) Elem() BarTimeRangeIntervalRead {
	if i == nil {
		return BarTimeRangeIntervalRead{}
	}
	return *i
}

func NewDataSourceCreate(e *ent.DataSource) *DataSourceCreate {
	if e == nil {
		return nil
	}
	var ret DataSourceCreate
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Address = e.Address
	return &ret
}

func NewDataSourceCreates(es []*ent.DataSource) []DataSourceCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]DataSourceCreate, len(es))
	for i, e := range es {
		r[i] = NewDataSourceCreate(e).Elem()
	}
	return r
}

func (ds *DataSourceCreate) Elem() DataSourceCreate {
	if ds == nil {
		return DataSourceCreate{}
	}
	return *ds
}

func NewDataSourceList(e *ent.DataSource) *DataSourceList {
	if e == nil {
		return nil
	}
	var ret DataSourceList
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Address = e.Address
	return &ret
}

func NewDataSourceLists(es []*ent.DataSource) []DataSourceList {
	if len(es) == 0 {
		return nil
	}
	r := make([]DataSourceList, len(es))
	for i, e := range es {
		r[i] = NewDataSourceList(e).Elem()
	}
	return r
}

func (ds *DataSourceList) Elem() DataSourceList {
	if ds == nil {
		return DataSourceList{}
	}
	return *ds
}

func NewDataSourceRead(e *ent.DataSource) *DataSourceRead {
	if e == nil {
		return nil
	}
	var ret DataSourceRead
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Address = e.Address
	return &ret
}

func NewDataSourceReads(es []*ent.DataSource) []DataSourceRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]DataSourceRead, len(es))
	for i, e := range es {
		r[i] = NewDataSourceRead(e).Elem()
	}
	return r
}

func (ds *DataSourceRead) Elem() DataSourceRead {
	if ds == nil {
		return DataSourceRead{}
	}
	return *ds
}

func NewDataSourceUpdate(e *ent.DataSource) *DataSourceUpdate {
	if e == nil {
		return nil
	}
	var ret DataSourceUpdate
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Address = e.Address
	return &ret
}

func NewDataSourceUpdates(es []*ent.DataSource) []DataSourceUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]DataSourceUpdate, len(es))
	for i, e := range es {
		r[i] = NewDataSourceUpdate(e).Elem()
	}
	return r
}

func (ds *DataSourceUpdate) Elem() DataSourceUpdate {
	if ds == nil {
		return DataSourceUpdate{}
	}
	return *ds
}

func NewDataSourceIntervalsList(e *ent.Interval) *DataSourceIntervalsList {
	if e == nil {
		return nil
	}
	var ret DataSourceIntervalsList
	ret.ID = e.ID
	ret.Active = e.Active
	ret.Interval = DataSourceIntervalsListInterval(e.Interval)
	ret.StockID = e.StockID
	ret.DataSourceID = e.DataSourceID
	return &ret
}

func NewDataSourceIntervalsLists(es []*ent.Interval) []DataSourceIntervalsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]DataSourceIntervalsList, len(es))
	for i, e := range es {
		r[i] = NewDataSourceIntervalsList(e).Elem()
	}
	return r
}

func (i *DataSourceIntervalsList) Elem() DataSourceIntervalsList {
	if i == nil {
		return DataSourceIntervalsList{}
	}
	return *i
}

func NewDividendCreate(e *ent.Dividend) *DividendCreate {
	if e == nil {
		return nil
	}
	var ret DividendCreate
	ret.ID = e.ID
	ret.Rate = e.Rate
	ret.DeclarationDate = e.DeclarationDate
	ret.ExDividendDate = e.ExDividendDate
	ret.RecordDate = e.RecordDate
	ret.PayDate = e.PayDate
	return &ret
}

func NewDividendCreates(es []*ent.Dividend) []DividendCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]DividendCreate, len(es))
	for i, e := range es {
		r[i] = NewDividendCreate(e).Elem()
	}
	return r
}

func (d *DividendCreate) Elem() DividendCreate {
	if d == nil {
		return DividendCreate{}
	}
	return *d
}

func NewDividendList(e *ent.Dividend) *DividendList {
	if e == nil {
		return nil
	}
	var ret DividendList
	ret.ID = e.ID
	ret.Rate = e.Rate
	ret.DeclarationDate = e.DeclarationDate
	ret.ExDividendDate = e.ExDividendDate
	ret.RecordDate = e.RecordDate
	ret.PayDate = e.PayDate
	return &ret
}

func NewDividendLists(es []*ent.Dividend) []DividendList {
	if len(es) == 0 {
		return nil
	}
	r := make([]DividendList, len(es))
	for i, e := range es {
		r[i] = NewDividendList(e).Elem()
	}
	return r
}

func (d *DividendList) Elem() DividendList {
	if d == nil {
		return DividendList{}
	}
	return *d
}

func NewDividendRead(e *ent.Dividend) *DividendRead {
	if e == nil {
		return nil
	}
	var ret DividendRead
	ret.ID = e.ID
	ret.Rate = e.Rate
	ret.DeclarationDate = e.DeclarationDate
	ret.ExDividendDate = e.ExDividendDate
	ret.RecordDate = e.RecordDate
	ret.PayDate = e.PayDate
	return &ret
}

func NewDividendReads(es []*ent.Dividend) []DividendRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]DividendRead, len(es))
	for i, e := range es {
		r[i] = NewDividendRead(e).Elem()
	}
	return r
}

func (d *DividendRead) Elem() DividendRead {
	if d == nil {
		return DividendRead{}
	}
	return *d
}

func NewDividendUpdate(e *ent.Dividend) *DividendUpdate {
	if e == nil {
		return nil
	}
	var ret DividendUpdate
	ret.ID = e.ID
	ret.Rate = e.Rate
	ret.DeclarationDate = e.DeclarationDate
	ret.ExDividendDate = e.ExDividendDate
	ret.RecordDate = e.RecordDate
	ret.PayDate = e.PayDate
	return &ret
}

func NewDividendUpdates(es []*ent.Dividend) []DividendUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]DividendUpdate, len(es))
	for i, e := range es {
		r[i] = NewDividendUpdate(e).Elem()
	}
	return r
}

func (d *DividendUpdate) Elem() DividendUpdate {
	if d == nil {
		return DividendUpdate{}
	}
	return *d
}

func NewDividendStockList(e *ent.Entity) *DividendStockList {
	if e == nil {
		return nil
	}
	var ret DividendStockList
	ret.ID = e.ID
	ret.Active = e.Active
	ret.Ticker = e.Ticker
	ret.Name = e.Name
	ret.Description = e.Description
	ret.ListDate = e.ListDate
	ret.Options = e.Options
	ret.Tradable = e.Tradable
	return &ret
}

func NewDividendStockLists(es []*ent.Entity) []DividendStockList {
	if len(es) == 0 {
		return nil
	}
	r := make([]DividendStockList, len(es))
	for i, e := range es {
		r[i] = NewDividendStockList(e).Elem()
	}
	return r
}

func (e *DividendStockList) Elem() DividendStockList {
	if e == nil {
		return DividendStockList{}
	}
	return *e
}

func NewEntityCreate(e *ent.Entity) *EntityCreate {
	if e == nil {
		return nil
	}
	var ret EntityCreate
	ret.ID = e.ID
	ret.Active = e.Active
	ret.Ticker = e.Ticker
	ret.Name = e.Name
	ret.Description = e.Description
	ret.ListDate = e.ListDate
	ret.Options = e.Options
	ret.Tradable = e.Tradable
	return &ret
}

func NewEntityCreates(es []*ent.Entity) []EntityCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]EntityCreate, len(es))
	for i, e := range es {
		r[i] = NewEntityCreate(e).Elem()
	}
	return r
}

func (e *EntityCreate) Elem() EntityCreate {
	if e == nil {
		return EntityCreate{}
	}
	return *e
}

func NewEntityList(e *ent.Entity) *EntityList {
	if e == nil {
		return nil
	}
	var ret EntityList
	ret.ID = e.ID
	ret.Active = e.Active
	ret.Ticker = e.Ticker
	ret.Name = e.Name
	ret.Description = e.Description
	ret.ListDate = e.ListDate
	ret.Options = e.Options
	ret.Tradable = e.Tradable
	return &ret
}

func NewEntityLists(es []*ent.Entity) []EntityList {
	if len(es) == 0 {
		return nil
	}
	r := make([]EntityList, len(es))
	for i, e := range es {
		r[i] = NewEntityList(e).Elem()
	}
	return r
}

func (e *EntityList) Elem() EntityList {
	if e == nil {
		return EntityList{}
	}
	return *e
}

func NewEntityRead(e *ent.Entity) *EntityRead {
	if e == nil {
		return nil
	}
	var ret EntityRead
	ret.ID = e.ID
	ret.Active = e.Active
	ret.Ticker = e.Ticker
	ret.Name = e.Name
	ret.Description = e.Description
	ret.ListDate = e.ListDate
	ret.Options = e.Options
	ret.Tradable = e.Tradable
	return &ret
}

func NewEntityReads(es []*ent.Entity) []EntityRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]EntityRead, len(es))
	for i, e := range es {
		r[i] = NewEntityRead(e).Elem()
	}
	return r
}

func (e *EntityRead) Elem() EntityRead {
	if e == nil {
		return EntityRead{}
	}
	return *e
}

func NewEntityUpdate(e *ent.Entity) *EntityUpdate {
	if e == nil {
		return nil
	}
	var ret EntityUpdate
	ret.ID = e.ID
	ret.Active = e.Active
	ret.Ticker = e.Ticker
	ret.Name = e.Name
	ret.Description = e.Description
	ret.ListDate = e.ListDate
	ret.Options = e.Options
	ret.Tradable = e.Tradable
	return &ret
}

func NewEntityUpdates(es []*ent.Entity) []EntityUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]EntityUpdate, len(es))
	for i, e := range es {
		r[i] = NewEntityUpdate(e).Elem()
	}
	return r
}

func (e *EntityUpdate) Elem() EntityUpdate {
	if e == nil {
		return EntityUpdate{}
	}
	return *e
}

func NewEntityDividendsList(e *ent.Dividend) *EntityDividendsList {
	if e == nil {
		return nil
	}
	var ret EntityDividendsList
	ret.ID = e.ID
	ret.Rate = e.Rate
	ret.DeclarationDate = e.DeclarationDate
	ret.ExDividendDate = e.ExDividendDate
	ret.RecordDate = e.RecordDate
	ret.PayDate = e.PayDate
	return &ret
}

func NewEntityDividendsLists(es []*ent.Dividend) []EntityDividendsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]EntityDividendsList, len(es))
	for i, e := range es {
		r[i] = NewEntityDividendsList(e).Elem()
	}
	return r
}

func (d *EntityDividendsList) Elem() EntityDividendsList {
	if d == nil {
		return EntityDividendsList{}
	}
	return *d
}

func NewEntityExchangesList(e *ent.Exchange) *EntityExchangesList {
	if e == nil {
		return nil
	}
	var ret EntityExchangesList
	ret.ID = e.ID
	ret.Code = e.Code
	ret.Name = e.Name
	return &ret
}

func NewEntityExchangesLists(es []*ent.Exchange) []EntityExchangesList {
	if len(es) == 0 {
		return nil
	}
	r := make([]EntityExchangesList, len(es))
	for i, e := range es {
		r[i] = NewEntityExchangesList(e).Elem()
	}
	return r
}

func (e *EntityExchangesList) Elem() EntityExchangesList {
	if e == nil {
		return EntityExchangesList{}
	}
	return *e
}

func NewEntityFinancialsList(e *ent.Financial) *EntityFinancialsList {
	if e == nil {
		return nil
	}
	var ret EntityFinancialsList
	ret.ID = e.ID
	return &ret
}

func NewEntityFinancialsLists(es []*ent.Financial) []EntityFinancialsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]EntityFinancialsList, len(es))
	for i, e := range es {
		r[i] = NewEntityFinancialsList(e).Elem()
	}
	return r
}

func (f *EntityFinancialsList) Elem() EntityFinancialsList {
	if f == nil {
		return EntityFinancialsList{}
	}
	return *f
}

func NewEntityIntervalsList(e *ent.Interval) *EntityIntervalsList {
	if e == nil {
		return nil
	}
	var ret EntityIntervalsList
	ret.ID = e.ID
	ret.Active = e.Active
	ret.Interval = EntityIntervalsListInterval(e.Interval)
	ret.StockID = e.StockID
	ret.DataSourceID = e.DataSourceID
	return &ret
}

func NewEntityIntervalsLists(es []*ent.Interval) []EntityIntervalsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]EntityIntervalsList, len(es))
	for i, e := range es {
		r[i] = NewEntityIntervalsList(e).Elem()
	}
	return r
}

func (i *EntityIntervalsList) Elem() EntityIntervalsList {
	if i == nil {
		return EntityIntervalsList{}
	}
	return *i
}

func NewEntitySplitsList(e *ent.Split) *EntitySplitsList {
	if e == nil {
		return nil
	}
	var ret EntitySplitsList
	ret.ID = e.ID
	ret.ExecutionDate = e.ExecutionDate
	ret.From = e.From
	ret.To = e.To
	return &ret
}

func NewEntitySplitsLists(es []*ent.Split) []EntitySplitsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]EntitySplitsList, len(es))
	for i, e := range es {
		r[i] = NewEntitySplitsList(e).Elem()
	}
	return r
}

func (s *EntitySplitsList) Elem() EntitySplitsList {
	if s == nil {
		return EntitySplitsList{}
	}
	return *s
}

func NewExchangeCreate(e *ent.Exchange) *ExchangeCreate {
	if e == nil {
		return nil
	}
	var ret ExchangeCreate
	ret.ID = e.ID
	ret.Code = e.Code
	ret.Name = e.Name
	return &ret
}

func NewExchangeCreates(es []*ent.Exchange) []ExchangeCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]ExchangeCreate, len(es))
	for i, e := range es {
		r[i] = NewExchangeCreate(e).Elem()
	}
	return r
}

func (e *ExchangeCreate) Elem() ExchangeCreate {
	if e == nil {
		return ExchangeCreate{}
	}
	return *e
}

func NewExchangeList(e *ent.Exchange) *ExchangeList {
	if e == nil {
		return nil
	}
	var ret ExchangeList
	ret.ID = e.ID
	ret.Code = e.Code
	ret.Name = e.Name
	return &ret
}

func NewExchangeLists(es []*ent.Exchange) []ExchangeList {
	if len(es) == 0 {
		return nil
	}
	r := make([]ExchangeList, len(es))
	for i, e := range es {
		r[i] = NewExchangeList(e).Elem()
	}
	return r
}

func (e *ExchangeList) Elem() ExchangeList {
	if e == nil {
		return ExchangeList{}
	}
	return *e
}

func NewExchangeRead(e *ent.Exchange) *ExchangeRead {
	if e == nil {
		return nil
	}
	var ret ExchangeRead
	ret.ID = e.ID
	ret.Code = e.Code
	ret.Name = e.Name
	return &ret
}

func NewExchangeReads(es []*ent.Exchange) []ExchangeRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]ExchangeRead, len(es))
	for i, e := range es {
		r[i] = NewExchangeRead(e).Elem()
	}
	return r
}

func (e *ExchangeRead) Elem() ExchangeRead {
	if e == nil {
		return ExchangeRead{}
	}
	return *e
}

func NewExchangeUpdate(e *ent.Exchange) *ExchangeUpdate {
	if e == nil {
		return nil
	}
	var ret ExchangeUpdate
	ret.ID = e.ID
	ret.Code = e.Code
	ret.Name = e.Name
	return &ret
}

func NewExchangeUpdates(es []*ent.Exchange) []ExchangeUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]ExchangeUpdate, len(es))
	for i, e := range es {
		r[i] = NewExchangeUpdate(e).Elem()
	}
	return r
}

func (e *ExchangeUpdate) Elem() ExchangeUpdate {
	if e == nil {
		return ExchangeUpdate{}
	}
	return *e
}

func NewExchangeStocksList(e *ent.Entity) *ExchangeStocksList {
	if e == nil {
		return nil
	}
	var ret ExchangeStocksList
	ret.ID = e.ID
	ret.Active = e.Active
	ret.Ticker = e.Ticker
	ret.Name = e.Name
	ret.Description = e.Description
	ret.ListDate = e.ListDate
	ret.Options = e.Options
	ret.Tradable = e.Tradable
	return &ret
}

func NewExchangeStocksLists(es []*ent.Entity) []ExchangeStocksList {
	if len(es) == 0 {
		return nil
	}
	r := make([]ExchangeStocksList, len(es))
	for i, e := range es {
		r[i] = NewExchangeStocksList(e).Elem()
	}
	return r
}

func (e *ExchangeStocksList) Elem() ExchangeStocksList {
	if e == nil {
		return ExchangeStocksList{}
	}
	return *e
}

func NewFinancialCreate(e *ent.Financial) *FinancialCreate {
	if e == nil {
		return nil
	}
	var ret FinancialCreate
	ret.ID = e.ID
	return &ret
}

func NewFinancialCreates(es []*ent.Financial) []FinancialCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]FinancialCreate, len(es))
	for i, e := range es {
		r[i] = NewFinancialCreate(e).Elem()
	}
	return r
}

func (f *FinancialCreate) Elem() FinancialCreate {
	if f == nil {
		return FinancialCreate{}
	}
	return *f
}

func NewFinancialList(e *ent.Financial) *FinancialList {
	if e == nil {
		return nil
	}
	var ret FinancialList
	ret.ID = e.ID
	return &ret
}

func NewFinancialLists(es []*ent.Financial) []FinancialList {
	if len(es) == 0 {
		return nil
	}
	r := make([]FinancialList, len(es))
	for i, e := range es {
		r[i] = NewFinancialList(e).Elem()
	}
	return r
}

func (f *FinancialList) Elem() FinancialList {
	if f == nil {
		return FinancialList{}
	}
	return *f
}

func NewFinancialRead(e *ent.Financial) *FinancialRead {
	if e == nil {
		return nil
	}
	var ret FinancialRead
	ret.ID = e.ID
	return &ret
}

func NewFinancialReads(es []*ent.Financial) []FinancialRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]FinancialRead, len(es))
	for i, e := range es {
		r[i] = NewFinancialRead(e).Elem()
	}
	return r
}

func (f *FinancialRead) Elem() FinancialRead {
	if f == nil {
		return FinancialRead{}
	}
	return *f
}

func NewFinancialUpdate(e *ent.Financial) *FinancialUpdate {
	if e == nil {
		return nil
	}
	var ret FinancialUpdate
	ret.ID = e.ID
	return &ret
}

func NewFinancialUpdates(es []*ent.Financial) []FinancialUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]FinancialUpdate, len(es))
	for i, e := range es {
		r[i] = NewFinancialUpdate(e).Elem()
	}
	return r
}

func (f *FinancialUpdate) Elem() FinancialUpdate {
	if f == nil {
		return FinancialUpdate{}
	}
	return *f
}

func NewFinancialStockList(e *ent.Entity) *FinancialStockList {
	if e == nil {
		return nil
	}
	var ret FinancialStockList
	ret.ID = e.ID
	ret.Active = e.Active
	ret.Ticker = e.Ticker
	ret.Name = e.Name
	ret.Description = e.Description
	ret.ListDate = e.ListDate
	ret.Options = e.Options
	ret.Tradable = e.Tradable
	return &ret
}

func NewFinancialStockLists(es []*ent.Entity) []FinancialStockList {
	if len(es) == 0 {
		return nil
	}
	r := make([]FinancialStockList, len(es))
	for i, e := range es {
		r[i] = NewFinancialStockList(e).Elem()
	}
	return r
}

func (e *FinancialStockList) Elem() FinancialStockList {
	if e == nil {
		return FinancialStockList{}
	}
	return *e
}

func NewIntervalCreate(e *ent.Interval) *IntervalCreate {
	if e == nil {
		return nil
	}
	var ret IntervalCreate
	ret.ID = e.ID
	ret.Active = e.Active
	ret.Interval = IntervalCreateInterval(e.Interval)
	ret.StockID = e.StockID
	ret.DataSourceID = e.DataSourceID
	return &ret
}

func NewIntervalCreates(es []*ent.Interval) []IntervalCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]IntervalCreate, len(es))
	for i, e := range es {
		r[i] = NewIntervalCreate(e).Elem()
	}
	return r
}

func (i *IntervalCreate) Elem() IntervalCreate {
	if i == nil {
		return IntervalCreate{}
	}
	return *i
}

func NewIntervalList(e *ent.Interval) *IntervalList {
	if e == nil {
		return nil
	}
	var ret IntervalList
	ret.ID = e.ID
	ret.Active = e.Active
	ret.Interval = IntervalListInterval(e.Interval)
	ret.StockID = e.StockID
	ret.DataSourceID = e.DataSourceID
	return &ret
}

func NewIntervalLists(es []*ent.Interval) []IntervalList {
	if len(es) == 0 {
		return nil
	}
	r := make([]IntervalList, len(es))
	for i, e := range es {
		r[i] = NewIntervalList(e).Elem()
	}
	return r
}

func (i *IntervalList) Elem() IntervalList {
	if i == nil {
		return IntervalList{}
	}
	return *i
}

func NewIntervalRead(e *ent.Interval) *IntervalRead {
	if e == nil {
		return nil
	}
	var ret IntervalRead
	ret.ID = e.ID
	ret.Active = e.Active
	ret.Interval = IntervalReadInterval(e.Interval)
	ret.StockID = e.StockID
	ret.DataSourceID = e.DataSourceID
	return &ret
}

func NewIntervalReads(es []*ent.Interval) []IntervalRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]IntervalRead, len(es))
	for i, e := range es {
		r[i] = NewIntervalRead(e).Elem()
	}
	return r
}

func (i *IntervalRead) Elem() IntervalRead {
	if i == nil {
		return IntervalRead{}
	}
	return *i
}

func NewIntervalUpdate(e *ent.Interval) *IntervalUpdate {
	if e == nil {
		return nil
	}
	var ret IntervalUpdate
	ret.ID = e.ID
	ret.Active = e.Active
	ret.Interval = IntervalUpdateInterval(e.Interval)
	ret.StockID = e.StockID
	ret.DataSourceID = e.DataSourceID
	return &ret
}

func NewIntervalUpdates(es []*ent.Interval) []IntervalUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]IntervalUpdate, len(es))
	for i, e := range es {
		r[i] = NewIntervalUpdate(e).Elem()
	}
	return r
}

func (i *IntervalUpdate) Elem() IntervalUpdate {
	if i == nil {
		return IntervalUpdate{}
	}
	return *i
}

func NewIntervalBarsList(e *ent.BarTimeRange) *IntervalBarsList {
	if e == nil {
		return nil
	}
	var ret IntervalBarsList
	ret.ID = e.ID
	ret.Start = e.Start
	ret.End = e.End
	ret.Count = e.Count
	ret.IntervalID = e.IntervalID
	ret.Status = IntervalBarsListStatus(e.Status)
	ret.UpdateTime = e.UpdateTime
	return &ret
}

func NewIntervalBarsLists(es []*ent.BarTimeRange) []IntervalBarsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]IntervalBarsList, len(es))
	for i, e := range es {
		r[i] = NewIntervalBarsList(e).Elem()
	}
	return r
}

func (btr *IntervalBarsList) Elem() IntervalBarsList {
	if btr == nil {
		return IntervalBarsList{}
	}
	return *btr
}

func NewIntervalDataSourceRead(e *ent.DataSource) *IntervalDataSourceRead {
	if e == nil {
		return nil
	}
	var ret IntervalDataSourceRead
	ret.ID = e.ID
	ret.Name = e.Name
	ret.Address = e.Address
	return &ret
}

func NewIntervalDataSourceReads(es []*ent.DataSource) []IntervalDataSourceRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]IntervalDataSourceRead, len(es))
	for i, e := range es {
		r[i] = NewIntervalDataSourceRead(e).Elem()
	}
	return r
}

func (ds *IntervalDataSourceRead) Elem() IntervalDataSourceRead {
	if ds == nil {
		return IntervalDataSourceRead{}
	}
	return *ds
}

func NewIntervalStockRead(e *ent.Entity) *IntervalStockRead {
	if e == nil {
		return nil
	}
	var ret IntervalStockRead
	ret.ID = e.ID
	ret.Active = e.Active
	ret.Ticker = e.Ticker
	ret.Name = e.Name
	ret.Description = e.Description
	ret.ListDate = e.ListDate
	ret.Options = e.Options
	ret.Tradable = e.Tradable
	return &ret
}

func NewIntervalStockReads(es []*ent.Entity) []IntervalStockRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]IntervalStockRead, len(es))
	for i, e := range es {
		r[i] = NewIntervalStockRead(e).Elem()
	}
	return r
}

func (e *IntervalStockRead) Elem() IntervalStockRead {
	if e == nil {
		return IntervalStockRead{}
	}
	return *e
}

func NewIntervalTradesList(e *ent.TradeTimeRange) *IntervalTradesList {
	if e == nil {
		return nil
	}
	var ret IntervalTradesList
	ret.ID = e.ID
	ret.Start = e.Start
	ret.End = e.End
	ret.IntervalID = e.IntervalID
	return &ret
}

func NewIntervalTradesLists(es []*ent.TradeTimeRange) []IntervalTradesList {
	if len(es) == 0 {
		return nil
	}
	r := make([]IntervalTradesList, len(es))
	for i, e := range es {
		r[i] = NewIntervalTradesList(e).Elem()
	}
	return r
}

func (ttr *IntervalTradesList) Elem() IntervalTradesList {
	if ttr == nil {
		return IntervalTradesList{}
	}
	return *ttr
}

func NewMarketHoursCreate(e *ent.MarketHours) *MarketHoursCreate {
	if e == nil {
		return nil
	}
	var ret MarketHoursCreate
	ret.ID = e.ID
	ret.Date = e.Date
	ret.StartTime = e.StartTime
	ret.EndTime = e.EndTime
	return &ret
}

func NewMarketHoursCreates(es []*ent.MarketHours) []MarketHoursCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]MarketHoursCreate, len(es))
	for i, e := range es {
		r[i] = NewMarketHoursCreate(e).Elem()
	}
	return r
}

func (mh *MarketHoursCreate) Elem() MarketHoursCreate {
	if mh == nil {
		return MarketHoursCreate{}
	}
	return *mh
}

func NewMarketHoursList(e *ent.MarketHours) *MarketHoursList {
	if e == nil {
		return nil
	}
	var ret MarketHoursList
	ret.ID = e.ID
	ret.Date = e.Date
	ret.StartTime = e.StartTime
	ret.EndTime = e.EndTime
	return &ret
}

func NewMarketHoursLists(es []*ent.MarketHours) []MarketHoursList {
	if len(es) == 0 {
		return nil
	}
	r := make([]MarketHoursList, len(es))
	for i, e := range es {
		r[i] = NewMarketHoursList(e).Elem()
	}
	return r
}

func (mh *MarketHoursList) Elem() MarketHoursList {
	if mh == nil {
		return MarketHoursList{}
	}
	return *mh
}

func NewMarketHoursRead(e *ent.MarketHours) *MarketHoursRead {
	if e == nil {
		return nil
	}
	var ret MarketHoursRead
	ret.ID = e.ID
	ret.Date = e.Date
	ret.StartTime = e.StartTime
	ret.EndTime = e.EndTime
	return &ret
}

func NewMarketHoursReads(es []*ent.MarketHours) []MarketHoursRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]MarketHoursRead, len(es))
	for i, e := range es {
		r[i] = NewMarketHoursRead(e).Elem()
	}
	return r
}

func (mh *MarketHoursRead) Elem() MarketHoursRead {
	if mh == nil {
		return MarketHoursRead{}
	}
	return *mh
}

func NewMarketHoursUpdate(e *ent.MarketHours) *MarketHoursUpdate {
	if e == nil {
		return nil
	}
	var ret MarketHoursUpdate
	ret.ID = e.ID
	ret.Date = e.Date
	ret.StartTime = e.StartTime
	ret.EndTime = e.EndTime
	return &ret
}

func NewMarketHoursUpdates(es []*ent.MarketHours) []MarketHoursUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]MarketHoursUpdate, len(es))
	for i, e := range es {
		r[i] = NewMarketHoursUpdate(e).Elem()
	}
	return r
}

func (mh *MarketHoursUpdate) Elem() MarketHoursUpdate {
	if mh == nil {
		return MarketHoursUpdate{}
	}
	return *mh
}

func NewMarketHoursMarketInfoRead(e *ent.MarketInfo) *MarketHoursMarketInfoRead {
	if e == nil {
		return nil
	}
	var ret MarketHoursMarketInfoRead
	ret.ID = e.ID
	ret.HoursStart = e.HoursStart
	ret.HoursEnd = e.HoursEnd
	return &ret
}

func NewMarketHoursMarketInfoReads(es []*ent.MarketInfo) []MarketHoursMarketInfoRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]MarketHoursMarketInfoRead, len(es))
	for i, e := range es {
		r[i] = NewMarketHoursMarketInfoRead(e).Elem()
	}
	return r
}

func (mi *MarketHoursMarketInfoRead) Elem() MarketHoursMarketInfoRead {
	if mi == nil {
		return MarketHoursMarketInfoRead{}
	}
	return *mi
}

func NewMarketInfoCreate(e *ent.MarketInfo) *MarketInfoCreate {
	if e == nil {
		return nil
	}
	var ret MarketInfoCreate
	ret.ID = e.ID
	ret.HoursStart = e.HoursStart
	ret.HoursEnd = e.HoursEnd
	return &ret
}

func NewMarketInfoCreates(es []*ent.MarketInfo) []MarketInfoCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]MarketInfoCreate, len(es))
	for i, e := range es {
		r[i] = NewMarketInfoCreate(e).Elem()
	}
	return r
}

func (mi *MarketInfoCreate) Elem() MarketInfoCreate {
	if mi == nil {
		return MarketInfoCreate{}
	}
	return *mi
}

func NewMarketInfoList(e *ent.MarketInfo) *MarketInfoList {
	if e == nil {
		return nil
	}
	var ret MarketInfoList
	ret.ID = e.ID
	ret.HoursStart = e.HoursStart
	ret.HoursEnd = e.HoursEnd
	return &ret
}

func NewMarketInfoLists(es []*ent.MarketInfo) []MarketInfoList {
	if len(es) == 0 {
		return nil
	}
	r := make([]MarketInfoList, len(es))
	for i, e := range es {
		r[i] = NewMarketInfoList(e).Elem()
	}
	return r
}

func (mi *MarketInfoList) Elem() MarketInfoList {
	if mi == nil {
		return MarketInfoList{}
	}
	return *mi
}

func NewMarketInfoRead(e *ent.MarketInfo) *MarketInfoRead {
	if e == nil {
		return nil
	}
	var ret MarketInfoRead
	ret.ID = e.ID
	ret.HoursStart = e.HoursStart
	ret.HoursEnd = e.HoursEnd
	return &ret
}

func NewMarketInfoReads(es []*ent.MarketInfo) []MarketInfoRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]MarketInfoRead, len(es))
	for i, e := range es {
		r[i] = NewMarketInfoRead(e).Elem()
	}
	return r
}

func (mi *MarketInfoRead) Elem() MarketInfoRead {
	if mi == nil {
		return MarketInfoRead{}
	}
	return *mi
}

func NewMarketInfoUpdate(e *ent.MarketInfo) *MarketInfoUpdate {
	if e == nil {
		return nil
	}
	var ret MarketInfoUpdate
	ret.ID = e.ID
	ret.HoursStart = e.HoursStart
	ret.HoursEnd = e.HoursEnd
	return &ret
}

func NewMarketInfoUpdates(es []*ent.MarketInfo) []MarketInfoUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]MarketInfoUpdate, len(es))
	for i, e := range es {
		r[i] = NewMarketInfoUpdate(e).Elem()
	}
	return r
}

func (mi *MarketInfoUpdate) Elem() MarketInfoUpdate {
	if mi == nil {
		return MarketInfoUpdate{}
	}
	return *mi
}

func NewMarketInfoHoursList(e *ent.MarketHours) *MarketInfoHoursList {
	if e == nil {
		return nil
	}
	var ret MarketInfoHoursList
	ret.ID = e.ID
	ret.Date = e.Date
	ret.StartTime = e.StartTime
	ret.EndTime = e.EndTime
	return &ret
}

func NewMarketInfoHoursLists(es []*ent.MarketHours) []MarketInfoHoursList {
	if len(es) == 0 {
		return nil
	}
	r := make([]MarketInfoHoursList, len(es))
	for i, e := range es {
		r[i] = NewMarketInfoHoursList(e).Elem()
	}
	return r
}

func (mh *MarketInfoHoursList) Elem() MarketInfoHoursList {
	if mh == nil {
		return MarketInfoHoursList{}
	}
	return *mh
}

func NewSplitCreate(e *ent.Split) *SplitCreate {
	if e == nil {
		return nil
	}
	var ret SplitCreate
	ret.ID = e.ID
	ret.ExecutionDate = e.ExecutionDate
	ret.From = e.From
	ret.To = e.To
	return &ret
}

func NewSplitCreates(es []*ent.Split) []SplitCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]SplitCreate, len(es))
	for i, e := range es {
		r[i] = NewSplitCreate(e).Elem()
	}
	return r
}

func (s *SplitCreate) Elem() SplitCreate {
	if s == nil {
		return SplitCreate{}
	}
	return *s
}

func NewSplitList(e *ent.Split) *SplitList {
	if e == nil {
		return nil
	}
	var ret SplitList
	ret.ID = e.ID
	ret.ExecutionDate = e.ExecutionDate
	ret.From = e.From
	ret.To = e.To
	return &ret
}

func NewSplitLists(es []*ent.Split) []SplitList {
	if len(es) == 0 {
		return nil
	}
	r := make([]SplitList, len(es))
	for i, e := range es {
		r[i] = NewSplitList(e).Elem()
	}
	return r
}

func (s *SplitList) Elem() SplitList {
	if s == nil {
		return SplitList{}
	}
	return *s
}

func NewSplitRead(e *ent.Split) *SplitRead {
	if e == nil {
		return nil
	}
	var ret SplitRead
	ret.ID = e.ID
	ret.ExecutionDate = e.ExecutionDate
	ret.From = e.From
	ret.To = e.To
	return &ret
}

func NewSplitReads(es []*ent.Split) []SplitRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]SplitRead, len(es))
	for i, e := range es {
		r[i] = NewSplitRead(e).Elem()
	}
	return r
}

func (s *SplitRead) Elem() SplitRead {
	if s == nil {
		return SplitRead{}
	}
	return *s
}

func NewSplitUpdate(e *ent.Split) *SplitUpdate {
	if e == nil {
		return nil
	}
	var ret SplitUpdate
	ret.ID = e.ID
	ret.ExecutionDate = e.ExecutionDate
	ret.From = e.From
	ret.To = e.To
	return &ret
}

func NewSplitUpdates(es []*ent.Split) []SplitUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]SplitUpdate, len(es))
	for i, e := range es {
		r[i] = NewSplitUpdate(e).Elem()
	}
	return r
}

func (s *SplitUpdate) Elem() SplitUpdate {
	if s == nil {
		return SplitUpdate{}
	}
	return *s
}

func NewSplitStockRead(e *ent.Entity) *SplitStockRead {
	if e == nil {
		return nil
	}
	var ret SplitStockRead
	ret.ID = e.ID
	ret.Active = e.Active
	ret.Ticker = e.Ticker
	ret.Name = e.Name
	ret.Description = e.Description
	ret.ListDate = e.ListDate
	ret.Options = e.Options
	ret.Tradable = e.Tradable
	return &ret
}

func NewSplitStockReads(es []*ent.Entity) []SplitStockRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]SplitStockRead, len(es))
	for i, e := range es {
		r[i] = NewSplitStockRead(e).Elem()
	}
	return r
}

func (e *SplitStockRead) Elem() SplitStockRead {
	if e == nil {
		return SplitStockRead{}
	}
	return *e
}

func NewTradeConditionCreate(e *ent.TradeCondition) *TradeConditionCreate {
	if e == nil {
		return nil
	}
	var ret TradeConditionCreate
	ret.ID = e.ID
	ret.Condition = e.Condition
	return &ret
}

func NewTradeConditionCreates(es []*ent.TradeCondition) []TradeConditionCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeConditionCreate, len(es))
	for i, e := range es {
		r[i] = NewTradeConditionCreate(e).Elem()
	}
	return r
}

func (tc *TradeConditionCreate) Elem() TradeConditionCreate {
	if tc == nil {
		return TradeConditionCreate{}
	}
	return *tc
}

func NewTradeConditionList(e *ent.TradeCondition) *TradeConditionList {
	if e == nil {
		return nil
	}
	var ret TradeConditionList
	ret.ID = e.ID
	ret.Condition = e.Condition
	return &ret
}

func NewTradeConditionLists(es []*ent.TradeCondition) []TradeConditionList {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeConditionList, len(es))
	for i, e := range es {
		r[i] = NewTradeConditionList(e).Elem()
	}
	return r
}

func (tc *TradeConditionList) Elem() TradeConditionList {
	if tc == nil {
		return TradeConditionList{}
	}
	return *tc
}

func NewTradeConditionRead(e *ent.TradeCondition) *TradeConditionRead {
	if e == nil {
		return nil
	}
	var ret TradeConditionRead
	ret.ID = e.ID
	ret.Condition = e.Condition
	return &ret
}

func NewTradeConditionReads(es []*ent.TradeCondition) []TradeConditionRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeConditionRead, len(es))
	for i, e := range es {
		r[i] = NewTradeConditionRead(e).Elem()
	}
	return r
}

func (tc *TradeConditionRead) Elem() TradeConditionRead {
	if tc == nil {
		return TradeConditionRead{}
	}
	return *tc
}

func NewTradeConditionUpdate(e *ent.TradeCondition) *TradeConditionUpdate {
	if e == nil {
		return nil
	}
	var ret TradeConditionUpdate
	ret.ID = e.ID
	ret.Condition = e.Condition
	return &ret
}

func NewTradeConditionUpdates(es []*ent.TradeCondition) []TradeConditionUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeConditionUpdate, len(es))
	for i, e := range es {
		r[i] = NewTradeConditionUpdate(e).Elem()
	}
	return r
}

func (tc *TradeConditionUpdate) Elem() TradeConditionUpdate {
	if tc == nil {
		return TradeConditionUpdate{}
	}
	return *tc
}

func NewTradeConditionRecordList(e *ent.TradeRecord) *TradeConditionRecordList {
	if e == nil {
		return nil
	}
	var ret TradeConditionRecordList
	ret.ID = e.ID
	ret.Price = e.Price
	ret.Timestamp = e.Timestamp
	ret.Volume = e.Volume
	ret.TimeRangeID = e.TimeRangeID
	return &ret
}

func NewTradeConditionRecordLists(es []*ent.TradeRecord) []TradeConditionRecordList {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeConditionRecordList, len(es))
	for i, e := range es {
		r[i] = NewTradeConditionRecordList(e).Elem()
	}
	return r
}

func (tr *TradeConditionRecordList) Elem() TradeConditionRecordList {
	if tr == nil {
		return TradeConditionRecordList{}
	}
	return *tr
}

func NewTradeCorrectionCreate(e *ent.TradeCorrection) *TradeCorrectionCreate {
	if e == nil {
		return nil
	}
	var ret TradeCorrectionCreate
	ret.ID = e.ID
	ret.Correction = e.Correction
	return &ret
}

func NewTradeCorrectionCreates(es []*ent.TradeCorrection) []TradeCorrectionCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeCorrectionCreate, len(es))
	for i, e := range es {
		r[i] = NewTradeCorrectionCreate(e).Elem()
	}
	return r
}

func (tc *TradeCorrectionCreate) Elem() TradeCorrectionCreate {
	if tc == nil {
		return TradeCorrectionCreate{}
	}
	return *tc
}

func NewTradeCorrectionList(e *ent.TradeCorrection) *TradeCorrectionList {
	if e == nil {
		return nil
	}
	var ret TradeCorrectionList
	ret.ID = e.ID
	ret.Correction = e.Correction
	return &ret
}

func NewTradeCorrectionLists(es []*ent.TradeCorrection) []TradeCorrectionList {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeCorrectionList, len(es))
	for i, e := range es {
		r[i] = NewTradeCorrectionList(e).Elem()
	}
	return r
}

func (tc *TradeCorrectionList) Elem() TradeCorrectionList {
	if tc == nil {
		return TradeCorrectionList{}
	}
	return *tc
}

func NewTradeCorrectionRead(e *ent.TradeCorrection) *TradeCorrectionRead {
	if e == nil {
		return nil
	}
	var ret TradeCorrectionRead
	ret.ID = e.ID
	ret.Correction = e.Correction
	return &ret
}

func NewTradeCorrectionReads(es []*ent.TradeCorrection) []TradeCorrectionRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeCorrectionRead, len(es))
	for i, e := range es {
		r[i] = NewTradeCorrectionRead(e).Elem()
	}
	return r
}

func (tc *TradeCorrectionRead) Elem() TradeCorrectionRead {
	if tc == nil {
		return TradeCorrectionRead{}
	}
	return *tc
}

func NewTradeCorrectionUpdate(e *ent.TradeCorrection) *TradeCorrectionUpdate {
	if e == nil {
		return nil
	}
	var ret TradeCorrectionUpdate
	ret.ID = e.ID
	ret.Correction = e.Correction
	return &ret
}

func NewTradeCorrectionUpdates(es []*ent.TradeCorrection) []TradeCorrectionUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeCorrectionUpdate, len(es))
	for i, e := range es {
		r[i] = NewTradeCorrectionUpdate(e).Elem()
	}
	return r
}

func (tc *TradeCorrectionUpdate) Elem() TradeCorrectionUpdate {
	if tc == nil {
		return TradeCorrectionUpdate{}
	}
	return *tc
}

func NewTradeCorrectionRecordList(e *ent.TradeRecord) *TradeCorrectionRecordList {
	if e == nil {
		return nil
	}
	var ret TradeCorrectionRecordList
	ret.ID = e.ID
	ret.Price = e.Price
	ret.Timestamp = e.Timestamp
	ret.Volume = e.Volume
	ret.TimeRangeID = e.TimeRangeID
	return &ret
}

func NewTradeCorrectionRecordLists(es []*ent.TradeRecord) []TradeCorrectionRecordList {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeCorrectionRecordList, len(es))
	for i, e := range es {
		r[i] = NewTradeCorrectionRecordList(e).Elem()
	}
	return r
}

func (tr *TradeCorrectionRecordList) Elem() TradeCorrectionRecordList {
	if tr == nil {
		return TradeCorrectionRecordList{}
	}
	return *tr
}

func NewTradeRecordCreate(e *ent.TradeRecord) *TradeRecordCreate {
	if e == nil {
		return nil
	}
	var ret TradeRecordCreate
	ret.ID = e.ID
	ret.Price = e.Price
	ret.Timestamp = e.Timestamp
	ret.Volume = e.Volume
	ret.TimeRangeID = e.TimeRangeID
	return &ret
}

func NewTradeRecordCreates(es []*ent.TradeRecord) []TradeRecordCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeRecordCreate, len(es))
	for i, e := range es {
		r[i] = NewTradeRecordCreate(e).Elem()
	}
	return r
}

func (tr *TradeRecordCreate) Elem() TradeRecordCreate {
	if tr == nil {
		return TradeRecordCreate{}
	}
	return *tr
}

func NewTradeRecordList(e *ent.TradeRecord) *TradeRecordList {
	if e == nil {
		return nil
	}
	var ret TradeRecordList
	ret.ID = e.ID
	ret.Price = e.Price
	ret.Timestamp = e.Timestamp
	ret.Volume = e.Volume
	ret.TimeRangeID = e.TimeRangeID
	return &ret
}

func NewTradeRecordLists(es []*ent.TradeRecord) []TradeRecordList {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeRecordList, len(es))
	for i, e := range es {
		r[i] = NewTradeRecordList(e).Elem()
	}
	return r
}

func (tr *TradeRecordList) Elem() TradeRecordList {
	if tr == nil {
		return TradeRecordList{}
	}
	return *tr
}

func NewTradeRecordRead(e *ent.TradeRecord) *TradeRecordRead {
	if e == nil {
		return nil
	}
	var ret TradeRecordRead
	ret.ID = e.ID
	ret.Price = e.Price
	ret.Timestamp = e.Timestamp
	ret.Volume = e.Volume
	ret.TimeRangeID = e.TimeRangeID
	return &ret
}

func NewTradeRecordReads(es []*ent.TradeRecord) []TradeRecordRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeRecordRead, len(es))
	for i, e := range es {
		r[i] = NewTradeRecordRead(e).Elem()
	}
	return r
}

func (tr *TradeRecordRead) Elem() TradeRecordRead {
	if tr == nil {
		return TradeRecordRead{}
	}
	return *tr
}

func NewTradeRecordUpdate(e *ent.TradeRecord) *TradeRecordUpdate {
	if e == nil {
		return nil
	}
	var ret TradeRecordUpdate
	ret.ID = e.ID
	ret.Price = e.Price
	ret.Timestamp = e.Timestamp
	ret.Volume = e.Volume
	ret.TimeRangeID = e.TimeRangeID
	return &ret
}

func NewTradeRecordUpdates(es []*ent.TradeRecord) []TradeRecordUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeRecordUpdate, len(es))
	for i, e := range es {
		r[i] = NewTradeRecordUpdate(e).Elem()
	}
	return r
}

func (tr *TradeRecordUpdate) Elem() TradeRecordUpdate {
	if tr == nil {
		return TradeRecordUpdate{}
	}
	return *tr
}

func NewTradeRecordConditionsList(e *ent.TradeCondition) *TradeRecordConditionsList {
	if e == nil {
		return nil
	}
	var ret TradeRecordConditionsList
	ret.ID = e.ID
	ret.Condition = e.Condition
	return &ret
}

func NewTradeRecordConditionsLists(es []*ent.TradeCondition) []TradeRecordConditionsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeRecordConditionsList, len(es))
	for i, e := range es {
		r[i] = NewTradeRecordConditionsList(e).Elem()
	}
	return r
}

func (tc *TradeRecordConditionsList) Elem() TradeRecordConditionsList {
	if tc == nil {
		return TradeRecordConditionsList{}
	}
	return *tc
}

func NewTradeRecordCorrectionList(e *ent.TradeCorrection) *TradeRecordCorrectionList {
	if e == nil {
		return nil
	}
	var ret TradeRecordCorrectionList
	ret.ID = e.ID
	ret.Correction = e.Correction
	return &ret
}

func NewTradeRecordCorrectionLists(es []*ent.TradeCorrection) []TradeRecordCorrectionList {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeRecordCorrectionList, len(es))
	for i, e := range es {
		r[i] = NewTradeRecordCorrectionList(e).Elem()
	}
	return r
}

func (tc *TradeRecordCorrectionList) Elem() TradeRecordCorrectionList {
	if tc == nil {
		return TradeRecordCorrectionList{}
	}
	return *tc
}

func NewTradeRecordExchangeList(e *ent.Exchange) *TradeRecordExchangeList {
	if e == nil {
		return nil
	}
	var ret TradeRecordExchangeList
	ret.ID = e.ID
	ret.Code = e.Code
	ret.Name = e.Name
	return &ret
}

func NewTradeRecordExchangeLists(es []*ent.Exchange) []TradeRecordExchangeList {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeRecordExchangeList, len(es))
	for i, e := range es {
		r[i] = NewTradeRecordExchangeList(e).Elem()
	}
	return r
}

func (e *TradeRecordExchangeList) Elem() TradeRecordExchangeList {
	if e == nil {
		return TradeRecordExchangeList{}
	}
	return *e
}

func NewTradeRecordTimeRangeRead(e *ent.TradeTimeRange) *TradeRecordTimeRangeRead {
	if e == nil {
		return nil
	}
	var ret TradeRecordTimeRangeRead
	ret.ID = e.ID
	ret.Start = e.Start
	ret.End = e.End
	ret.IntervalID = e.IntervalID
	return &ret
}

func NewTradeRecordTimeRangeReads(es []*ent.TradeTimeRange) []TradeRecordTimeRangeRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeRecordTimeRangeRead, len(es))
	for i, e := range es {
		r[i] = NewTradeRecordTimeRangeRead(e).Elem()
	}
	return r
}

func (ttr *TradeRecordTimeRangeRead) Elem() TradeRecordTimeRangeRead {
	if ttr == nil {
		return TradeRecordTimeRangeRead{}
	}
	return *ttr
}

func NewTradeTimeRangeCreate(e *ent.TradeTimeRange) *TradeTimeRangeCreate {
	if e == nil {
		return nil
	}
	var ret TradeTimeRangeCreate
	ret.ID = e.ID
	ret.Start = e.Start
	ret.End = e.End
	ret.IntervalID = e.IntervalID
	return &ret
}

func NewTradeTimeRangeCreates(es []*ent.TradeTimeRange) []TradeTimeRangeCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeTimeRangeCreate, len(es))
	for i, e := range es {
		r[i] = NewTradeTimeRangeCreate(e).Elem()
	}
	return r
}

func (ttr *TradeTimeRangeCreate) Elem() TradeTimeRangeCreate {
	if ttr == nil {
		return TradeTimeRangeCreate{}
	}
	return *ttr
}

func NewTradeTimeRangeList(e *ent.TradeTimeRange) *TradeTimeRangeList {
	if e == nil {
		return nil
	}
	var ret TradeTimeRangeList
	ret.ID = e.ID
	ret.Start = e.Start
	ret.End = e.End
	ret.IntervalID = e.IntervalID
	return &ret
}

func NewTradeTimeRangeLists(es []*ent.TradeTimeRange) []TradeTimeRangeList {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeTimeRangeList, len(es))
	for i, e := range es {
		r[i] = NewTradeTimeRangeList(e).Elem()
	}
	return r
}

func (ttr *TradeTimeRangeList) Elem() TradeTimeRangeList {
	if ttr == nil {
		return TradeTimeRangeList{}
	}
	return *ttr
}

func NewTradeTimeRangeRead(e *ent.TradeTimeRange) *TradeTimeRangeRead {
	if e == nil {
		return nil
	}
	var ret TradeTimeRangeRead
	ret.ID = e.ID
	ret.Start = e.Start
	ret.End = e.End
	ret.IntervalID = e.IntervalID
	return &ret
}

func NewTradeTimeRangeReads(es []*ent.TradeTimeRange) []TradeTimeRangeRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeTimeRangeRead, len(es))
	for i, e := range es {
		r[i] = NewTradeTimeRangeRead(e).Elem()
	}
	return r
}

func (ttr *TradeTimeRangeRead) Elem() TradeTimeRangeRead {
	if ttr == nil {
		return TradeTimeRangeRead{}
	}
	return *ttr
}

func NewTradeTimeRangeUpdate(e *ent.TradeTimeRange) *TradeTimeRangeUpdate {
	if e == nil {
		return nil
	}
	var ret TradeTimeRangeUpdate
	ret.ID = e.ID
	ret.Start = e.Start
	ret.End = e.End
	ret.IntervalID = e.IntervalID
	return &ret
}

func NewTradeTimeRangeUpdates(es []*ent.TradeTimeRange) []TradeTimeRangeUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeTimeRangeUpdate, len(es))
	for i, e := range es {
		r[i] = NewTradeTimeRangeUpdate(e).Elem()
	}
	return r
}

func (ttr *TradeTimeRangeUpdate) Elem() TradeTimeRangeUpdate {
	if ttr == nil {
		return TradeTimeRangeUpdate{}
	}
	return *ttr
}

func NewTradeTimeRangeIntervalRead(e *ent.Interval) *TradeTimeRangeIntervalRead {
	if e == nil {
		return nil
	}
	var ret TradeTimeRangeIntervalRead
	ret.ID = e.ID
	ret.Active = e.Active
	ret.Interval = TradeTimeRangeIntervalReadInterval(e.Interval)
	ret.StockID = e.StockID
	ret.DataSourceID = e.DataSourceID
	return &ret
}

func NewTradeTimeRangeIntervalReads(es []*ent.Interval) []TradeTimeRangeIntervalRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeTimeRangeIntervalRead, len(es))
	for i, e := range es {
		r[i] = NewTradeTimeRangeIntervalRead(e).Elem()
	}
	return r
}

func (i *TradeTimeRangeIntervalRead) Elem() TradeTimeRangeIntervalRead {
	if i == nil {
		return TradeTimeRangeIntervalRead{}
	}
	return *i
}

func NewTradeTimeRangeRecordsList(e *ent.TradeRecord) *TradeTimeRangeRecordsList {
	if e == nil {
		return nil
	}
	var ret TradeTimeRangeRecordsList
	ret.ID = e.ID
	ret.Price = e.Price
	ret.Timestamp = e.Timestamp
	ret.Volume = e.Volume
	ret.TimeRangeID = e.TimeRangeID
	return &ret
}

func NewTradeTimeRangeRecordsLists(es []*ent.TradeRecord) []TradeTimeRangeRecordsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]TradeTimeRangeRecordsList, len(es))
	for i, e := range es {
		r[i] = NewTradeTimeRangeRecordsList(e).Elem()
	}
	return r
}

func (tr *TradeTimeRangeRecordsList) Elem() TradeTimeRangeRecordsList {
	if tr == nil {
		return TradeTimeRangeRecordsList{}
	}
	return *tr
}
