// Code generated by ogen, DO NOT EDIT.

package ogent

import (
	"net/http"
	"net/url"
	"strings"

	"github.com/ogen-go/ogen/uri"
)

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	if rawPath := r.URL.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
		}
	}
	if prefix := s.cfg.Prefix; len(prefix) > 0 {
		if strings.HasPrefix(elem, prefix) {
			// Cut prefix from the path.
			elem = strings.TrimPrefix(elem, prefix)
		} else {
			// Prefix doesn't match.
			s.notFound(w, r)
			return
		}
	}
	if len(elem) == 0 {
		s.notFound(w, r)
		return
	}
	args := [1]string{}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/rest/"
			if l := len("/rest/"); len(elem) >= l && elem[0:l] == "/rest/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'b': // Prefix: "bar-"
				if l := len("bar-"); len(elem) >= l && elem[0:l] == "bar-" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'g': // Prefix: "groups"
					if l := len("groups"); len(elem) >= l && elem[0:l] == "groups" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListBarGroupRequest([0]string{}, w, r)
						case "POST":
							s.handleCreateBarGroupRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteBarGroupRequest([1]string{
									args[0],
								}, w, r)
							case "GET":
								s.handleReadBarGroupRequest([1]string{
									args[0],
								}, w, r)
							case "PATCH":
								s.handleUpdateBarGroupRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PATCH")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'r': // Prefix: "records"
								if l := len("records"); len(elem) >= l && elem[0:l] == "records" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleListBarGroupRecordsRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 't': // Prefix: "time-range"
								if l := len("time-range"); len(elem) >= l && elem[0:l] == "time-range" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleReadBarGroupTimeRangeRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						}
					}
				case 'r': // Prefix: "records"
					if l := len("records"); len(elem) >= l && elem[0:l] == "records" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListBarRecordRequest([0]string{}, w, r)
						case "POST":
							s.handleCreateBarRecordRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteBarRecordRequest([1]string{
									args[0],
								}, w, r)
							case "GET":
								s.handleReadBarRecordRequest([1]string{
									args[0],
								}, w, r)
							case "PATCH":
								s.handleUpdateBarRecordRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PATCH")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/group"
							if l := len("/group"); len(elem) >= l && elem[0:l] == "/group" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleReadBarRecordGroupRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
					}
				case 't': // Prefix: "time-ranges"
					if l := len("time-ranges"); len(elem) >= l && elem[0:l] == "time-ranges" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListBarTimeRangeRequest([0]string{}, w, r)
						case "POST":
							s.handleCreateBarTimeRangeRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteBarTimeRangeRequest([1]string{
									args[0],
								}, w, r)
							case "GET":
								s.handleReadBarTimeRangeRequest([1]string{
									args[0],
								}, w, r)
							case "PATCH":
								s.handleUpdateBarTimeRangeRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PATCH")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'g': // Prefix: "groups"
								if l := len("groups"); len(elem) >= l && elem[0:l] == "groups" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleListBarTimeRangeGroupsRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 'i': // Prefix: "interval"
								if l := len("interval"); len(elem) >= l && elem[0:l] == "interval" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleReadBarTimeRangeIntervalRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						}
					}
				}
			case 'd': // Prefix: "d"
				if l := len("d"); len(elem) >= l && elem[0:l] == "d" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "ata-sources"
					if l := len("ata-sources"); len(elem) >= l && elem[0:l] == "ata-sources" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListDataSourceRequest([0]string{}, w, r)
						case "POST":
							s.handleCreateDataSourceRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteDataSourceRequest([1]string{
									args[0],
								}, w, r)
							case "GET":
								s.handleReadDataSourceRequest([1]string{
									args[0],
								}, w, r)
							case "PATCH":
								s.handleUpdateDataSourceRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PATCH")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/intervals"
							if l := len("/intervals"); len(elem) >= l && elem[0:l] == "/intervals" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleListDataSourceIntervalsRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
					}
				case 'i': // Prefix: "ividends"
					if l := len("ividends"); len(elem) >= l && elem[0:l] == "ividends" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListDividendRequest([0]string{}, w, r)
						case "POST":
							s.handleCreateDividendRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteDividendRequest([1]string{
									args[0],
								}, w, r)
							case "GET":
								s.handleReadDividendRequest([1]string{
									args[0],
								}, w, r)
							case "PATCH":
								s.handleUpdateDividendRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PATCH")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/stock"
							if l := len("/stock"); len(elem) >= l && elem[0:l] == "/stock" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleListDividendStockRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
					}
				}
			case 'e': // Prefix: "e"
				if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'n': // Prefix: "ntities"
					if l := len("ntities"); len(elem) >= l && elem[0:l] == "ntities" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListEntityRequest([0]string{}, w, r)
						case "POST":
							s.handleCreateEntityRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "add/"
							if l := len("add/"); len(elem) >= l && elem[0:l] == "add/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "ticker"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleAddTickerRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
						}
						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteEntityRequest([1]string{
									args[0],
								}, w, r)
							case "GET":
								s.handleReadEntityRequest([1]string{
									args[0],
								}, w, r)
							case "PATCH":
								s.handleUpdateEntityRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PATCH")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'd': // Prefix: "dividends"
								if l := len("dividends"); len(elem) >= l && elem[0:l] == "dividends" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleListEntityDividendsRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 'e': // Prefix: "exchanges"
								if l := len("exchanges"); len(elem) >= l && elem[0:l] == "exchanges" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleListEntityExchangesRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 'f': // Prefix: "financials"
								if l := len("financials"); len(elem) >= l && elem[0:l] == "financials" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleListEntityFinancialsRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 'i': // Prefix: "intervals"
								if l := len("intervals"); len(elem) >= l && elem[0:l] == "intervals" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleListEntityIntervalsRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 's': // Prefix: "splits"
								if l := len("splits"); len(elem) >= l && elem[0:l] == "splits" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleListEntitySplitsRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						}
					}
				case 'x': // Prefix: "xchanges"
					if l := len("xchanges"); len(elem) >= l && elem[0:l] == "xchanges" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListExchangeRequest([0]string{}, w, r)
						case "POST":
							s.handleCreateExchangeRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteExchangeRequest([1]string{
									args[0],
								}, w, r)
							case "GET":
								s.handleReadExchangeRequest([1]string{
									args[0],
								}, w, r)
							case "PATCH":
								s.handleUpdateExchangeRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PATCH")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/stocks"
							if l := len("/stocks"); len(elem) >= l && elem[0:l] == "/stocks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleListExchangeStocksRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
					}
				}
			case 'f': // Prefix: "financials"
				if l := len("financials"); len(elem) >= l && elem[0:l] == "financials" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleListFinancialRequest([0]string{}, w, r)
					case "POST":
						s.handleCreateFinancialRequest([0]string{}, w, r)
					default:
						s.notAllowed(w, r, "GET,POST")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch r.Method {
						case "DELETE":
							s.handleDeleteFinancialRequest([1]string{
								args[0],
							}, w, r)
						case "GET":
							s.handleReadFinancialRequest([1]string{
								args[0],
							}, w, r)
						case "PATCH":
							s.handleUpdateFinancialRequest([1]string{
								args[0],
							}, w, r)
						default:
							s.notAllowed(w, r, "DELETE,GET,PATCH")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/stock"
						if l := len("/stock"); len(elem) >= l && elem[0:l] == "/stock" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleListFinancialStockRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
					}
				}
			case 'i': // Prefix: "intervals"
				if l := len("intervals"); len(elem) >= l && elem[0:l] == "intervals" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleListIntervalRequest([0]string{}, w, r)
					case "POST":
						s.handleCreateIntervalRequest([0]string{}, w, r)
					default:
						s.notAllowed(w, r, "GET,POST")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch r.Method {
						case "DELETE":
							s.handleDeleteIntervalRequest([1]string{
								args[0],
							}, w, r)
						case "GET":
							s.handleReadIntervalRequest([1]string{
								args[0],
							}, w, r)
						case "PATCH":
							s.handleUpdateIntervalRequest([1]string{
								args[0],
							}, w, r)
						default:
							s.notAllowed(w, r, "DELETE,GET,PATCH")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'b': // Prefix: "bars"
							if l := len("bars"); len(elem) >= l && elem[0:l] == "bars" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleListIntervalBarsRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						case 'd': // Prefix: "data-source"
							if l := len("data-source"); len(elem) >= l && elem[0:l] == "data-source" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleReadIntervalDataSourceRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						case 's': // Prefix: "stock"
							if l := len("stock"); len(elem) >= l && elem[0:l] == "stock" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleReadIntervalStockRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						case 't': // Prefix: "trades"
							if l := len("trades"); len(elem) >= l && elem[0:l] == "trades" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleListIntervalTradesRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
					}
				}
			case 'm': // Prefix: "market-"
				if l := len("market-"); len(elem) >= l && elem[0:l] == "market-" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'h': // Prefix: "hours"
					if l := len("hours"); len(elem) >= l && elem[0:l] == "hours" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListMarketHoursRequest([0]string{}, w, r)
						case "POST":
							s.handleCreateMarketHoursRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteMarketHoursRequest([1]string{
									args[0],
								}, w, r)
							case "GET":
								s.handleReadMarketHoursRequest([1]string{
									args[0],
								}, w, r)
							case "PATCH":
								s.handleUpdateMarketHoursRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PATCH")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/market-info"
							if l := len("/market-info"); len(elem) >= l && elem[0:l] == "/market-info" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleReadMarketHoursMarketInfoRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
					}
				case 'i': // Prefix: "infos"
					if l := len("infos"); len(elem) >= l && elem[0:l] == "infos" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListMarketInfoRequest([0]string{}, w, r)
						case "POST":
							s.handleCreateMarketInfoRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteMarketInfoRequest([1]string{
									args[0],
								}, w, r)
							case "GET":
								s.handleReadMarketInfoRequest([1]string{
									args[0],
								}, w, r)
							case "PATCH":
								s.handleUpdateMarketInfoRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PATCH")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/hours"
							if l := len("/hours"); len(elem) >= l && elem[0:l] == "/hours" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleListMarketInfoHoursRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
					}
				}
			case 's': // Prefix: "s"
				if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'e': // Prefix: "earch/"
					if l := len("earch/"); len(elem) >= l && elem[0:l] == "earch/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "ticker"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleSearchTickerRequest([1]string{
								args[0],
							}, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
				case 'p': // Prefix: "plits"
					if l := len("plits"); len(elem) >= l && elem[0:l] == "plits" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListSplitRequest([0]string{}, w, r)
						case "POST":
							s.handleCreateSplitRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteSplitRequest([1]string{
									args[0],
								}, w, r)
							case "GET":
								s.handleReadSplitRequest([1]string{
									args[0],
								}, w, r)
							case "PATCH":
								s.handleUpdateSplitRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PATCH")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/stock"
							if l := len("/stock"); len(elem) >= l && elem[0:l] == "/stock" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleReadSplitStockRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
					}
				}
			case 't': // Prefix: "trade-"
				if l := len("trade-"); len(elem) >= l && elem[0:l] == "trade-" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "co"
					if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'n': // Prefix: "nditions"
						if l := len("nditions"); len(elem) >= l && elem[0:l] == "nditions" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleListTradeConditionRequest([0]string{}, w, r)
							case "POST":
								s.handleCreateTradeConditionRequest([0]string{}, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleDeleteTradeConditionRequest([1]string{
										args[0],
									}, w, r)
								case "GET":
									s.handleReadTradeConditionRequest([1]string{
										args[0],
									}, w, r)
								case "PATCH":
									s.handleUpdateTradeConditionRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,PATCH")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/record"
								if l := len("/record"); len(elem) >= l && elem[0:l] == "/record" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleListTradeConditionRecordRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						}
					case 'r': // Prefix: "rrections"
						if l := len("rrections"); len(elem) >= l && elem[0:l] == "rrections" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleListTradeCorrectionRequest([0]string{}, w, r)
							case "POST":
								s.handleCreateTradeCorrectionRequest([0]string{}, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleDeleteTradeCorrectionRequest([1]string{
										args[0],
									}, w, r)
								case "GET":
									s.handleReadTradeCorrectionRequest([1]string{
										args[0],
									}, w, r)
								case "PATCH":
									s.handleUpdateTradeCorrectionRequest([1]string{
										args[0],
									}, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,PATCH")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/record"
								if l := len("/record"); len(elem) >= l && elem[0:l] == "/record" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleListTradeCorrectionRecordRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						}
					}
				case 'r': // Prefix: "records"
					if l := len("records"); len(elem) >= l && elem[0:l] == "records" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListTradeRecordRequest([0]string{}, w, r)
						case "POST":
							s.handleCreateTradeRecordRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteTradeRecordRequest([1]string{
									args[0],
								}, w, r)
							case "GET":
								s.handleReadTradeRecordRequest([1]string{
									args[0],
								}, w, r)
							case "PATCH":
								s.handleUpdateTradeRecordRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PATCH")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "co"
								if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'n': // Prefix: "nditions"
									if l := len("nditions"); len(elem) >= l && elem[0:l] == "nditions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleListTradeRecordConditionsRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
								case 'r': // Prefix: "rrection"
									if l := len("rrection"); len(elem) >= l && elem[0:l] == "rrection" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleListTradeRecordCorrectionRequest([1]string{
												args[0],
											}, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
								}
							case 'e': // Prefix: "exchange"
								if l := len("exchange"); len(elem) >= l && elem[0:l] == "exchange" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleListTradeRecordExchangeRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 't': // Prefix: "time-range"
								if l := len("time-range"); len(elem) >= l && elem[0:l] == "time-range" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleReadTradeRecordTimeRangeRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						}
					}
				case 't': // Prefix: "time-ranges"
					if l := len("time-ranges"); len(elem) >= l && elem[0:l] == "time-ranges" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListTradeTimeRangeRequest([0]string{}, w, r)
						case "POST":
							s.handleCreateTradeTimeRangeRequest([0]string{}, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteTradeTimeRangeRequest([1]string{
									args[0],
								}, w, r)
							case "GET":
								s.handleReadTradeTimeRangeRequest([1]string{
									args[0],
								}, w, r)
							case "PATCH":
								s.handleUpdateTradeTimeRangeRequest([1]string{
									args[0],
								}, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PATCH")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'i': // Prefix: "interval"
								if l := len("interval"); len(elem) >= l && elem[0:l] == "interval" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleReadTradeTimeRangeIntervalRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 'r': // Prefix: "records"
								if l := len("records"); len(elem) >= l && elem[0:l] == "records" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleListTradeTimeRangeRecordsRequest([1]string{
											args[0],
										}, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						}
					}
				}
			}
		}
	}
	s.notFound(w, r)
}

// Route is route object.
type Route struct {
	name        string
	operationID string
	count       int
	args        [1]string
}

// Name returns ogen operation name.
//
// It is guaranteed to be unique and not empty.
func (r Route) Name() string {
	return r.name
}

// OperationID returns OpenAPI operationId.
func (r Route) OperationID() string {
	return r.operationID
}

// Args returns parsed arguments.
func (r Route) Args() []string {
	return r.args[:r.count]
}

// FindRoute finds Route for given method and path.
//
// Note: this method does not unescape path or handle reserved characters in path properly. Use FindPath instead.
func (s *Server) FindRoute(method, path string) (Route, bool) {
	return s.FindPath(method, &url.URL{Path: path})
}

// FindPath finds Route for given method and URL.
func (s *Server) FindPath(method string, u *url.URL) (r Route, _ bool) {
	var (
		elem = u.Path
		args = r.args
	)
	if rawPath := u.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
		}
		defer func() {
			for i, arg := range r.args[:r.count] {
				if unescaped, err := url.PathUnescape(arg); err == nil {
					r.args[i] = unescaped
				}
			}
		}()
	}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/rest/"
			if l := len("/rest/"); len(elem) >= l && elem[0:l] == "/rest/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'b': // Prefix: "bar-"
				if l := len("bar-"); len(elem) >= l && elem[0:l] == "bar-" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'g': // Prefix: "groups"
					if l := len("groups"); len(elem) >= l && elem[0:l] == "groups" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListBarGroup"
							r.operationID = "listBarGroup"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateBarGroup"
							r.operationID = "createBarGroup"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteBarGroup"
								r.operationID = "deleteBarGroup"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "ReadBarGroup"
								r.operationID = "readBarGroup"
								r.args = args
								r.count = 1
								return r, true
							case "PATCH":
								r.name = "UpdateBarGroup"
								r.operationID = "updateBarGroup"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'r': // Prefix: "records"
								if l := len("records"); len(elem) >= l && elem[0:l] == "records" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: ListBarGroupRecords
										r.name = "ListBarGroupRecords"
										r.operationID = "listBarGroupRecords"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 't': // Prefix: "time-range"
								if l := len("time-range"); len(elem) >= l && elem[0:l] == "time-range" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: ReadBarGroupTimeRange
										r.name = "ReadBarGroupTimeRange"
										r.operationID = "readBarGroupTimeRange"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						}
					}
				case 'r': // Prefix: "records"
					if l := len("records"); len(elem) >= l && elem[0:l] == "records" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListBarRecord"
							r.operationID = "listBarRecord"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateBarRecord"
							r.operationID = "createBarRecord"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteBarRecord"
								r.operationID = "deleteBarRecord"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "ReadBarRecord"
								r.operationID = "readBarRecord"
								r.args = args
								r.count = 1
								return r, true
							case "PATCH":
								r.name = "UpdateBarRecord"
								r.operationID = "updateBarRecord"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/group"
							if l := len("/group"); len(elem) >= l && elem[0:l] == "/group" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ReadBarRecordGroup
									r.name = "ReadBarRecordGroup"
									r.operationID = "readBarRecordGroup"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					}
				case 't': // Prefix: "time-ranges"
					if l := len("time-ranges"); len(elem) >= l && elem[0:l] == "time-ranges" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListBarTimeRange"
							r.operationID = "listBarTimeRange"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateBarTimeRange"
							r.operationID = "createBarTimeRange"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteBarTimeRange"
								r.operationID = "deleteBarTimeRange"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "ReadBarTimeRange"
								r.operationID = "readBarTimeRange"
								r.args = args
								r.count = 1
								return r, true
							case "PATCH":
								r.name = "UpdateBarTimeRange"
								r.operationID = "updateBarTimeRange"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'g': // Prefix: "groups"
								if l := len("groups"); len(elem) >= l && elem[0:l] == "groups" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: ListBarTimeRangeGroups
										r.name = "ListBarTimeRangeGroups"
										r.operationID = "listBarTimeRangeGroups"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 'i': // Prefix: "interval"
								if l := len("interval"); len(elem) >= l && elem[0:l] == "interval" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: ReadBarTimeRangeInterval
										r.name = "ReadBarTimeRangeInterval"
										r.operationID = "readBarTimeRangeInterval"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						}
					}
				}
			case 'd': // Prefix: "d"
				if l := len("d"); len(elem) >= l && elem[0:l] == "d" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "ata-sources"
					if l := len("ata-sources"); len(elem) >= l && elem[0:l] == "ata-sources" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListDataSource"
							r.operationID = "listDataSource"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateDataSource"
							r.operationID = "createDataSource"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteDataSource"
								r.operationID = "deleteDataSource"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "ReadDataSource"
								r.operationID = "readDataSource"
								r.args = args
								r.count = 1
								return r, true
							case "PATCH":
								r.name = "UpdateDataSource"
								r.operationID = "updateDataSource"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/intervals"
							if l := len("/intervals"); len(elem) >= l && elem[0:l] == "/intervals" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ListDataSourceIntervals
									r.name = "ListDataSourceIntervals"
									r.operationID = "listDataSourceIntervals"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					}
				case 'i': // Prefix: "ividends"
					if l := len("ividends"); len(elem) >= l && elem[0:l] == "ividends" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListDividend"
							r.operationID = "listDividend"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateDividend"
							r.operationID = "createDividend"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteDividend"
								r.operationID = "deleteDividend"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "ReadDividend"
								r.operationID = "readDividend"
								r.args = args
								r.count = 1
								return r, true
							case "PATCH":
								r.name = "UpdateDividend"
								r.operationID = "updateDividend"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/stock"
							if l := len("/stock"); len(elem) >= l && elem[0:l] == "/stock" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ListDividendStock
									r.name = "ListDividendStock"
									r.operationID = "listDividendStock"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					}
				}
			case 'e': // Prefix: "e"
				if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'n': // Prefix: "ntities"
					if l := len("ntities"); len(elem) >= l && elem[0:l] == "ntities" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListEntity"
							r.operationID = "listEntity"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateEntity"
							r.operationID = "createEntity"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'a': // Prefix: "add/"
							if l := len("add/"); len(elem) >= l && elem[0:l] == "add/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "ticker"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "POST":
									// Leaf: AddTicker
									r.name = "AddTicker"
									r.operationID = "addTicker"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteEntity"
								r.operationID = "deleteEntity"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "ReadEntity"
								r.operationID = "readEntity"
								r.args = args
								r.count = 1
								return r, true
							case "PATCH":
								r.name = "UpdateEntity"
								r.operationID = "updateEntity"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'd': // Prefix: "dividends"
								if l := len("dividends"); len(elem) >= l && elem[0:l] == "dividends" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: ListEntityDividends
										r.name = "ListEntityDividends"
										r.operationID = "listEntityDividends"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 'e': // Prefix: "exchanges"
								if l := len("exchanges"); len(elem) >= l && elem[0:l] == "exchanges" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: ListEntityExchanges
										r.name = "ListEntityExchanges"
										r.operationID = "listEntityExchanges"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 'f': // Prefix: "financials"
								if l := len("financials"); len(elem) >= l && elem[0:l] == "financials" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: ListEntityFinancials
										r.name = "ListEntityFinancials"
										r.operationID = "listEntityFinancials"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 'i': // Prefix: "intervals"
								if l := len("intervals"); len(elem) >= l && elem[0:l] == "intervals" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: ListEntityIntervals
										r.name = "ListEntityIntervals"
										r.operationID = "listEntityIntervals"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 's': // Prefix: "splits"
								if l := len("splits"); len(elem) >= l && elem[0:l] == "splits" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: ListEntitySplits
										r.name = "ListEntitySplits"
										r.operationID = "listEntitySplits"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						}
					}
				case 'x': // Prefix: "xchanges"
					if l := len("xchanges"); len(elem) >= l && elem[0:l] == "xchanges" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListExchange"
							r.operationID = "listExchange"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateExchange"
							r.operationID = "createExchange"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteExchange"
								r.operationID = "deleteExchange"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "ReadExchange"
								r.operationID = "readExchange"
								r.args = args
								r.count = 1
								return r, true
							case "PATCH":
								r.name = "UpdateExchange"
								r.operationID = "updateExchange"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/stocks"
							if l := len("/stocks"); len(elem) >= l && elem[0:l] == "/stocks" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ListExchangeStocks
									r.name = "ListExchangeStocks"
									r.operationID = "listExchangeStocks"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					}
				}
			case 'f': // Prefix: "financials"
				if l := len("financials"); len(elem) >= l && elem[0:l] == "financials" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = "ListFinancial"
						r.operationID = "listFinancial"
						r.args = args
						r.count = 0
						return r, true
					case "POST":
						r.name = "CreateFinancial"
						r.operationID = "createFinancial"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch method {
						case "DELETE":
							r.name = "DeleteFinancial"
							r.operationID = "deleteFinancial"
							r.args = args
							r.count = 1
							return r, true
						case "GET":
							r.name = "ReadFinancial"
							r.operationID = "readFinancial"
							r.args = args
							r.count = 1
							return r, true
						case "PATCH":
							r.name = "UpdateFinancial"
							r.operationID = "updateFinancial"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/stock"
						if l := len("/stock"); len(elem) >= l && elem[0:l] == "/stock" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: ListFinancialStock
								r.name = "ListFinancialStock"
								r.operationID = "listFinancialStock"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
					}
				}
			case 'i': // Prefix: "intervals"
				if l := len("intervals"); len(elem) >= l && elem[0:l] == "intervals" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = "ListInterval"
						r.operationID = "listInterval"
						r.args = args
						r.count = 0
						return r, true
					case "POST":
						r.name = "CreateInterval"
						r.operationID = "createInterval"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch method {
						case "DELETE":
							r.name = "DeleteInterval"
							r.operationID = "deleteInterval"
							r.args = args
							r.count = 1
							return r, true
						case "GET":
							r.name = "ReadInterval"
							r.operationID = "readInterval"
							r.args = args
							r.count = 1
							return r, true
						case "PATCH":
							r.name = "UpdateInterval"
							r.operationID = "updateInterval"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'b': // Prefix: "bars"
							if l := len("bars"); len(elem) >= l && elem[0:l] == "bars" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ListIntervalBars
									r.name = "ListIntervalBars"
									r.operationID = "listIntervalBars"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						case 'd': // Prefix: "data-source"
							if l := len("data-source"); len(elem) >= l && elem[0:l] == "data-source" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ReadIntervalDataSource
									r.name = "ReadIntervalDataSource"
									r.operationID = "readIntervalDataSource"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						case 's': // Prefix: "stock"
							if l := len("stock"); len(elem) >= l && elem[0:l] == "stock" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ReadIntervalStock
									r.name = "ReadIntervalStock"
									r.operationID = "readIntervalStock"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						case 't': // Prefix: "trades"
							if l := len("trades"); len(elem) >= l && elem[0:l] == "trades" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ListIntervalTrades
									r.name = "ListIntervalTrades"
									r.operationID = "listIntervalTrades"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					}
				}
			case 'm': // Prefix: "market-"
				if l := len("market-"); len(elem) >= l && elem[0:l] == "market-" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'h': // Prefix: "hours"
					if l := len("hours"); len(elem) >= l && elem[0:l] == "hours" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListMarketHours"
							r.operationID = "listMarketHours"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateMarketHours"
							r.operationID = "createMarketHours"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteMarketHours"
								r.operationID = "deleteMarketHours"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "ReadMarketHours"
								r.operationID = "readMarketHours"
								r.args = args
								r.count = 1
								return r, true
							case "PATCH":
								r.name = "UpdateMarketHours"
								r.operationID = "updateMarketHours"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/market-info"
							if l := len("/market-info"); len(elem) >= l && elem[0:l] == "/market-info" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ReadMarketHoursMarketInfo
									r.name = "ReadMarketHoursMarketInfo"
									r.operationID = "readMarketHoursMarketInfo"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					}
				case 'i': // Prefix: "infos"
					if l := len("infos"); len(elem) >= l && elem[0:l] == "infos" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListMarketInfo"
							r.operationID = "listMarketInfo"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateMarketInfo"
							r.operationID = "createMarketInfo"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteMarketInfo"
								r.operationID = "deleteMarketInfo"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "ReadMarketInfo"
								r.operationID = "readMarketInfo"
								r.args = args
								r.count = 1
								return r, true
							case "PATCH":
								r.name = "UpdateMarketInfo"
								r.operationID = "updateMarketInfo"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/hours"
							if l := len("/hours"); len(elem) >= l && elem[0:l] == "/hours" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ListMarketInfoHours
									r.name = "ListMarketInfoHours"
									r.operationID = "listMarketInfoHours"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					}
				}
			case 's': // Prefix: "s"
				if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'e': // Prefix: "earch/"
					if l := len("earch/"); len(elem) >= l && elem[0:l] == "earch/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "ticker"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						switch method {
						case "GET":
							// Leaf: SearchTicker
							r.name = "SearchTicker"
							r.operationID = "searchTicker"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
				case 'p': // Prefix: "plits"
					if l := len("plits"); len(elem) >= l && elem[0:l] == "plits" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListSplit"
							r.operationID = "listSplit"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateSplit"
							r.operationID = "createSplit"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteSplit"
								r.operationID = "deleteSplit"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "ReadSplit"
								r.operationID = "readSplit"
								r.args = args
								r.count = 1
								return r, true
							case "PATCH":
								r.name = "UpdateSplit"
								r.operationID = "updateSplit"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/stock"
							if l := len("/stock"); len(elem) >= l && elem[0:l] == "/stock" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ReadSplitStock
									r.name = "ReadSplitStock"
									r.operationID = "readSplitStock"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					}
				}
			case 't': // Prefix: "trade-"
				if l := len("trade-"); len(elem) >= l && elem[0:l] == "trade-" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "co"
					if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'n': // Prefix: "nditions"
						if l := len("nditions"); len(elem) >= l && elem[0:l] == "nditions" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "ListTradeCondition"
								r.operationID = "listTradeCondition"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = "CreateTradeCondition"
								r.operationID = "createTradeCondition"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = "DeleteTradeCondition"
									r.operationID = "deleteTradeCondition"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									r.name = "ReadTradeCondition"
									r.operationID = "readTradeCondition"
									r.args = args
									r.count = 1
									return r, true
								case "PATCH":
									r.name = "UpdateTradeCondition"
									r.operationID = "updateTradeCondition"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/record"
								if l := len("/record"); len(elem) >= l && elem[0:l] == "/record" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: ListTradeConditionRecord
										r.name = "ListTradeConditionRecord"
										r.operationID = "listTradeConditionRecord"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						}
					case 'r': // Prefix: "rrections"
						if l := len("rrections"); len(elem) >= l && elem[0:l] == "rrections" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "ListTradeCorrection"
								r.operationID = "listTradeCorrection"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = "CreateTradeCorrection"
								r.operationID = "createTradeCorrection"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = "DeleteTradeCorrection"
									r.operationID = "deleteTradeCorrection"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									r.name = "ReadTradeCorrection"
									r.operationID = "readTradeCorrection"
									r.args = args
									r.count = 1
									return r, true
								case "PATCH":
									r.name = "UpdateTradeCorrection"
									r.operationID = "updateTradeCorrection"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/record"
								if l := len("/record"); len(elem) >= l && elem[0:l] == "/record" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: ListTradeCorrectionRecord
										r.name = "ListTradeCorrectionRecord"
										r.operationID = "listTradeCorrectionRecord"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						}
					}
				case 'r': // Prefix: "records"
					if l := len("records"); len(elem) >= l && elem[0:l] == "records" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListTradeRecord"
							r.operationID = "listTradeRecord"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateTradeRecord"
							r.operationID = "createTradeRecord"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteTradeRecord"
								r.operationID = "deleteTradeRecord"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "ReadTradeRecord"
								r.operationID = "readTradeRecord"
								r.args = args
								r.count = 1
								return r, true
							case "PATCH":
								r.name = "UpdateTradeRecord"
								r.operationID = "updateTradeRecord"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'c': // Prefix: "co"
								if l := len("co"); len(elem) >= l && elem[0:l] == "co" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'n': // Prefix: "nditions"
									if l := len("nditions"); len(elem) >= l && elem[0:l] == "nditions" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: ListTradeRecordConditions
											r.name = "ListTradeRecordConditions"
											r.operationID = "listTradeRecordConditions"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								case 'r': // Prefix: "rrection"
									if l := len("rrection"); len(elem) >= l && elem[0:l] == "rrection" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: ListTradeRecordCorrection
											r.name = "ListTradeRecordCorrection"
											r.operationID = "listTradeRecordCorrection"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								}
							case 'e': // Prefix: "exchange"
								if l := len("exchange"); len(elem) >= l && elem[0:l] == "exchange" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: ListTradeRecordExchange
										r.name = "ListTradeRecordExchange"
										r.operationID = "listTradeRecordExchange"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 't': // Prefix: "time-range"
								if l := len("time-range"); len(elem) >= l && elem[0:l] == "time-range" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: ReadTradeRecordTimeRange
										r.name = "ReadTradeRecordTimeRange"
										r.operationID = "readTradeRecordTimeRange"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						}
					}
				case 't': // Prefix: "time-ranges"
					if l := len("time-ranges"); len(elem) >= l && elem[0:l] == "time-ranges" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListTradeTimeRange"
							r.operationID = "listTradeTimeRange"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateTradeTimeRange"
							r.operationID = "createTradeTimeRange"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteTradeTimeRange"
								r.operationID = "deleteTradeTimeRange"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "ReadTradeTimeRange"
								r.operationID = "readTradeTimeRange"
								r.args = args
								r.count = 1
								return r, true
							case "PATCH":
								r.name = "UpdateTradeTimeRange"
								r.operationID = "updateTradeTimeRange"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'i': // Prefix: "interval"
								if l := len("interval"); len(elem) >= l && elem[0:l] == "interval" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: ReadTradeTimeRangeInterval
										r.name = "ReadTradeTimeRangeInterval"
										r.operationID = "readTradeTimeRangeInterval"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 'r': // Prefix: "records"
								if l := len("records"); len(elem) >= l && elem[0:l] == "records" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: ListTradeTimeRangeRecords
										r.name = "ListTradeTimeRangeRecords"
										r.operationID = "listTradeTimeRangeRecords"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return r, false
}
