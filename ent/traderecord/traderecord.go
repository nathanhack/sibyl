// Code generated by ent, DO NOT EDIT.

package traderecord

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the traderecord type in the database.
	Label = "trade_record"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldPrice holds the string denoting the price field in the database.
	FieldPrice = "price"
	// FieldTimestamp holds the string denoting the timestamp field in the database.
	FieldTimestamp = "timestamp"
	// FieldVolume holds the string denoting the volume field in the database.
	FieldVolume = "volume"
	// FieldTimeRangeID holds the string denoting the time_range_id field in the database.
	FieldTimeRangeID = "time_range_id"
	// EdgeTimeRange holds the string denoting the time_range edge name in mutations.
	EdgeTimeRange = "time_range"
	// EdgeConditions holds the string denoting the conditions edge name in mutations.
	EdgeConditions = "conditions"
	// EdgeCorrection holds the string denoting the correction edge name in mutations.
	EdgeCorrection = "correction"
	// EdgeExchange holds the string denoting the exchange edge name in mutations.
	EdgeExchange = "exchange"
	// Table holds the table name of the traderecord in the database.
	Table = "trade_records"
	// TimeRangeTable is the table that holds the time_range relation/edge.
	TimeRangeTable = "trade_records"
	// TimeRangeInverseTable is the table name for the TradeTimeRange entity.
	// It exists in this package in order to avoid circular dependency with the "tradetimerange" package.
	TimeRangeInverseTable = "trade_time_ranges"
	// TimeRangeColumn is the table column denoting the time_range relation/edge.
	TimeRangeColumn = "time_range_id"
	// ConditionsTable is the table that holds the conditions relation/edge. The primary key declared below.
	ConditionsTable = "trade_record_conditions"
	// ConditionsInverseTable is the table name for the TradeCondition entity.
	// It exists in this package in order to avoid circular dependency with the "tradecondition" package.
	ConditionsInverseTable = "trade_conditions"
	// CorrectionTable is the table that holds the correction relation/edge. The primary key declared below.
	CorrectionTable = "trade_record_correction"
	// CorrectionInverseTable is the table name for the TradeCorrection entity.
	// It exists in this package in order to avoid circular dependency with the "tradecorrection" package.
	CorrectionInverseTable = "trade_corrections"
	// ExchangeTable is the table that holds the exchange relation/edge.
	ExchangeTable = "exchanges"
	// ExchangeInverseTable is the table name for the Exchange entity.
	// It exists in this package in order to avoid circular dependency with the "exchange" package.
	ExchangeInverseTable = "exchanges"
	// ExchangeColumn is the table column denoting the exchange relation/edge.
	ExchangeColumn = "trade_record_exchange"
)

// Columns holds all SQL columns for traderecord fields.
var Columns = []string{
	FieldID,
	FieldPrice,
	FieldTimestamp,
	FieldVolume,
	FieldTimeRangeID,
}

var (
	// ConditionsPrimaryKey and ConditionsColumn2 are the table columns denoting the
	// primary key for the conditions relation (M2M).
	ConditionsPrimaryKey = []string{"trade_record_id", "trade_condition_id"}
	// CorrectionPrimaryKey and CorrectionColumn2 are the table columns denoting the
	// primary key for the correction relation (M2M).
	CorrectionPrimaryKey = []string{"trade_record_id", "trade_correction_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

// OrderOption defines the ordering options for the TradeRecord queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByPrice orders the results by the price field.
func ByPrice(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPrice, opts...).ToFunc()
}

// ByTimestamp orders the results by the timestamp field.
func ByTimestamp(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTimestamp, opts...).ToFunc()
}

// ByVolume orders the results by the volume field.
func ByVolume(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldVolume, opts...).ToFunc()
}

// ByTimeRangeID orders the results by the time_range_id field.
func ByTimeRangeID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTimeRangeID, opts...).ToFunc()
}

// ByTimeRangeField orders the results by time_range field.
func ByTimeRangeField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newTimeRangeStep(), sql.OrderByField(field, opts...))
	}
}

// ByConditionsCount orders the results by conditions count.
func ByConditionsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newConditionsStep(), opts...)
	}
}

// ByConditions orders the results by conditions terms.
func ByConditions(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newConditionsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByCorrectionCount orders the results by correction count.
func ByCorrectionCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newCorrectionStep(), opts...)
	}
}

// ByCorrection orders the results by correction terms.
func ByCorrection(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newCorrectionStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByExchangeCount orders the results by exchange count.
func ByExchangeCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newExchangeStep(), opts...)
	}
}

// ByExchange orders the results by exchange terms.
func ByExchange(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newExchangeStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newTimeRangeStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(TimeRangeInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, TimeRangeTable, TimeRangeColumn),
	)
}
func newConditionsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ConditionsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, false, ConditionsTable, ConditionsPrimaryKey...),
	)
}
func newCorrectionStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(CorrectionInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, false, CorrectionTable, CorrectionPrimaryKey...),
	)
}
func newExchangeStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ExchangeInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, ExchangeTable, ExchangeColumn),
	)
}
